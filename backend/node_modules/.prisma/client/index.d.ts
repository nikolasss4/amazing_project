
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model UserMetric
 * 
 */
export type UserMetric = $Result.DefaultSelection<Prisma.$UserMetricPayload>
/**
 * Model Narrative
 * 
 */
export type Narrative = $Result.DefaultSelection<Prisma.$NarrativePayload>
/**
 * Model NarrativeAsset
 * 
 */
export type NarrativeAsset = $Result.DefaultSelection<Prisma.$NarrativeAssetPayload>
/**
 * Model NarrativeEvent
 * 
 */
export type NarrativeEvent = $Result.DefaultSelection<Prisma.$NarrativeEventPayload>
/**
 * Model SocialPost
 * 
 */
export type SocialPost = $Result.DefaultSelection<Prisma.$SocialPostPayload>
/**
 * Model PostTicker
 * 
 */
export type PostTicker = $Result.DefaultSelection<Prisma.$PostTickerPayload>
/**
 * Model PostLike
 * 
 */
export type PostLike = $Result.DefaultSelection<Prisma.$PostLikePayload>
/**
 * Model TrackedAccount
 * 
 */
export type TrackedAccount = $Result.DefaultSelection<Prisma.$TrackedAccountPayload>
/**
 * Model IngestedPost
 * 
 */
export type IngestedPost = $Result.DefaultSelection<Prisma.$IngestedPostPayload>
/**
 * Model CommunityPulse
 * 
 */
export type CommunityPulse = $Result.DefaultSelection<Prisma.$CommunityPulsePayload>
/**
 * Model NewsArticle
 * 
 */
export type NewsArticle = $Result.DefaultSelection<Prisma.$NewsArticlePayload>
/**
 * Model NewsSource
 * 
 */
export type NewsSource = $Result.DefaultSelection<Prisma.$NewsSourcePayload>
/**
 * Model ArticleEntity
 * 
 */
export type ArticleEntity = $Result.DefaultSelection<Prisma.$ArticleEntityPayload>
/**
 * Model DetectedNarrative
 * 
 */
export type DetectedNarrative = $Result.DefaultSelection<Prisma.$DetectedNarrativePayload>
/**
 * Model MarketMessage
 * 
 */
export type MarketMessage = $Result.DefaultSelection<Prisma.$MarketMessagePayload>
/**
 * Model NarrativeFollower
 * 
 */
export type NarrativeFollower = $Result.DefaultSelection<Prisma.$NarrativeFollowerPayload>
/**
 * Model NarrativeMetric
 * 
 */
export type NarrativeMetric = $Result.DefaultSelection<Prisma.$NarrativeMetricPayload>
/**
 * Model DetectedNarrativeArticle
 * 
 */
export type DetectedNarrativeArticle = $Result.DefaultSelection<Prisma.$DetectedNarrativeArticlePayload>
/**
 * Model NarrativeStance
 * 
 */
export type NarrativeStance = $Result.DefaultSelection<Prisma.$NarrativeStancePayload>
/**
 * Model ExternalPost
 * 
 */
export type ExternalPost = $Result.DefaultSelection<Prisma.$ExternalPostPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs>;

  /**
   * `prisma.userMetric`: Exposes CRUD operations for the **UserMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMetrics
    * const userMetrics = await prisma.userMetric.findMany()
    * ```
    */
  get userMetric(): Prisma.UserMetricDelegate<ExtArgs>;

  /**
   * `prisma.narrative`: Exposes CRUD operations for the **Narrative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Narratives
    * const narratives = await prisma.narrative.findMany()
    * ```
    */
  get narrative(): Prisma.NarrativeDelegate<ExtArgs>;

  /**
   * `prisma.narrativeAsset`: Exposes CRUD operations for the **NarrativeAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NarrativeAssets
    * const narrativeAssets = await prisma.narrativeAsset.findMany()
    * ```
    */
  get narrativeAsset(): Prisma.NarrativeAssetDelegate<ExtArgs>;

  /**
   * `prisma.narrativeEvent`: Exposes CRUD operations for the **NarrativeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NarrativeEvents
    * const narrativeEvents = await prisma.narrativeEvent.findMany()
    * ```
    */
  get narrativeEvent(): Prisma.NarrativeEventDelegate<ExtArgs>;

  /**
   * `prisma.socialPost`: Exposes CRUD operations for the **SocialPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialPosts
    * const socialPosts = await prisma.socialPost.findMany()
    * ```
    */
  get socialPost(): Prisma.SocialPostDelegate<ExtArgs>;

  /**
   * `prisma.postTicker`: Exposes CRUD operations for the **PostTicker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTickers
    * const postTickers = await prisma.postTicker.findMany()
    * ```
    */
  get postTicker(): Prisma.PostTickerDelegate<ExtArgs>;

  /**
   * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLike.findMany()
    * ```
    */
  get postLike(): Prisma.PostLikeDelegate<ExtArgs>;

  /**
   * `prisma.trackedAccount`: Exposes CRUD operations for the **TrackedAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrackedAccounts
    * const trackedAccounts = await prisma.trackedAccount.findMany()
    * ```
    */
  get trackedAccount(): Prisma.TrackedAccountDelegate<ExtArgs>;

  /**
   * `prisma.ingestedPost`: Exposes CRUD operations for the **IngestedPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngestedPosts
    * const ingestedPosts = await prisma.ingestedPost.findMany()
    * ```
    */
  get ingestedPost(): Prisma.IngestedPostDelegate<ExtArgs>;

  /**
   * `prisma.communityPulse`: Exposes CRUD operations for the **CommunityPulse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPulses
    * const communityPulses = await prisma.communityPulse.findMany()
    * ```
    */
  get communityPulse(): Prisma.CommunityPulseDelegate<ExtArgs>;

  /**
   * `prisma.newsArticle`: Exposes CRUD operations for the **NewsArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsArticles
    * const newsArticles = await prisma.newsArticle.findMany()
    * ```
    */
  get newsArticle(): Prisma.NewsArticleDelegate<ExtArgs>;

  /**
   * `prisma.newsSource`: Exposes CRUD operations for the **NewsSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsSources
    * const newsSources = await prisma.newsSource.findMany()
    * ```
    */
  get newsSource(): Prisma.NewsSourceDelegate<ExtArgs>;

  /**
   * `prisma.articleEntity`: Exposes CRUD operations for the **ArticleEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleEntities
    * const articleEntities = await prisma.articleEntity.findMany()
    * ```
    */
  get articleEntity(): Prisma.ArticleEntityDelegate<ExtArgs>;

  /**
   * `prisma.detectedNarrative`: Exposes CRUD operations for the **DetectedNarrative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetectedNarratives
    * const detectedNarratives = await prisma.detectedNarrative.findMany()
    * ```
    */
  get detectedNarrative(): Prisma.DetectedNarrativeDelegate<ExtArgs>;

  /**
   * `prisma.marketMessage`: Exposes CRUD operations for the **MarketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketMessages
    * const marketMessages = await prisma.marketMessage.findMany()
    * ```
    */
  get marketMessage(): Prisma.MarketMessageDelegate<ExtArgs>;

  /**
   * `prisma.narrativeFollower`: Exposes CRUD operations for the **NarrativeFollower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NarrativeFollowers
    * const narrativeFollowers = await prisma.narrativeFollower.findMany()
    * ```
    */
  get narrativeFollower(): Prisma.NarrativeFollowerDelegate<ExtArgs>;

  /**
   * `prisma.narrativeMetric`: Exposes CRUD operations for the **NarrativeMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NarrativeMetrics
    * const narrativeMetrics = await prisma.narrativeMetric.findMany()
    * ```
    */
  get narrativeMetric(): Prisma.NarrativeMetricDelegate<ExtArgs>;

  /**
   * `prisma.detectedNarrativeArticle`: Exposes CRUD operations for the **DetectedNarrativeArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetectedNarrativeArticles
    * const detectedNarrativeArticles = await prisma.detectedNarrativeArticle.findMany()
    * ```
    */
  get detectedNarrativeArticle(): Prisma.DetectedNarrativeArticleDelegate<ExtArgs>;

  /**
   * `prisma.narrativeStance`: Exposes CRUD operations for the **NarrativeStance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NarrativeStances
    * const narrativeStances = await prisma.narrativeStance.findMany()
    * ```
    */
  get narrativeStance(): Prisma.NarrativeStanceDelegate<ExtArgs>;

  /**
   * `prisma.externalPost`: Exposes CRUD operations for the **ExternalPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalPosts
    * const externalPosts = await prisma.externalPost.findMany()
    * ```
    */
  get externalPost(): Prisma.ExternalPostDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Friendship: 'Friendship',
    UserMetric: 'UserMetric',
    Narrative: 'Narrative',
    NarrativeAsset: 'NarrativeAsset',
    NarrativeEvent: 'NarrativeEvent',
    SocialPost: 'SocialPost',
    PostTicker: 'PostTicker',
    PostLike: 'PostLike',
    TrackedAccount: 'TrackedAccount',
    IngestedPost: 'IngestedPost',
    CommunityPulse: 'CommunityPulse',
    NewsArticle: 'NewsArticle',
    NewsSource: 'NewsSource',
    ArticleEntity: 'ArticleEntity',
    DetectedNarrative: 'DetectedNarrative',
    MarketMessage: 'MarketMessage',
    NarrativeFollower: 'NarrativeFollower',
    NarrativeMetric: 'NarrativeMetric',
    DetectedNarrativeArticle: 'DetectedNarrativeArticle',
    NarrativeStance: 'NarrativeStance',
    ExternalPost: 'ExternalPost'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "friendship" | "userMetric" | "narrative" | "narrativeAsset" | "narrativeEvent" | "socialPost" | "postTicker" | "postLike" | "trackedAccount" | "ingestedPost" | "communityPulse" | "newsArticle" | "newsSource" | "articleEntity" | "detectedNarrative" | "marketMessage" | "narrativeFollower" | "narrativeMetric" | "detectedNarrativeArticle" | "narrativeStance" | "externalPost"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      UserMetric: {
        payload: Prisma.$UserMetricPayload<ExtArgs>
        fields: Prisma.UserMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          findFirst: {
            args: Prisma.UserMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          findMany: {
            args: Prisma.UserMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>[]
          }
          create: {
            args: Prisma.UserMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          createMany: {
            args: Prisma.UserMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>[]
          }
          delete: {
            args: Prisma.UserMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          update: {
            args: Prisma.UserMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          deleteMany: {
            args: Prisma.UserMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMetricPayload>
          }
          aggregate: {
            args: Prisma.UserMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMetric>
          }
          groupBy: {
            args: Prisma.UserMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMetricCountArgs<ExtArgs>
            result: $Utils.Optional<UserMetricCountAggregateOutputType> | number
          }
        }
      }
      Narrative: {
        payload: Prisma.$NarrativePayload<ExtArgs>
        fields: Prisma.NarrativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          findFirst: {
            args: Prisma.NarrativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          findMany: {
            args: Prisma.NarrativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>[]
          }
          create: {
            args: Prisma.NarrativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          createMany: {
            args: Prisma.NarrativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>[]
          }
          delete: {
            args: Prisma.NarrativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          update: {
            args: Prisma.NarrativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          deleteMany: {
            args: Prisma.NarrativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativePayload>
          }
          aggregate: {
            args: Prisma.NarrativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrative>
          }
          groupBy: {
            args: Prisma.NarrativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeCountAggregateOutputType> | number
          }
        }
      }
      NarrativeAsset: {
        payload: Prisma.$NarrativeAssetPayload<ExtArgs>
        fields: Prisma.NarrativeAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          findFirst: {
            args: Prisma.NarrativeAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          findMany: {
            args: Prisma.NarrativeAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>[]
          }
          create: {
            args: Prisma.NarrativeAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          createMany: {
            args: Prisma.NarrativeAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>[]
          }
          delete: {
            args: Prisma.NarrativeAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          update: {
            args: Prisma.NarrativeAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          deleteMany: {
            args: Prisma.NarrativeAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeAssetPayload>
          }
          aggregate: {
            args: Prisma.NarrativeAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrativeAsset>
          }
          groupBy: {
            args: Prisma.NarrativeAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeAssetCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeAssetCountAggregateOutputType> | number
          }
        }
      }
      NarrativeEvent: {
        payload: Prisma.$NarrativeEventPayload<ExtArgs>
        fields: Prisma.NarrativeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          findFirst: {
            args: Prisma.NarrativeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          findMany: {
            args: Prisma.NarrativeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>[]
          }
          create: {
            args: Prisma.NarrativeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          createMany: {
            args: Prisma.NarrativeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>[]
          }
          delete: {
            args: Prisma.NarrativeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          update: {
            args: Prisma.NarrativeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          deleteMany: {
            args: Prisma.NarrativeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeEventPayload>
          }
          aggregate: {
            args: Prisma.NarrativeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrativeEvent>
          }
          groupBy: {
            args: Prisma.NarrativeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeEventCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeEventCountAggregateOutputType> | number
          }
        }
      }
      SocialPost: {
        payload: Prisma.$SocialPostPayload<ExtArgs>
        fields: Prisma.SocialPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          findFirst: {
            args: Prisma.SocialPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          findMany: {
            args: Prisma.SocialPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>[]
          }
          create: {
            args: Prisma.SocialPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          createMany: {
            args: Prisma.SocialPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>[]
          }
          delete: {
            args: Prisma.SocialPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          update: {
            args: Prisma.SocialPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          deleteMany: {
            args: Prisma.SocialPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPostPayload>
          }
          aggregate: {
            args: Prisma.SocialPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialPost>
          }
          groupBy: {
            args: Prisma.SocialPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialPostCountArgs<ExtArgs>
            result: $Utils.Optional<SocialPostCountAggregateOutputType> | number
          }
        }
      }
      PostTicker: {
        payload: Prisma.$PostTickerPayload<ExtArgs>
        fields: Prisma.PostTickerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTickerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTickerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          findFirst: {
            args: Prisma.PostTickerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTickerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          findMany: {
            args: Prisma.PostTickerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>[]
          }
          create: {
            args: Prisma.PostTickerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          createMany: {
            args: Prisma.PostTickerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTickerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>[]
          }
          delete: {
            args: Prisma.PostTickerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          update: {
            args: Prisma.PostTickerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          deleteMany: {
            args: Prisma.PostTickerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTickerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostTickerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTickerPayload>
          }
          aggregate: {
            args: Prisma.PostTickerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTicker>
          }
          groupBy: {
            args: Prisma.PostTickerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTickerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTickerCountArgs<ExtArgs>
            result: $Utils.Optional<PostTickerCountAggregateOutputType> | number
          }
        }
      }
      PostLike: {
        payload: Prisma.$PostLikePayload<ExtArgs>
        fields: Prisma.PostLikeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostLikeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostLikeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findFirst: {
            args: Prisma.PostLikeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostLikeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          findMany: {
            args: Prisma.PostLikeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          create: {
            args: Prisma.PostLikeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          createMany: {
            args: Prisma.PostLikeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostLikeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>[]
          }
          delete: {
            args: Prisma.PostLikeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          update: {
            args: Prisma.PostLikeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          deleteMany: {
            args: Prisma.PostLikeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostLikeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostLikeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostLikePayload>
          }
          aggregate: {
            args: Prisma.PostLikeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostLike>
          }
          groupBy: {
            args: Prisma.PostLikeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostLikeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostLikeCountArgs<ExtArgs>
            result: $Utils.Optional<PostLikeCountAggregateOutputType> | number
          }
        }
      }
      TrackedAccount: {
        payload: Prisma.$TrackedAccountPayload<ExtArgs>
        fields: Prisma.TrackedAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackedAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackedAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          findFirst: {
            args: Prisma.TrackedAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackedAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          findMany: {
            args: Prisma.TrackedAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>[]
          }
          create: {
            args: Prisma.TrackedAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          createMany: {
            args: Prisma.TrackedAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackedAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>[]
          }
          delete: {
            args: Prisma.TrackedAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          update: {
            args: Prisma.TrackedAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          deleteMany: {
            args: Prisma.TrackedAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackedAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrackedAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackedAccountPayload>
          }
          aggregate: {
            args: Prisma.TrackedAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackedAccount>
          }
          groupBy: {
            args: Prisma.TrackedAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackedAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackedAccountCountArgs<ExtArgs>
            result: $Utils.Optional<TrackedAccountCountAggregateOutputType> | number
          }
        }
      }
      IngestedPost: {
        payload: Prisma.$IngestedPostPayload<ExtArgs>
        fields: Prisma.IngestedPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestedPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestedPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          findFirst: {
            args: Prisma.IngestedPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestedPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          findMany: {
            args: Prisma.IngestedPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>[]
          }
          create: {
            args: Prisma.IngestedPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          createMany: {
            args: Prisma.IngestedPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestedPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>[]
          }
          delete: {
            args: Prisma.IngestedPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          update: {
            args: Prisma.IngestedPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          deleteMany: {
            args: Prisma.IngestedPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestedPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IngestedPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedPostPayload>
          }
          aggregate: {
            args: Prisma.IngestedPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestedPost>
          }
          groupBy: {
            args: Prisma.IngestedPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestedPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestedPostCountArgs<ExtArgs>
            result: $Utils.Optional<IngestedPostCountAggregateOutputType> | number
          }
        }
      }
      CommunityPulse: {
        payload: Prisma.$CommunityPulsePayload<ExtArgs>
        fields: Prisma.CommunityPulseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityPulseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityPulseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          findFirst: {
            args: Prisma.CommunityPulseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityPulseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          findMany: {
            args: Prisma.CommunityPulseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>[]
          }
          create: {
            args: Prisma.CommunityPulseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          createMany: {
            args: Prisma.CommunityPulseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityPulseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>[]
          }
          delete: {
            args: Prisma.CommunityPulseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          update: {
            args: Prisma.CommunityPulseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          deleteMany: {
            args: Prisma.CommunityPulseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityPulseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityPulseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPulsePayload>
          }
          aggregate: {
            args: Prisma.CommunityPulseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityPulse>
          }
          groupBy: {
            args: Prisma.CommunityPulseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityPulseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityPulseCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityPulseCountAggregateOutputType> | number
          }
        }
      }
      NewsArticle: {
        payload: Prisma.$NewsArticlePayload<ExtArgs>
        fields: Prisma.NewsArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findFirst: {
            args: Prisma.NewsArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          findMany: {
            args: Prisma.NewsArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          create: {
            args: Prisma.NewsArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          createMany: {
            args: Prisma.NewsArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>[]
          }
          delete: {
            args: Prisma.NewsArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          update: {
            args: Prisma.NewsArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          deleteMany: {
            args: Prisma.NewsArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsArticlePayload>
          }
          aggregate: {
            args: Prisma.NewsArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsArticle>
          }
          groupBy: {
            args: Prisma.NewsArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsArticleCountArgs<ExtArgs>
            result: $Utils.Optional<NewsArticleCountAggregateOutputType> | number
          }
        }
      }
      NewsSource: {
        payload: Prisma.$NewsSourcePayload<ExtArgs>
        fields: Prisma.NewsSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NewsSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NewsSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findFirst: {
            args: Prisma.NewsSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NewsSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          findMany: {
            args: Prisma.NewsSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          create: {
            args: Prisma.NewsSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          createMany: {
            args: Prisma.NewsSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NewsSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>[]
          }
          delete: {
            args: Prisma.NewsSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          update: {
            args: Prisma.NewsSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          deleteMany: {
            args: Prisma.NewsSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NewsSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NewsSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NewsSourcePayload>
          }
          aggregate: {
            args: Prisma.NewsSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsSource>
          }
          groupBy: {
            args: Prisma.NewsSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NewsSourceCountArgs<ExtArgs>
            result: $Utils.Optional<NewsSourceCountAggregateOutputType> | number
          }
        }
      }
      ArticleEntity: {
        payload: Prisma.$ArticleEntityPayload<ExtArgs>
        fields: Prisma.ArticleEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          findFirst: {
            args: Prisma.ArticleEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          findMany: {
            args: Prisma.ArticleEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>[]
          }
          create: {
            args: Prisma.ArticleEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          createMany: {
            args: Prisma.ArticleEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>[]
          }
          delete: {
            args: Prisma.ArticleEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          update: {
            args: Prisma.ArticleEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          deleteMany: {
            args: Prisma.ArticleEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleEntityPayload>
          }
          aggregate: {
            args: Prisma.ArticleEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleEntity>
          }
          groupBy: {
            args: Prisma.ArticleEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleEntityCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleEntityCountAggregateOutputType> | number
          }
        }
      }
      DetectedNarrative: {
        payload: Prisma.$DetectedNarrativePayload<ExtArgs>
        fields: Prisma.DetectedNarrativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetectedNarrativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetectedNarrativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          findFirst: {
            args: Prisma.DetectedNarrativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetectedNarrativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          findMany: {
            args: Prisma.DetectedNarrativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>[]
          }
          create: {
            args: Prisma.DetectedNarrativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          createMany: {
            args: Prisma.DetectedNarrativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetectedNarrativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>[]
          }
          delete: {
            args: Prisma.DetectedNarrativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          update: {
            args: Prisma.DetectedNarrativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          deleteMany: {
            args: Prisma.DetectedNarrativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetectedNarrativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetectedNarrativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativePayload>
          }
          aggregate: {
            args: Prisma.DetectedNarrativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetectedNarrative>
          }
          groupBy: {
            args: Prisma.DetectedNarrativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetectedNarrativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetectedNarrativeCountArgs<ExtArgs>
            result: $Utils.Optional<DetectedNarrativeCountAggregateOutputType> | number
          }
        }
      }
      MarketMessage: {
        payload: Prisma.$MarketMessagePayload<ExtArgs>
        fields: Prisma.MarketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          findFirst: {
            args: Prisma.MarketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          findMany: {
            args: Prisma.MarketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>[]
          }
          create: {
            args: Prisma.MarketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          createMany: {
            args: Prisma.MarketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>[]
          }
          delete: {
            args: Prisma.MarketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          update: {
            args: Prisma.MarketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          deleteMany: {
            args: Prisma.MarketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketMessagePayload>
          }
          aggregate: {
            args: Prisma.MarketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketMessage>
          }
          groupBy: {
            args: Prisma.MarketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<MarketMessageCountAggregateOutputType> | number
          }
        }
      }
      NarrativeFollower: {
        payload: Prisma.$NarrativeFollowerPayload<ExtArgs>
        fields: Prisma.NarrativeFollowerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeFollowerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeFollowerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          findFirst: {
            args: Prisma.NarrativeFollowerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeFollowerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          findMany: {
            args: Prisma.NarrativeFollowerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>[]
          }
          create: {
            args: Prisma.NarrativeFollowerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          createMany: {
            args: Prisma.NarrativeFollowerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeFollowerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>[]
          }
          delete: {
            args: Prisma.NarrativeFollowerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          update: {
            args: Prisma.NarrativeFollowerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          deleteMany: {
            args: Prisma.NarrativeFollowerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeFollowerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeFollowerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeFollowerPayload>
          }
          aggregate: {
            args: Prisma.NarrativeFollowerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrativeFollower>
          }
          groupBy: {
            args: Prisma.NarrativeFollowerGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeFollowerGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeFollowerCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeFollowerCountAggregateOutputType> | number
          }
        }
      }
      NarrativeMetric: {
        payload: Prisma.$NarrativeMetricPayload<ExtArgs>
        fields: Prisma.NarrativeMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          findFirst: {
            args: Prisma.NarrativeMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          findMany: {
            args: Prisma.NarrativeMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>[]
          }
          create: {
            args: Prisma.NarrativeMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          createMany: {
            args: Prisma.NarrativeMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>[]
          }
          delete: {
            args: Prisma.NarrativeMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          update: {
            args: Prisma.NarrativeMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          deleteMany: {
            args: Prisma.NarrativeMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeMetricPayload>
          }
          aggregate: {
            args: Prisma.NarrativeMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrativeMetric>
          }
          groupBy: {
            args: Prisma.NarrativeMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeMetricCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeMetricCountAggregateOutputType> | number
          }
        }
      }
      DetectedNarrativeArticle: {
        payload: Prisma.$DetectedNarrativeArticlePayload<ExtArgs>
        fields: Prisma.DetectedNarrativeArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetectedNarrativeArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetectedNarrativeArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          findFirst: {
            args: Prisma.DetectedNarrativeArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetectedNarrativeArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          findMany: {
            args: Prisma.DetectedNarrativeArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>[]
          }
          create: {
            args: Prisma.DetectedNarrativeArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          createMany: {
            args: Prisma.DetectedNarrativeArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetectedNarrativeArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>[]
          }
          delete: {
            args: Prisma.DetectedNarrativeArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          update: {
            args: Prisma.DetectedNarrativeArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          deleteMany: {
            args: Prisma.DetectedNarrativeArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetectedNarrativeArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetectedNarrativeArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetectedNarrativeArticlePayload>
          }
          aggregate: {
            args: Prisma.DetectedNarrativeArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetectedNarrativeArticle>
          }
          groupBy: {
            args: Prisma.DetectedNarrativeArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetectedNarrativeArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetectedNarrativeArticleCountArgs<ExtArgs>
            result: $Utils.Optional<DetectedNarrativeArticleCountAggregateOutputType> | number
          }
        }
      }
      NarrativeStance: {
        payload: Prisma.$NarrativeStancePayload<ExtArgs>
        fields: Prisma.NarrativeStanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NarrativeStanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NarrativeStanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          findFirst: {
            args: Prisma.NarrativeStanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NarrativeStanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          findMany: {
            args: Prisma.NarrativeStanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>[]
          }
          create: {
            args: Prisma.NarrativeStanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          createMany: {
            args: Prisma.NarrativeStanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NarrativeStanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>[]
          }
          delete: {
            args: Prisma.NarrativeStanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          update: {
            args: Prisma.NarrativeStanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          deleteMany: {
            args: Prisma.NarrativeStanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NarrativeStanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NarrativeStanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NarrativeStancePayload>
          }
          aggregate: {
            args: Prisma.NarrativeStanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNarrativeStance>
          }
          groupBy: {
            args: Prisma.NarrativeStanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NarrativeStanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NarrativeStanceCountArgs<ExtArgs>
            result: $Utils.Optional<NarrativeStanceCountAggregateOutputType> | number
          }
        }
      }
      ExternalPost: {
        payload: Prisma.$ExternalPostPayload<ExtArgs>
        fields: Prisma.ExternalPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          findFirst: {
            args: Prisma.ExternalPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          findMany: {
            args: Prisma.ExternalPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>[]
          }
          create: {
            args: Prisma.ExternalPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          createMany: {
            args: Prisma.ExternalPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>[]
          }
          delete: {
            args: Prisma.ExternalPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          update: {
            args: Prisma.ExternalPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          deleteMany: {
            args: Prisma.ExternalPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExternalPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalPostPayload>
          }
          aggregate: {
            args: Prisma.ExternalPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalPost>
          }
          groupBy: {
            args: Prisma.ExternalPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalPostCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalPostCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    friendshipsAsUser: number
    friendshipsAsFriend: number
    narrativeFollowers: number
    userMetrics: number
    socialPosts: number
    postLikes: number
    marketMessages: number
    narrativeStances: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    friendshipsAsUser?: boolean | UserCountOutputTypeCountFriendshipsAsUserArgs
    friendshipsAsFriend?: boolean | UserCountOutputTypeCountFriendshipsAsFriendArgs
    narrativeFollowers?: boolean | UserCountOutputTypeCountNarrativeFollowersArgs
    userMetrics?: boolean | UserCountOutputTypeCountUserMetricsArgs
    socialPosts?: boolean | UserCountOutputTypeCountSocialPostsArgs
    postLikes?: boolean | UserCountOutputTypeCountPostLikesArgs
    marketMessages?: boolean | UserCountOutputTypeCountMarketMessagesArgs
    narrativeStances?: boolean | UserCountOutputTypeCountNarrativeStancesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipsAsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendshipsAsFriendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNarrativeFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeFollowerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMetricWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMarketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNarrativeStancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeStanceWhereInput
  }


  /**
   * Count Type NarrativeCountOutputType
   */

  export type NarrativeCountOutputType = {
    assets: number
    events: number
    posts: number
    pulse: number
  }

  export type NarrativeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | NarrativeCountOutputTypeCountAssetsArgs
    events?: boolean | NarrativeCountOutputTypeCountEventsArgs
    posts?: boolean | NarrativeCountOutputTypeCountPostsArgs
    pulse?: boolean | NarrativeCountOutputTypeCountPulseArgs
  }

  // Custom InputTypes
  /**
   * NarrativeCountOutputType without action
   */
  export type NarrativeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeCountOutputType
     */
    select?: NarrativeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NarrativeCountOutputType without action
   */
  export type NarrativeCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeAssetWhereInput
  }

  /**
   * NarrativeCountOutputType without action
   */
  export type NarrativeCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeEventWhereInput
  }

  /**
   * NarrativeCountOutputType without action
   */
  export type NarrativeCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestedPostWhereInput
  }

  /**
   * NarrativeCountOutputType without action
   */
  export type NarrativeCountOutputTypeCountPulseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPulseWhereInput
  }


  /**
   * Count Type SocialPostCountOutputType
   */

  export type SocialPostCountOutputType = {
    tickers: number
    likes: number
  }

  export type SocialPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickers?: boolean | SocialPostCountOutputTypeCountTickersArgs
    likes?: boolean | SocialPostCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes
  /**
   * SocialPostCountOutputType without action
   */
  export type SocialPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPostCountOutputType
     */
    select?: SocialPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialPostCountOutputType without action
   */
  export type SocialPostCountOutputTypeCountTickersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTickerWhereInput
  }

  /**
   * SocialPostCountOutputType without action
   */
  export type SocialPostCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
  }


  /**
   * Count Type TrackedAccountCountOutputType
   */

  export type TrackedAccountCountOutputType = {
    posts: number
  }

  export type TrackedAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TrackedAccountCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TrackedAccountCountOutputType without action
   */
  export type TrackedAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccountCountOutputType
     */
    select?: TrackedAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrackedAccountCountOutputType without action
   */
  export type TrackedAccountCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestedPostWhereInput
  }


  /**
   * Count Type DetectedNarrativeCountOutputType
   */

  export type DetectedNarrativeCountOutputType = {
    articles: number
    metrics: number
    followers: number
    messages: number
    stances: number
  }

  export type DetectedNarrativeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | DetectedNarrativeCountOutputTypeCountArticlesArgs
    metrics?: boolean | DetectedNarrativeCountOutputTypeCountMetricsArgs
    followers?: boolean | DetectedNarrativeCountOutputTypeCountFollowersArgs
    messages?: boolean | DetectedNarrativeCountOutputTypeCountMessagesArgs
    stances?: boolean | DetectedNarrativeCountOutputTypeCountStancesArgs
  }

  // Custom InputTypes
  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeCountOutputType
     */
    select?: DetectedNarrativeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectedNarrativeArticleWhereInput
  }

  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeMetricWhereInput
  }

  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeFollowerWhereInput
  }

  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMessageWhereInput
  }

  /**
   * DetectedNarrativeCountOutputType without action
   */
  export type DetectedNarrativeCountOutputTypeCountStancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeStanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    profileMetadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    profileMetadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    profileMetadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    profileMetadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    profileMetadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    profileMetadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string | null
    profileMetadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    profileMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    friendshipsAsUser?: boolean | User$friendshipsAsUserArgs<ExtArgs>
    friendshipsAsFriend?: boolean | User$friendshipsAsFriendArgs<ExtArgs>
    narrativeFollowers?: boolean | User$narrativeFollowersArgs<ExtArgs>
    userMetrics?: boolean | User$userMetricsArgs<ExtArgs>
    socialPosts?: boolean | User$socialPostsArgs<ExtArgs>
    postLikes?: boolean | User$postLikesArgs<ExtArgs>
    marketMessages?: boolean | User$marketMessagesArgs<ExtArgs>
    narrativeStances?: boolean | User$narrativeStancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    profileMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    profileMetadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    friendshipsAsUser?: boolean | User$friendshipsAsUserArgs<ExtArgs>
    friendshipsAsFriend?: boolean | User$friendshipsAsFriendArgs<ExtArgs>
    narrativeFollowers?: boolean | User$narrativeFollowersArgs<ExtArgs>
    userMetrics?: boolean | User$userMetricsArgs<ExtArgs>
    socialPosts?: boolean | User$socialPostsArgs<ExtArgs>
    postLikes?: boolean | User$postLikesArgs<ExtArgs>
    marketMessages?: boolean | User$marketMessagesArgs<ExtArgs>
    narrativeStances?: boolean | User$narrativeStancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      friendshipsAsUser: Prisma.$FriendshipPayload<ExtArgs>[]
      friendshipsAsFriend: Prisma.$FriendshipPayload<ExtArgs>[]
      narrativeFollowers: Prisma.$NarrativeFollowerPayload<ExtArgs>[]
      userMetrics: Prisma.$UserMetricPayload<ExtArgs>[]
      socialPosts: Prisma.$SocialPostPayload<ExtArgs>[]
      postLikes: Prisma.$PostLikePayload<ExtArgs>[]
      marketMessages: Prisma.$MarketMessagePayload<ExtArgs>[]
      narrativeStances: Prisma.$NarrativeStancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string | null
      profileMetadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    friendshipsAsUser<T extends User$friendshipsAsUserArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipsAsUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friendshipsAsFriend<T extends User$friendshipsAsFriendArgs<ExtArgs> = {}>(args?: Subset<T, User$friendshipsAsFriendArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany"> | Null>
    narrativeFollowers<T extends User$narrativeFollowersArgs<ExtArgs> = {}>(args?: Subset<T, User$narrativeFollowersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findMany"> | Null>
    userMetrics<T extends User$userMetricsArgs<ExtArgs> = {}>(args?: Subset<T, User$userMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findMany"> | Null>
    socialPosts<T extends User$socialPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findMany"> | Null>
    postLikes<T extends User$postLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$postLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany"> | Null>
    marketMessages<T extends User$marketMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$marketMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    narrativeStances<T extends User$narrativeStancesArgs<ExtArgs> = {}>(args?: Subset<T, User$narrativeStancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly profileMetadata: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.friendshipsAsUser
   */
  export type User$friendshipsAsUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friendshipsAsFriend
   */
  export type User$friendshipsAsFriendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.narrativeFollowers
   */
  export type User$narrativeFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    where?: NarrativeFollowerWhereInput
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    cursor?: NarrativeFollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeFollowerScalarFieldEnum | NarrativeFollowerScalarFieldEnum[]
  }

  /**
   * User.userMetrics
   */
  export type User$userMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    where?: UserMetricWhereInput
    orderBy?: UserMetricOrderByWithRelationInput | UserMetricOrderByWithRelationInput[]
    cursor?: UserMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMetricScalarFieldEnum | UserMetricScalarFieldEnum[]
  }

  /**
   * User.socialPosts
   */
  export type User$socialPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    where?: SocialPostWhereInput
    orderBy?: SocialPostOrderByWithRelationInput | SocialPostOrderByWithRelationInput[]
    cursor?: SocialPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialPostScalarFieldEnum | SocialPostScalarFieldEnum[]
  }

  /**
   * User.postLikes
   */
  export type User$postLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * User.marketMessages
   */
  export type User$marketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    where?: MarketMessageWhereInput
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    cursor?: MarketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketMessageScalarFieldEnum | MarketMessageScalarFieldEnum[]
  }

  /**
   * User.narrativeStances
   */
  export type User$narrativeStancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    where?: NarrativeStanceWhereInput
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    cursor?: NarrativeStanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeStanceScalarFieldEnum | NarrativeStanceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    friendId: string | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    userId: number
    friendId: number
    createdAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    userId?: true
    friendId?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    userId: string
    friendId: string
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    friendId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    userId?: boolean
    friendId?: boolean
    createdAt?: boolean
  }

  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    friend?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      friend: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      friendId: string
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    friend<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */ 
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly userId: FieldRef<"Friendship", 'String'>
    readonly friendId: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model UserMetric
   */

  export type AggregateUserMetric = {
    _count: UserMetricCountAggregateOutputType | null
    _avg: UserMetricAvgAggregateOutputType | null
    _sum: UserMetricSumAggregateOutputType | null
    _min: UserMetricMinAggregateOutputType | null
    _max: UserMetricMaxAggregateOutputType | null
  }

  export type UserMetricAvgAggregateOutputType = {
    returnPercent: number | null
    winRate: number | null
    tradesCount: number | null
  }

  export type UserMetricSumAggregateOutputType = {
    returnPercent: number | null
    winRate: number | null
    tradesCount: number | null
  }

  export type UserMetricMinAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    returnPercent: number | null
    winRate: number | null
    tradesCount: number | null
    calculatedAt: Date | null
  }

  export type UserMetricMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    period: string | null
    returnPercent: number | null
    winRate: number | null
    tradesCount: number | null
    calculatedAt: Date | null
  }

  export type UserMetricCountAggregateOutputType = {
    id: number
    userId: number
    period: number
    returnPercent: number
    winRate: number
    tradesCount: number
    calculatedAt: number
    _all: number
  }


  export type UserMetricAvgAggregateInputType = {
    returnPercent?: true
    winRate?: true
    tradesCount?: true
  }

  export type UserMetricSumAggregateInputType = {
    returnPercent?: true
    winRate?: true
    tradesCount?: true
  }

  export type UserMetricMinAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    returnPercent?: true
    winRate?: true
    tradesCount?: true
    calculatedAt?: true
  }

  export type UserMetricMaxAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    returnPercent?: true
    winRate?: true
    tradesCount?: true
    calculatedAt?: true
  }

  export type UserMetricCountAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    returnPercent?: true
    winRate?: true
    tradesCount?: true
    calculatedAt?: true
    _all?: true
  }

  export type UserMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMetric to aggregate.
     */
    where?: UserMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetrics to fetch.
     */
    orderBy?: UserMetricOrderByWithRelationInput | UserMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMetrics
    **/
    _count?: true | UserMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMetricMaxAggregateInputType
  }

  export type GetUserMetricAggregateType<T extends UserMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMetric[P]>
      : GetScalarType<T[P], AggregateUserMetric[P]>
  }




  export type UserMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMetricWhereInput
    orderBy?: UserMetricOrderByWithAggregationInput | UserMetricOrderByWithAggregationInput[]
    by: UserMetricScalarFieldEnum[] | UserMetricScalarFieldEnum
    having?: UserMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMetricCountAggregateInputType | true
    _avg?: UserMetricAvgAggregateInputType
    _sum?: UserMetricSumAggregateInputType
    _min?: UserMetricMinAggregateInputType
    _max?: UserMetricMaxAggregateInputType
  }

  export type UserMetricGroupByOutputType = {
    id: string
    userId: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount: number
    calculatedAt: Date
    _count: UserMetricCountAggregateOutputType | null
    _avg: UserMetricAvgAggregateOutputType | null
    _sum: UserMetricSumAggregateOutputType | null
    _min: UserMetricMinAggregateOutputType | null
    _max: UserMetricMaxAggregateOutputType | null
  }

  type GetUserMetricGroupByPayload<T extends UserMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMetricGroupByOutputType[P]>
            : GetScalarType<T[P], UserMetricGroupByOutputType[P]>
        }
      >
    >


  export type UserMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    returnPercent?: boolean
    winRate?: boolean
    tradesCount?: boolean
    calculatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMetric"]>

  export type UserMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    returnPercent?: boolean
    winRate?: boolean
    tradesCount?: boolean
    calculatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMetric"]>

  export type UserMetricSelectScalar = {
    id?: boolean
    userId?: boolean
    period?: boolean
    returnPercent?: boolean
    winRate?: boolean
    tradesCount?: boolean
    calculatedAt?: boolean
  }

  export type UserMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMetric"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      period: string
      returnPercent: number
      winRate: number
      tradesCount: number
      calculatedAt: Date
    }, ExtArgs["result"]["userMetric"]>
    composites: {}
  }

  type UserMetricGetPayload<S extends boolean | null | undefined | UserMetricDefaultArgs> = $Result.GetResult<Prisma.$UserMetricPayload, S>

  type UserMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserMetricCountAggregateInputType | true
    }

  export interface UserMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMetric'], meta: { name: 'UserMetric' } }
    /**
     * Find zero or one UserMetric that matches the filter.
     * @param {UserMetricFindUniqueArgs} args - Arguments to find a UserMetric
     * @example
     * // Get one UserMetric
     * const userMetric = await prisma.userMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMetricFindUniqueArgs>(args: SelectSubset<T, UserMetricFindUniqueArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserMetricFindUniqueOrThrowArgs} args - Arguments to find a UserMetric
     * @example
     * // Get one UserMetric
     * const userMetric = await prisma.userMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricFindFirstArgs} args - Arguments to find a UserMetric
     * @example
     * // Get one UserMetric
     * const userMetric = await prisma.userMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMetricFindFirstArgs>(args?: SelectSubset<T, UserMetricFindFirstArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricFindFirstOrThrowArgs} args - Arguments to find a UserMetric
     * @example
     * // Get one UserMetric
     * const userMetric = await prisma.userMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMetrics
     * const userMetrics = await prisma.userMetric.findMany()
     * 
     * // Get first 10 UserMetrics
     * const userMetrics = await prisma.userMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMetricWithIdOnly = await prisma.userMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMetricFindManyArgs>(args?: SelectSubset<T, UserMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserMetric.
     * @param {UserMetricCreateArgs} args - Arguments to create a UserMetric.
     * @example
     * // Create one UserMetric
     * const UserMetric = await prisma.userMetric.create({
     *   data: {
     *     // ... data to create a UserMetric
     *   }
     * })
     * 
     */
    create<T extends UserMetricCreateArgs>(args: SelectSubset<T, UserMetricCreateArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserMetrics.
     * @param {UserMetricCreateManyArgs} args - Arguments to create many UserMetrics.
     * @example
     * // Create many UserMetrics
     * const userMetric = await prisma.userMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMetricCreateManyArgs>(args?: SelectSubset<T, UserMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMetrics and returns the data saved in the database.
     * @param {UserMetricCreateManyAndReturnArgs} args - Arguments to create many UserMetrics.
     * @example
     * // Create many UserMetrics
     * const userMetric = await prisma.userMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMetrics and only return the `id`
     * const userMetricWithIdOnly = await prisma.userMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserMetric.
     * @param {UserMetricDeleteArgs} args - Arguments to delete one UserMetric.
     * @example
     * // Delete one UserMetric
     * const UserMetric = await prisma.userMetric.delete({
     *   where: {
     *     // ... filter to delete one UserMetric
     *   }
     * })
     * 
     */
    delete<T extends UserMetricDeleteArgs>(args: SelectSubset<T, UserMetricDeleteArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserMetric.
     * @param {UserMetricUpdateArgs} args - Arguments to update one UserMetric.
     * @example
     * // Update one UserMetric
     * const userMetric = await prisma.userMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMetricUpdateArgs>(args: SelectSubset<T, UserMetricUpdateArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserMetrics.
     * @param {UserMetricDeleteManyArgs} args - Arguments to filter UserMetrics to delete.
     * @example
     * // Delete a few UserMetrics
     * const { count } = await prisma.userMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMetricDeleteManyArgs>(args?: SelectSubset<T, UserMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMetrics
     * const userMetric = await prisma.userMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMetricUpdateManyArgs>(args: SelectSubset<T, UserMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserMetric.
     * @param {UserMetricUpsertArgs} args - Arguments to update or create a UserMetric.
     * @example
     * // Update or create a UserMetric
     * const userMetric = await prisma.userMetric.upsert({
     *   create: {
     *     // ... data to create a UserMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMetric we want to update
     *   }
     * })
     */
    upsert<T extends UserMetricUpsertArgs>(args: SelectSubset<T, UserMetricUpsertArgs<ExtArgs>>): Prisma__UserMetricClient<$Result.GetResult<Prisma.$UserMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricCountArgs} args - Arguments to filter UserMetrics to count.
     * @example
     * // Count the number of UserMetrics
     * const count = await prisma.userMetric.count({
     *   where: {
     *     // ... the filter for the UserMetrics we want to count
     *   }
     * })
    **/
    count<T extends UserMetricCountArgs>(
      args?: Subset<T, UserMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMetricAggregateArgs>(args: Subset<T, UserMetricAggregateArgs>): Prisma.PrismaPromise<GetUserMetricAggregateType<T>>

    /**
     * Group by UserMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMetricGroupByArgs['orderBy'] }
        : { orderBy?: UserMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMetric model
   */
  readonly fields: UserMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMetric model
   */ 
  interface UserMetricFieldRefs {
    readonly id: FieldRef<"UserMetric", 'String'>
    readonly userId: FieldRef<"UserMetric", 'String'>
    readonly period: FieldRef<"UserMetric", 'String'>
    readonly returnPercent: FieldRef<"UserMetric", 'Float'>
    readonly winRate: FieldRef<"UserMetric", 'Float'>
    readonly tradesCount: FieldRef<"UserMetric", 'Int'>
    readonly calculatedAt: FieldRef<"UserMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserMetric findUnique
   */
  export type UserMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter, which UserMetric to fetch.
     */
    where: UserMetricWhereUniqueInput
  }

  /**
   * UserMetric findUniqueOrThrow
   */
  export type UserMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter, which UserMetric to fetch.
     */
    where: UserMetricWhereUniqueInput
  }

  /**
   * UserMetric findFirst
   */
  export type UserMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter, which UserMetric to fetch.
     */
    where?: UserMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetrics to fetch.
     */
    orderBy?: UserMetricOrderByWithRelationInput | UserMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMetrics.
     */
    cursor?: UserMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMetrics.
     */
    distinct?: UserMetricScalarFieldEnum | UserMetricScalarFieldEnum[]
  }

  /**
   * UserMetric findFirstOrThrow
   */
  export type UserMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter, which UserMetric to fetch.
     */
    where?: UserMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetrics to fetch.
     */
    orderBy?: UserMetricOrderByWithRelationInput | UserMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMetrics.
     */
    cursor?: UserMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMetrics.
     */
    distinct?: UserMetricScalarFieldEnum | UserMetricScalarFieldEnum[]
  }

  /**
   * UserMetric findMany
   */
  export type UserMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter, which UserMetrics to fetch.
     */
    where?: UserMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMetrics to fetch.
     */
    orderBy?: UserMetricOrderByWithRelationInput | UserMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMetrics.
     */
    cursor?: UserMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMetrics.
     */
    skip?: number
    distinct?: UserMetricScalarFieldEnum | UserMetricScalarFieldEnum[]
  }

  /**
   * UserMetric create
   */
  export type UserMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMetric.
     */
    data: XOR<UserMetricCreateInput, UserMetricUncheckedCreateInput>
  }

  /**
   * UserMetric createMany
   */
  export type UserMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMetrics.
     */
    data: UserMetricCreateManyInput | UserMetricCreateManyInput[]
  }

  /**
   * UserMetric createManyAndReturn
   */
  export type UserMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserMetrics.
     */
    data: UserMetricCreateManyInput | UserMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMetric update
   */
  export type UserMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMetric.
     */
    data: XOR<UserMetricUpdateInput, UserMetricUncheckedUpdateInput>
    /**
     * Choose, which UserMetric to update.
     */
    where: UserMetricWhereUniqueInput
  }

  /**
   * UserMetric updateMany
   */
  export type UserMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMetrics.
     */
    data: XOR<UserMetricUpdateManyMutationInput, UserMetricUncheckedUpdateManyInput>
    /**
     * Filter which UserMetrics to update
     */
    where?: UserMetricWhereInput
  }

  /**
   * UserMetric upsert
   */
  export type UserMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMetric to update in case it exists.
     */
    where: UserMetricWhereUniqueInput
    /**
     * In case the UserMetric found by the `where` argument doesn't exist, create a new UserMetric with this data.
     */
    create: XOR<UserMetricCreateInput, UserMetricUncheckedCreateInput>
    /**
     * In case the UserMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMetricUpdateInput, UserMetricUncheckedUpdateInput>
  }

  /**
   * UserMetric delete
   */
  export type UserMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
    /**
     * Filter which UserMetric to delete.
     */
    where: UserMetricWhereUniqueInput
  }

  /**
   * UserMetric deleteMany
   */
  export type UserMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMetrics to delete
     */
    where?: UserMetricWhereInput
  }

  /**
   * UserMetric without action
   */
  export type UserMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMetric
     */
    select?: UserMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMetricInclude<ExtArgs> | null
  }


  /**
   * Model Narrative
   */

  export type AggregateNarrative = {
    _count: NarrativeCountAggregateOutputType | null
    _avg: NarrativeAvgAggregateOutputType | null
    _sum: NarrativeSumAggregateOutputType | null
    _min: NarrativeMinAggregateOutputType | null
    _max: NarrativeMaxAggregateOutputType | null
  }

  export type NarrativeAvgAggregateOutputType = {
    mentionCount: number | null
    velocity: number | null
  }

  export type NarrativeSumAggregateOutputType = {
    mentionCount: number | null
    velocity: number | null
  }

  export type NarrativeMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    triggerType: string | null
    triggerValue: string | null
    sentiment: string | null
    mentionCount: number | null
    velocity: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NarrativeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    triggerType: string | null
    triggerValue: string | null
    sentiment: string | null
    mentionCount: number | null
    velocity: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NarrativeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    triggerType: number
    triggerValue: number
    sentiment: number
    mentionCount: number
    velocity: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NarrativeAvgAggregateInputType = {
    mentionCount?: true
    velocity?: true
  }

  export type NarrativeSumAggregateInputType = {
    mentionCount?: true
    velocity?: true
  }

  export type NarrativeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    sentiment?: true
    mentionCount?: true
    velocity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NarrativeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    sentiment?: true
    mentionCount?: true
    velocity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NarrativeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    triggerType?: true
    triggerValue?: true
    sentiment?: true
    mentionCount?: true
    velocity?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NarrativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Narrative to aggregate.
     */
    where?: NarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Narratives to fetch.
     */
    orderBy?: NarrativeOrderByWithRelationInput | NarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Narratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Narratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Narratives
    **/
    _count?: true | NarrativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NarrativeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NarrativeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeMaxAggregateInputType
  }

  export type GetNarrativeAggregateType<T extends NarrativeAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrative[P]>
      : GetScalarType<T[P], AggregateNarrative[P]>
  }




  export type NarrativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeWhereInput
    orderBy?: NarrativeOrderByWithAggregationInput | NarrativeOrderByWithAggregationInput[]
    by: NarrativeScalarFieldEnum[] | NarrativeScalarFieldEnum
    having?: NarrativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeCountAggregateInputType | true
    _avg?: NarrativeAvgAggregateInputType
    _sum?: NarrativeSumAggregateInputType
    _min?: NarrativeMinAggregateInputType
    _max?: NarrativeMaxAggregateInputType
  }

  export type NarrativeGroupByOutputType = {
    id: string
    title: string
    description: string | null
    triggerType: string
    triggerValue: string | null
    sentiment: string
    mentionCount: number
    velocity: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: NarrativeCountAggregateOutputType | null
    _avg: NarrativeAvgAggregateOutputType | null
    _sum: NarrativeSumAggregateOutputType | null
    _min: NarrativeMinAggregateOutputType | null
    _max: NarrativeMaxAggregateOutputType | null
  }

  type GetNarrativeGroupByPayload<T extends NarrativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    sentiment?: boolean
    mentionCount?: boolean
    velocity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assets?: boolean | Narrative$assetsArgs<ExtArgs>
    events?: boolean | Narrative$eventsArgs<ExtArgs>
    posts?: boolean | Narrative$postsArgs<ExtArgs>
    pulse?: boolean | Narrative$pulseArgs<ExtArgs>
    _count?: boolean | NarrativeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrative"]>

  export type NarrativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    sentiment?: boolean
    mentionCount?: boolean
    velocity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["narrative"]>

  export type NarrativeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    triggerType?: boolean
    triggerValue?: boolean
    sentiment?: boolean
    mentionCount?: boolean
    velocity?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NarrativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | Narrative$assetsArgs<ExtArgs>
    events?: boolean | Narrative$eventsArgs<ExtArgs>
    posts?: boolean | Narrative$postsArgs<ExtArgs>
    pulse?: boolean | Narrative$pulseArgs<ExtArgs>
    _count?: boolean | NarrativeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NarrativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NarrativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Narrative"
    objects: {
      assets: Prisma.$NarrativeAssetPayload<ExtArgs>[]
      events: Prisma.$NarrativeEventPayload<ExtArgs>[]
      posts: Prisma.$IngestedPostPayload<ExtArgs>[]
      pulse: Prisma.$CommunityPulsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      triggerType: string
      triggerValue: string | null
      sentiment: string
      mentionCount: number
      velocity: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["narrative"]>
    composites: {}
  }

  type NarrativeGetPayload<S extends boolean | null | undefined | NarrativeDefaultArgs> = $Result.GetResult<Prisma.$NarrativePayload, S>

  type NarrativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeCountAggregateInputType | true
    }

  export interface NarrativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Narrative'], meta: { name: 'Narrative' } }
    /**
     * Find zero or one Narrative that matches the filter.
     * @param {NarrativeFindUniqueArgs} args - Arguments to find a Narrative
     * @example
     * // Get one Narrative
     * const narrative = await prisma.narrative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeFindUniqueArgs>(args: SelectSubset<T, NarrativeFindUniqueArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Narrative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeFindUniqueOrThrowArgs} args - Arguments to find a Narrative
     * @example
     * // Get one Narrative
     * const narrative = await prisma.narrative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Narrative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFindFirstArgs} args - Arguments to find a Narrative
     * @example
     * // Get one Narrative
     * const narrative = await prisma.narrative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeFindFirstArgs>(args?: SelectSubset<T, NarrativeFindFirstArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Narrative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFindFirstOrThrowArgs} args - Arguments to find a Narrative
     * @example
     * // Get one Narrative
     * const narrative = await prisma.narrative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Narratives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Narratives
     * const narratives = await prisma.narrative.findMany()
     * 
     * // Get first 10 Narratives
     * const narratives = await prisma.narrative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeWithIdOnly = await prisma.narrative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeFindManyArgs>(args?: SelectSubset<T, NarrativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Narrative.
     * @param {NarrativeCreateArgs} args - Arguments to create a Narrative.
     * @example
     * // Create one Narrative
     * const Narrative = await prisma.narrative.create({
     *   data: {
     *     // ... data to create a Narrative
     *   }
     * })
     * 
     */
    create<T extends NarrativeCreateArgs>(args: SelectSubset<T, NarrativeCreateArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Narratives.
     * @param {NarrativeCreateManyArgs} args - Arguments to create many Narratives.
     * @example
     * // Create many Narratives
     * const narrative = await prisma.narrative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeCreateManyArgs>(args?: SelectSubset<T, NarrativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Narratives and returns the data saved in the database.
     * @param {NarrativeCreateManyAndReturnArgs} args - Arguments to create many Narratives.
     * @example
     * // Create many Narratives
     * const narrative = await prisma.narrative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Narratives and only return the `id`
     * const narrativeWithIdOnly = await prisma.narrative.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Narrative.
     * @param {NarrativeDeleteArgs} args - Arguments to delete one Narrative.
     * @example
     * // Delete one Narrative
     * const Narrative = await prisma.narrative.delete({
     *   where: {
     *     // ... filter to delete one Narrative
     *   }
     * })
     * 
     */
    delete<T extends NarrativeDeleteArgs>(args: SelectSubset<T, NarrativeDeleteArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Narrative.
     * @param {NarrativeUpdateArgs} args - Arguments to update one Narrative.
     * @example
     * // Update one Narrative
     * const narrative = await prisma.narrative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeUpdateArgs>(args: SelectSubset<T, NarrativeUpdateArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Narratives.
     * @param {NarrativeDeleteManyArgs} args - Arguments to filter Narratives to delete.
     * @example
     * // Delete a few Narratives
     * const { count } = await prisma.narrative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeDeleteManyArgs>(args?: SelectSubset<T, NarrativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Narratives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Narratives
     * const narrative = await prisma.narrative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeUpdateManyArgs>(args: SelectSubset<T, NarrativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Narrative.
     * @param {NarrativeUpsertArgs} args - Arguments to update or create a Narrative.
     * @example
     * // Update or create a Narrative
     * const narrative = await prisma.narrative.upsert({
     *   create: {
     *     // ... data to create a Narrative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Narrative we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeUpsertArgs>(args: SelectSubset<T, NarrativeUpsertArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Narratives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeCountArgs} args - Arguments to filter Narratives to count.
     * @example
     * // Count the number of Narratives
     * const count = await prisma.narrative.count({
     *   where: {
     *     // ... the filter for the Narratives we want to count
     *   }
     * })
    **/
    count<T extends NarrativeCountArgs>(
      args?: Subset<T, NarrativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Narrative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeAggregateArgs>(args: Subset<T, NarrativeAggregateArgs>): Prisma.PrismaPromise<GetNarrativeAggregateType<T>>

    /**
     * Group by Narrative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Narrative model
   */
  readonly fields: NarrativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Narrative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assets<T extends Narrative$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Narrative$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Narrative$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Narrative$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Narrative$postsArgs<ExtArgs> = {}>(args?: Subset<T, Narrative$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findMany"> | Null>
    pulse<T extends Narrative$pulseArgs<ExtArgs> = {}>(args?: Subset<T, Narrative$pulseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Narrative model
   */ 
  interface NarrativeFieldRefs {
    readonly id: FieldRef<"Narrative", 'String'>
    readonly title: FieldRef<"Narrative", 'String'>
    readonly description: FieldRef<"Narrative", 'String'>
    readonly triggerType: FieldRef<"Narrative", 'String'>
    readonly triggerValue: FieldRef<"Narrative", 'String'>
    readonly sentiment: FieldRef<"Narrative", 'String'>
    readonly mentionCount: FieldRef<"Narrative", 'Int'>
    readonly velocity: FieldRef<"Narrative", 'Float'>
    readonly status: FieldRef<"Narrative", 'String'>
    readonly createdAt: FieldRef<"Narrative", 'DateTime'>
    readonly updatedAt: FieldRef<"Narrative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Narrative findUnique
   */
  export type NarrativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter, which Narrative to fetch.
     */
    where: NarrativeWhereUniqueInput
  }

  /**
   * Narrative findUniqueOrThrow
   */
  export type NarrativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter, which Narrative to fetch.
     */
    where: NarrativeWhereUniqueInput
  }

  /**
   * Narrative findFirst
   */
  export type NarrativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter, which Narrative to fetch.
     */
    where?: NarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Narratives to fetch.
     */
    orderBy?: NarrativeOrderByWithRelationInput | NarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Narratives.
     */
    cursor?: NarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Narratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Narratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Narratives.
     */
    distinct?: NarrativeScalarFieldEnum | NarrativeScalarFieldEnum[]
  }

  /**
   * Narrative findFirstOrThrow
   */
  export type NarrativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter, which Narrative to fetch.
     */
    where?: NarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Narratives to fetch.
     */
    orderBy?: NarrativeOrderByWithRelationInput | NarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Narratives.
     */
    cursor?: NarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Narratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Narratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Narratives.
     */
    distinct?: NarrativeScalarFieldEnum | NarrativeScalarFieldEnum[]
  }

  /**
   * Narrative findMany
   */
  export type NarrativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter, which Narratives to fetch.
     */
    where?: NarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Narratives to fetch.
     */
    orderBy?: NarrativeOrderByWithRelationInput | NarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Narratives.
     */
    cursor?: NarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Narratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Narratives.
     */
    skip?: number
    distinct?: NarrativeScalarFieldEnum | NarrativeScalarFieldEnum[]
  }

  /**
   * Narrative create
   */
  export type NarrativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Narrative.
     */
    data: XOR<NarrativeCreateInput, NarrativeUncheckedCreateInput>
  }

  /**
   * Narrative createMany
   */
  export type NarrativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Narratives.
     */
    data: NarrativeCreateManyInput | NarrativeCreateManyInput[]
  }

  /**
   * Narrative createManyAndReturn
   */
  export type NarrativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Narratives.
     */
    data: NarrativeCreateManyInput | NarrativeCreateManyInput[]
  }

  /**
   * Narrative update
   */
  export type NarrativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Narrative.
     */
    data: XOR<NarrativeUpdateInput, NarrativeUncheckedUpdateInput>
    /**
     * Choose, which Narrative to update.
     */
    where: NarrativeWhereUniqueInput
  }

  /**
   * Narrative updateMany
   */
  export type NarrativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Narratives.
     */
    data: XOR<NarrativeUpdateManyMutationInput, NarrativeUncheckedUpdateManyInput>
    /**
     * Filter which Narratives to update
     */
    where?: NarrativeWhereInput
  }

  /**
   * Narrative upsert
   */
  export type NarrativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Narrative to update in case it exists.
     */
    where: NarrativeWhereUniqueInput
    /**
     * In case the Narrative found by the `where` argument doesn't exist, create a new Narrative with this data.
     */
    create: XOR<NarrativeCreateInput, NarrativeUncheckedCreateInput>
    /**
     * In case the Narrative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeUpdateInput, NarrativeUncheckedUpdateInput>
  }

  /**
   * Narrative delete
   */
  export type NarrativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    /**
     * Filter which Narrative to delete.
     */
    where: NarrativeWhereUniqueInput
  }

  /**
   * Narrative deleteMany
   */
  export type NarrativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Narratives to delete
     */
    where?: NarrativeWhereInput
  }

  /**
   * Narrative.assets
   */
  export type Narrative$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    where?: NarrativeAssetWhereInput
    orderBy?: NarrativeAssetOrderByWithRelationInput | NarrativeAssetOrderByWithRelationInput[]
    cursor?: NarrativeAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeAssetScalarFieldEnum | NarrativeAssetScalarFieldEnum[]
  }

  /**
   * Narrative.events
   */
  export type Narrative$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    where?: NarrativeEventWhereInput
    orderBy?: NarrativeEventOrderByWithRelationInput | NarrativeEventOrderByWithRelationInput[]
    cursor?: NarrativeEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeEventScalarFieldEnum | NarrativeEventScalarFieldEnum[]
  }

  /**
   * Narrative.posts
   */
  export type Narrative$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    where?: IngestedPostWhereInput
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    cursor?: IngestedPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestedPostScalarFieldEnum | IngestedPostScalarFieldEnum[]
  }

  /**
   * Narrative.pulse
   */
  export type Narrative$pulseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    where?: CommunityPulseWhereInput
    orderBy?: CommunityPulseOrderByWithRelationInput | CommunityPulseOrderByWithRelationInput[]
    cursor?: CommunityPulseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityPulseScalarFieldEnum | CommunityPulseScalarFieldEnum[]
  }

  /**
   * Narrative without action
   */
  export type NarrativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
  }


  /**
   * Model NarrativeAsset
   */

  export type AggregateNarrativeAsset = {
    _count: NarrativeAssetCountAggregateOutputType | null
    _avg: NarrativeAssetAvgAggregateOutputType | null
    _sum: NarrativeAssetSumAggregateOutputType | null
    _min: NarrativeAssetMinAggregateOutputType | null
    _max: NarrativeAssetMaxAggregateOutputType | null
  }

  export type NarrativeAssetAvgAggregateOutputType = {
    impact: number | null
  }

  export type NarrativeAssetSumAggregateOutputType = {
    impact: number | null
  }

  export type NarrativeAssetMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    assetSymbol: string | null
    impact: number | null
    createdAt: Date | null
  }

  export type NarrativeAssetMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    assetSymbol: string | null
    impact: number | null
    createdAt: Date | null
  }

  export type NarrativeAssetCountAggregateOutputType = {
    id: number
    narrativeId: number
    assetSymbol: number
    impact: number
    createdAt: number
    _all: number
  }


  export type NarrativeAssetAvgAggregateInputType = {
    impact?: true
  }

  export type NarrativeAssetSumAggregateInputType = {
    impact?: true
  }

  export type NarrativeAssetMinAggregateInputType = {
    id?: true
    narrativeId?: true
    assetSymbol?: true
    impact?: true
    createdAt?: true
  }

  export type NarrativeAssetMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    assetSymbol?: true
    impact?: true
    createdAt?: true
  }

  export type NarrativeAssetCountAggregateInputType = {
    id?: true
    narrativeId?: true
    assetSymbol?: true
    impact?: true
    createdAt?: true
    _all?: true
  }

  export type NarrativeAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeAsset to aggregate.
     */
    where?: NarrativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeAssets to fetch.
     */
    orderBy?: NarrativeAssetOrderByWithRelationInput | NarrativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NarrativeAssets
    **/
    _count?: true | NarrativeAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NarrativeAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NarrativeAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeAssetMaxAggregateInputType
  }

  export type GetNarrativeAssetAggregateType<T extends NarrativeAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrativeAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrativeAsset[P]>
      : GetScalarType<T[P], AggregateNarrativeAsset[P]>
  }




  export type NarrativeAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeAssetWhereInput
    orderBy?: NarrativeAssetOrderByWithAggregationInput | NarrativeAssetOrderByWithAggregationInput[]
    by: NarrativeAssetScalarFieldEnum[] | NarrativeAssetScalarFieldEnum
    having?: NarrativeAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeAssetCountAggregateInputType | true
    _avg?: NarrativeAssetAvgAggregateInputType
    _sum?: NarrativeAssetSumAggregateInputType
    _min?: NarrativeAssetMinAggregateInputType
    _max?: NarrativeAssetMaxAggregateInputType
  }

  export type NarrativeAssetGroupByOutputType = {
    id: string
    narrativeId: string
    assetSymbol: string
    impact: number | null
    createdAt: Date
    _count: NarrativeAssetCountAggregateOutputType | null
    _avg: NarrativeAssetAvgAggregateOutputType | null
    _sum: NarrativeAssetSumAggregateOutputType | null
    _min: NarrativeAssetMinAggregateOutputType | null
    _max: NarrativeAssetMaxAggregateOutputType | null
  }

  type GetNarrativeAssetGroupByPayload<T extends NarrativeAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeAssetGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeAssetGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    assetSymbol?: boolean
    impact?: boolean
    createdAt?: boolean
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeAsset"]>

  export type NarrativeAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    assetSymbol?: boolean
    impact?: boolean
    createdAt?: boolean
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeAsset"]>

  export type NarrativeAssetSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    assetSymbol?: boolean
    impact?: boolean
    createdAt?: boolean
  }

  export type NarrativeAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }
  export type NarrativeAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }

  export type $NarrativeAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NarrativeAsset"
    objects: {
      narrative: Prisma.$NarrativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      assetSymbol: string
      impact: number | null
      createdAt: Date
    }, ExtArgs["result"]["narrativeAsset"]>
    composites: {}
  }

  type NarrativeAssetGetPayload<S extends boolean | null | undefined | NarrativeAssetDefaultArgs> = $Result.GetResult<Prisma.$NarrativeAssetPayload, S>

  type NarrativeAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeAssetCountAggregateInputType | true
    }

  export interface NarrativeAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NarrativeAsset'], meta: { name: 'NarrativeAsset' } }
    /**
     * Find zero or one NarrativeAsset that matches the filter.
     * @param {NarrativeAssetFindUniqueArgs} args - Arguments to find a NarrativeAsset
     * @example
     * // Get one NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeAssetFindUniqueArgs>(args: SelectSubset<T, NarrativeAssetFindUniqueArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NarrativeAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeAssetFindUniqueOrThrowArgs} args - Arguments to find a NarrativeAsset
     * @example
     * // Get one NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NarrativeAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetFindFirstArgs} args - Arguments to find a NarrativeAsset
     * @example
     * // Get one NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeAssetFindFirstArgs>(args?: SelectSubset<T, NarrativeAssetFindFirstArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NarrativeAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetFindFirstOrThrowArgs} args - Arguments to find a NarrativeAsset
     * @example
     * // Get one NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NarrativeAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NarrativeAssets
     * const narrativeAssets = await prisma.narrativeAsset.findMany()
     * 
     * // Get first 10 NarrativeAssets
     * const narrativeAssets = await prisma.narrativeAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeAssetWithIdOnly = await prisma.narrativeAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeAssetFindManyArgs>(args?: SelectSubset<T, NarrativeAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NarrativeAsset.
     * @param {NarrativeAssetCreateArgs} args - Arguments to create a NarrativeAsset.
     * @example
     * // Create one NarrativeAsset
     * const NarrativeAsset = await prisma.narrativeAsset.create({
     *   data: {
     *     // ... data to create a NarrativeAsset
     *   }
     * })
     * 
     */
    create<T extends NarrativeAssetCreateArgs>(args: SelectSubset<T, NarrativeAssetCreateArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NarrativeAssets.
     * @param {NarrativeAssetCreateManyArgs} args - Arguments to create many NarrativeAssets.
     * @example
     * // Create many NarrativeAssets
     * const narrativeAsset = await prisma.narrativeAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeAssetCreateManyArgs>(args?: SelectSubset<T, NarrativeAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NarrativeAssets and returns the data saved in the database.
     * @param {NarrativeAssetCreateManyAndReturnArgs} args - Arguments to create many NarrativeAssets.
     * @example
     * // Create many NarrativeAssets
     * const narrativeAsset = await prisma.narrativeAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NarrativeAssets and only return the `id`
     * const narrativeAssetWithIdOnly = await prisma.narrativeAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NarrativeAsset.
     * @param {NarrativeAssetDeleteArgs} args - Arguments to delete one NarrativeAsset.
     * @example
     * // Delete one NarrativeAsset
     * const NarrativeAsset = await prisma.narrativeAsset.delete({
     *   where: {
     *     // ... filter to delete one NarrativeAsset
     *   }
     * })
     * 
     */
    delete<T extends NarrativeAssetDeleteArgs>(args: SelectSubset<T, NarrativeAssetDeleteArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NarrativeAsset.
     * @param {NarrativeAssetUpdateArgs} args - Arguments to update one NarrativeAsset.
     * @example
     * // Update one NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeAssetUpdateArgs>(args: SelectSubset<T, NarrativeAssetUpdateArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NarrativeAssets.
     * @param {NarrativeAssetDeleteManyArgs} args - Arguments to filter NarrativeAssets to delete.
     * @example
     * // Delete a few NarrativeAssets
     * const { count } = await prisma.narrativeAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeAssetDeleteManyArgs>(args?: SelectSubset<T, NarrativeAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NarrativeAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NarrativeAssets
     * const narrativeAsset = await prisma.narrativeAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeAssetUpdateManyArgs>(args: SelectSubset<T, NarrativeAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NarrativeAsset.
     * @param {NarrativeAssetUpsertArgs} args - Arguments to update or create a NarrativeAsset.
     * @example
     * // Update or create a NarrativeAsset
     * const narrativeAsset = await prisma.narrativeAsset.upsert({
     *   create: {
     *     // ... data to create a NarrativeAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NarrativeAsset we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeAssetUpsertArgs>(args: SelectSubset<T, NarrativeAssetUpsertArgs<ExtArgs>>): Prisma__NarrativeAssetClient<$Result.GetResult<Prisma.$NarrativeAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NarrativeAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetCountArgs} args - Arguments to filter NarrativeAssets to count.
     * @example
     * // Count the number of NarrativeAssets
     * const count = await prisma.narrativeAsset.count({
     *   where: {
     *     // ... the filter for the NarrativeAssets we want to count
     *   }
     * })
    **/
    count<T extends NarrativeAssetCountArgs>(
      args?: Subset<T, NarrativeAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NarrativeAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeAssetAggregateArgs>(args: Subset<T, NarrativeAssetAggregateArgs>): Prisma.PrismaPromise<GetNarrativeAssetAggregateType<T>>

    /**
     * Group by NarrativeAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeAssetGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NarrativeAsset model
   */
  readonly fields: NarrativeAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NarrativeAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends NarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NarrativeDefaultArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NarrativeAsset model
   */ 
  interface NarrativeAssetFieldRefs {
    readonly id: FieldRef<"NarrativeAsset", 'String'>
    readonly narrativeId: FieldRef<"NarrativeAsset", 'String'>
    readonly assetSymbol: FieldRef<"NarrativeAsset", 'String'>
    readonly impact: FieldRef<"NarrativeAsset", 'Float'>
    readonly createdAt: FieldRef<"NarrativeAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NarrativeAsset findUnique
   */
  export type NarrativeAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeAsset to fetch.
     */
    where: NarrativeAssetWhereUniqueInput
  }

  /**
   * NarrativeAsset findUniqueOrThrow
   */
  export type NarrativeAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeAsset to fetch.
     */
    where: NarrativeAssetWhereUniqueInput
  }

  /**
   * NarrativeAsset findFirst
   */
  export type NarrativeAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeAsset to fetch.
     */
    where?: NarrativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeAssets to fetch.
     */
    orderBy?: NarrativeAssetOrderByWithRelationInput | NarrativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeAssets.
     */
    cursor?: NarrativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeAssets.
     */
    distinct?: NarrativeAssetScalarFieldEnum | NarrativeAssetScalarFieldEnum[]
  }

  /**
   * NarrativeAsset findFirstOrThrow
   */
  export type NarrativeAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeAsset to fetch.
     */
    where?: NarrativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeAssets to fetch.
     */
    orderBy?: NarrativeAssetOrderByWithRelationInput | NarrativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeAssets.
     */
    cursor?: NarrativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeAssets.
     */
    distinct?: NarrativeAssetScalarFieldEnum | NarrativeAssetScalarFieldEnum[]
  }

  /**
   * NarrativeAsset findMany
   */
  export type NarrativeAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeAssets to fetch.
     */
    where?: NarrativeAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeAssets to fetch.
     */
    orderBy?: NarrativeAssetOrderByWithRelationInput | NarrativeAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NarrativeAssets.
     */
    cursor?: NarrativeAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeAssets.
     */
    skip?: number
    distinct?: NarrativeAssetScalarFieldEnum | NarrativeAssetScalarFieldEnum[]
  }

  /**
   * NarrativeAsset create
   */
  export type NarrativeAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a NarrativeAsset.
     */
    data: XOR<NarrativeAssetCreateInput, NarrativeAssetUncheckedCreateInput>
  }

  /**
   * NarrativeAsset createMany
   */
  export type NarrativeAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NarrativeAssets.
     */
    data: NarrativeAssetCreateManyInput | NarrativeAssetCreateManyInput[]
  }

  /**
   * NarrativeAsset createManyAndReturn
   */
  export type NarrativeAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NarrativeAssets.
     */
    data: NarrativeAssetCreateManyInput | NarrativeAssetCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NarrativeAsset update
   */
  export type NarrativeAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a NarrativeAsset.
     */
    data: XOR<NarrativeAssetUpdateInput, NarrativeAssetUncheckedUpdateInput>
    /**
     * Choose, which NarrativeAsset to update.
     */
    where: NarrativeAssetWhereUniqueInput
  }

  /**
   * NarrativeAsset updateMany
   */
  export type NarrativeAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NarrativeAssets.
     */
    data: XOR<NarrativeAssetUpdateManyMutationInput, NarrativeAssetUncheckedUpdateManyInput>
    /**
     * Filter which NarrativeAssets to update
     */
    where?: NarrativeAssetWhereInput
  }

  /**
   * NarrativeAsset upsert
   */
  export type NarrativeAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the NarrativeAsset to update in case it exists.
     */
    where: NarrativeAssetWhereUniqueInput
    /**
     * In case the NarrativeAsset found by the `where` argument doesn't exist, create a new NarrativeAsset with this data.
     */
    create: XOR<NarrativeAssetCreateInput, NarrativeAssetUncheckedCreateInput>
    /**
     * In case the NarrativeAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeAssetUpdateInput, NarrativeAssetUncheckedUpdateInput>
  }

  /**
   * NarrativeAsset delete
   */
  export type NarrativeAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
    /**
     * Filter which NarrativeAsset to delete.
     */
    where: NarrativeAssetWhereUniqueInput
  }

  /**
   * NarrativeAsset deleteMany
   */
  export type NarrativeAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeAssets to delete
     */
    where?: NarrativeAssetWhereInput
  }

  /**
   * NarrativeAsset without action
   */
  export type NarrativeAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeAsset
     */
    select?: NarrativeAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeAssetInclude<ExtArgs> | null
  }


  /**
   * Model NarrativeEvent
   */

  export type AggregateNarrativeEvent = {
    _count: NarrativeEventCountAggregateOutputType | null
    _min: NarrativeEventMinAggregateOutputType | null
    _max: NarrativeEventMaxAggregateOutputType | null
  }

  export type NarrativeEventMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    eventTime: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type NarrativeEventMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    eventTime: Date | null
    description: string | null
    createdAt: Date | null
  }

  export type NarrativeEventCountAggregateOutputType = {
    id: number
    narrativeId: number
    eventTime: number
    description: number
    createdAt: number
    _all: number
  }


  export type NarrativeEventMinAggregateInputType = {
    id?: true
    narrativeId?: true
    eventTime?: true
    description?: true
    createdAt?: true
  }

  export type NarrativeEventMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    eventTime?: true
    description?: true
    createdAt?: true
  }

  export type NarrativeEventCountAggregateInputType = {
    id?: true
    narrativeId?: true
    eventTime?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type NarrativeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeEvent to aggregate.
     */
    where?: NarrativeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeEvents to fetch.
     */
    orderBy?: NarrativeEventOrderByWithRelationInput | NarrativeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NarrativeEvents
    **/
    _count?: true | NarrativeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeEventMaxAggregateInputType
  }

  export type GetNarrativeEventAggregateType<T extends NarrativeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrativeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrativeEvent[P]>
      : GetScalarType<T[P], AggregateNarrativeEvent[P]>
  }




  export type NarrativeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeEventWhereInput
    orderBy?: NarrativeEventOrderByWithAggregationInput | NarrativeEventOrderByWithAggregationInput[]
    by: NarrativeEventScalarFieldEnum[] | NarrativeEventScalarFieldEnum
    having?: NarrativeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeEventCountAggregateInputType | true
    _min?: NarrativeEventMinAggregateInputType
    _max?: NarrativeEventMaxAggregateInputType
  }

  export type NarrativeEventGroupByOutputType = {
    id: string
    narrativeId: string
    eventTime: Date
    description: string | null
    createdAt: Date
    _count: NarrativeEventCountAggregateOutputType | null
    _min: NarrativeEventMinAggregateOutputType | null
    _max: NarrativeEventMaxAggregateOutputType | null
  }

  type GetNarrativeEventGroupByPayload<T extends NarrativeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeEventGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeEventGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    eventTime?: boolean
    description?: boolean
    createdAt?: boolean
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeEvent"]>

  export type NarrativeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    eventTime?: boolean
    description?: boolean
    createdAt?: boolean
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeEvent"]>

  export type NarrativeEventSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    eventTime?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type NarrativeEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }
  export type NarrativeEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | NarrativeDefaultArgs<ExtArgs>
  }

  export type $NarrativeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NarrativeEvent"
    objects: {
      narrative: Prisma.$NarrativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      eventTime: Date
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["narrativeEvent"]>
    composites: {}
  }

  type NarrativeEventGetPayload<S extends boolean | null | undefined | NarrativeEventDefaultArgs> = $Result.GetResult<Prisma.$NarrativeEventPayload, S>

  type NarrativeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeEventCountAggregateInputType | true
    }

  export interface NarrativeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NarrativeEvent'], meta: { name: 'NarrativeEvent' } }
    /**
     * Find zero or one NarrativeEvent that matches the filter.
     * @param {NarrativeEventFindUniqueArgs} args - Arguments to find a NarrativeEvent
     * @example
     * // Get one NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeEventFindUniqueArgs>(args: SelectSubset<T, NarrativeEventFindUniqueArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NarrativeEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeEventFindUniqueOrThrowArgs} args - Arguments to find a NarrativeEvent
     * @example
     * // Get one NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NarrativeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventFindFirstArgs} args - Arguments to find a NarrativeEvent
     * @example
     * // Get one NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeEventFindFirstArgs>(args?: SelectSubset<T, NarrativeEventFindFirstArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NarrativeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventFindFirstOrThrowArgs} args - Arguments to find a NarrativeEvent
     * @example
     * // Get one NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NarrativeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NarrativeEvents
     * const narrativeEvents = await prisma.narrativeEvent.findMany()
     * 
     * // Get first 10 NarrativeEvents
     * const narrativeEvents = await prisma.narrativeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeEventWithIdOnly = await prisma.narrativeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeEventFindManyArgs>(args?: SelectSubset<T, NarrativeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NarrativeEvent.
     * @param {NarrativeEventCreateArgs} args - Arguments to create a NarrativeEvent.
     * @example
     * // Create one NarrativeEvent
     * const NarrativeEvent = await prisma.narrativeEvent.create({
     *   data: {
     *     // ... data to create a NarrativeEvent
     *   }
     * })
     * 
     */
    create<T extends NarrativeEventCreateArgs>(args: SelectSubset<T, NarrativeEventCreateArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NarrativeEvents.
     * @param {NarrativeEventCreateManyArgs} args - Arguments to create many NarrativeEvents.
     * @example
     * // Create many NarrativeEvents
     * const narrativeEvent = await prisma.narrativeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeEventCreateManyArgs>(args?: SelectSubset<T, NarrativeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NarrativeEvents and returns the data saved in the database.
     * @param {NarrativeEventCreateManyAndReturnArgs} args - Arguments to create many NarrativeEvents.
     * @example
     * // Create many NarrativeEvents
     * const narrativeEvent = await prisma.narrativeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NarrativeEvents and only return the `id`
     * const narrativeEventWithIdOnly = await prisma.narrativeEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NarrativeEvent.
     * @param {NarrativeEventDeleteArgs} args - Arguments to delete one NarrativeEvent.
     * @example
     * // Delete one NarrativeEvent
     * const NarrativeEvent = await prisma.narrativeEvent.delete({
     *   where: {
     *     // ... filter to delete one NarrativeEvent
     *   }
     * })
     * 
     */
    delete<T extends NarrativeEventDeleteArgs>(args: SelectSubset<T, NarrativeEventDeleteArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NarrativeEvent.
     * @param {NarrativeEventUpdateArgs} args - Arguments to update one NarrativeEvent.
     * @example
     * // Update one NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeEventUpdateArgs>(args: SelectSubset<T, NarrativeEventUpdateArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NarrativeEvents.
     * @param {NarrativeEventDeleteManyArgs} args - Arguments to filter NarrativeEvents to delete.
     * @example
     * // Delete a few NarrativeEvents
     * const { count } = await prisma.narrativeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeEventDeleteManyArgs>(args?: SelectSubset<T, NarrativeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NarrativeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NarrativeEvents
     * const narrativeEvent = await prisma.narrativeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeEventUpdateManyArgs>(args: SelectSubset<T, NarrativeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NarrativeEvent.
     * @param {NarrativeEventUpsertArgs} args - Arguments to update or create a NarrativeEvent.
     * @example
     * // Update or create a NarrativeEvent
     * const narrativeEvent = await prisma.narrativeEvent.upsert({
     *   create: {
     *     // ... data to create a NarrativeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NarrativeEvent we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeEventUpsertArgs>(args: SelectSubset<T, NarrativeEventUpsertArgs<ExtArgs>>): Prisma__NarrativeEventClient<$Result.GetResult<Prisma.$NarrativeEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NarrativeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventCountArgs} args - Arguments to filter NarrativeEvents to count.
     * @example
     * // Count the number of NarrativeEvents
     * const count = await prisma.narrativeEvent.count({
     *   where: {
     *     // ... the filter for the NarrativeEvents we want to count
     *   }
     * })
    **/
    count<T extends NarrativeEventCountArgs>(
      args?: Subset<T, NarrativeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NarrativeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeEventAggregateArgs>(args: Subset<T, NarrativeEventAggregateArgs>): Prisma.PrismaPromise<GetNarrativeEventAggregateType<T>>

    /**
     * Group by NarrativeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeEventGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NarrativeEvent model
   */
  readonly fields: NarrativeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NarrativeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends NarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NarrativeDefaultArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NarrativeEvent model
   */ 
  interface NarrativeEventFieldRefs {
    readonly id: FieldRef<"NarrativeEvent", 'String'>
    readonly narrativeId: FieldRef<"NarrativeEvent", 'String'>
    readonly eventTime: FieldRef<"NarrativeEvent", 'DateTime'>
    readonly description: FieldRef<"NarrativeEvent", 'String'>
    readonly createdAt: FieldRef<"NarrativeEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NarrativeEvent findUnique
   */
  export type NarrativeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeEvent to fetch.
     */
    where: NarrativeEventWhereUniqueInput
  }

  /**
   * NarrativeEvent findUniqueOrThrow
   */
  export type NarrativeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeEvent to fetch.
     */
    where: NarrativeEventWhereUniqueInput
  }

  /**
   * NarrativeEvent findFirst
   */
  export type NarrativeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeEvent to fetch.
     */
    where?: NarrativeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeEvents to fetch.
     */
    orderBy?: NarrativeEventOrderByWithRelationInput | NarrativeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeEvents.
     */
    cursor?: NarrativeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeEvents.
     */
    distinct?: NarrativeEventScalarFieldEnum | NarrativeEventScalarFieldEnum[]
  }

  /**
   * NarrativeEvent findFirstOrThrow
   */
  export type NarrativeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeEvent to fetch.
     */
    where?: NarrativeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeEvents to fetch.
     */
    orderBy?: NarrativeEventOrderByWithRelationInput | NarrativeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeEvents.
     */
    cursor?: NarrativeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeEvents.
     */
    distinct?: NarrativeEventScalarFieldEnum | NarrativeEventScalarFieldEnum[]
  }

  /**
   * NarrativeEvent findMany
   */
  export type NarrativeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeEvents to fetch.
     */
    where?: NarrativeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeEvents to fetch.
     */
    orderBy?: NarrativeEventOrderByWithRelationInput | NarrativeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NarrativeEvents.
     */
    cursor?: NarrativeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeEvents.
     */
    skip?: number
    distinct?: NarrativeEventScalarFieldEnum | NarrativeEventScalarFieldEnum[]
  }

  /**
   * NarrativeEvent create
   */
  export type NarrativeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * The data needed to create a NarrativeEvent.
     */
    data: XOR<NarrativeEventCreateInput, NarrativeEventUncheckedCreateInput>
  }

  /**
   * NarrativeEvent createMany
   */
  export type NarrativeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NarrativeEvents.
     */
    data: NarrativeEventCreateManyInput | NarrativeEventCreateManyInput[]
  }

  /**
   * NarrativeEvent createManyAndReturn
   */
  export type NarrativeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NarrativeEvents.
     */
    data: NarrativeEventCreateManyInput | NarrativeEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NarrativeEvent update
   */
  export type NarrativeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * The data needed to update a NarrativeEvent.
     */
    data: XOR<NarrativeEventUpdateInput, NarrativeEventUncheckedUpdateInput>
    /**
     * Choose, which NarrativeEvent to update.
     */
    where: NarrativeEventWhereUniqueInput
  }

  /**
   * NarrativeEvent updateMany
   */
  export type NarrativeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NarrativeEvents.
     */
    data: XOR<NarrativeEventUpdateManyMutationInput, NarrativeEventUncheckedUpdateManyInput>
    /**
     * Filter which NarrativeEvents to update
     */
    where?: NarrativeEventWhereInput
  }

  /**
   * NarrativeEvent upsert
   */
  export type NarrativeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * The filter to search for the NarrativeEvent to update in case it exists.
     */
    where: NarrativeEventWhereUniqueInput
    /**
     * In case the NarrativeEvent found by the `where` argument doesn't exist, create a new NarrativeEvent with this data.
     */
    create: XOR<NarrativeEventCreateInput, NarrativeEventUncheckedCreateInput>
    /**
     * In case the NarrativeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeEventUpdateInput, NarrativeEventUncheckedUpdateInput>
  }

  /**
   * NarrativeEvent delete
   */
  export type NarrativeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
    /**
     * Filter which NarrativeEvent to delete.
     */
    where: NarrativeEventWhereUniqueInput
  }

  /**
   * NarrativeEvent deleteMany
   */
  export type NarrativeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeEvents to delete
     */
    where?: NarrativeEventWhereInput
  }

  /**
   * NarrativeEvent without action
   */
  export type NarrativeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeEvent
     */
    select?: NarrativeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeEventInclude<ExtArgs> | null
  }


  /**
   * Model SocialPost
   */

  export type AggregateSocialPost = {
    _count: SocialPostCountAggregateOutputType | null
    _avg: SocialPostAvgAggregateOutputType | null
    _sum: SocialPostSumAggregateOutputType | null
    _min: SocialPostMinAggregateOutputType | null
    _max: SocialPostMaxAggregateOutputType | null
  }

  export type SocialPostAvgAggregateOutputType = {
    likesCount: number | null
  }

  export type SocialPostSumAggregateOutputType = {
    likesCount: number | null
  }

  export type SocialPostMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    sentiment: string | null
    likesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialPostMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    sentiment: string | null
    likesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialPostCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    sentiment: number
    likesCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialPostAvgAggregateInputType = {
    likesCount?: true
  }

  export type SocialPostSumAggregateInputType = {
    likesCount?: true
  }

  export type SocialPostMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    sentiment?: true
    likesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialPostMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    sentiment?: true
    likesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialPostCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    sentiment?: true
    likesCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPost to aggregate.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: SocialPostOrderByWithRelationInput | SocialPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialPosts
    **/
    _count?: true | SocialPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialPostMaxAggregateInputType
  }

  export type GetSocialPostAggregateType<T extends SocialPostAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialPost[P]>
      : GetScalarType<T[P], AggregateSocialPost[P]>
  }




  export type SocialPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialPostWhereInput
    orderBy?: SocialPostOrderByWithAggregationInput | SocialPostOrderByWithAggregationInput[]
    by: SocialPostScalarFieldEnum[] | SocialPostScalarFieldEnum
    having?: SocialPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialPostCountAggregateInputType | true
    _avg?: SocialPostAvgAggregateInputType
    _sum?: SocialPostSumAggregateInputType
    _min?: SocialPostMinAggregateInputType
    _max?: SocialPostMaxAggregateInputType
  }

  export type SocialPostGroupByOutputType = {
    id: string
    userId: string
    content: string
    sentiment: string
    likesCount: number
    createdAt: Date
    updatedAt: Date
    _count: SocialPostCountAggregateOutputType | null
    _avg: SocialPostAvgAggregateOutputType | null
    _sum: SocialPostSumAggregateOutputType | null
    _min: SocialPostMinAggregateOutputType | null
    _max: SocialPostMaxAggregateOutputType | null
  }

  type GetSocialPostGroupByPayload<T extends SocialPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialPostGroupByOutputType[P]>
            : GetScalarType<T[P], SocialPostGroupByOutputType[P]>
        }
      >
    >


  export type SocialPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    sentiment?: boolean
    likesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tickers?: boolean | SocialPost$tickersArgs<ExtArgs>
    likes?: boolean | SocialPost$likesArgs<ExtArgs>
    _count?: boolean | SocialPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialPost"]>

  export type SocialPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    sentiment?: boolean
    likesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialPost"]>

  export type SocialPostSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    sentiment?: boolean
    likesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tickers?: boolean | SocialPost$tickersArgs<ExtArgs>
    likes?: boolean | SocialPost$likesArgs<ExtArgs>
    _count?: boolean | SocialPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SocialPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SocialPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tickers: Prisma.$PostTickerPayload<ExtArgs>[]
      likes: Prisma.$PostLikePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string
      sentiment: string
      likesCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialPost"]>
    composites: {}
  }

  type SocialPostGetPayload<S extends boolean | null | undefined | SocialPostDefaultArgs> = $Result.GetResult<Prisma.$SocialPostPayload, S>

  type SocialPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SocialPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SocialPostCountAggregateInputType | true
    }

  export interface SocialPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialPost'], meta: { name: 'SocialPost' } }
    /**
     * Find zero or one SocialPost that matches the filter.
     * @param {SocialPostFindUniqueArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialPostFindUniqueArgs>(args: SelectSubset<T, SocialPostFindUniqueArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SocialPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SocialPostFindUniqueOrThrowArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialPostFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SocialPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindFirstArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialPostFindFirstArgs>(args?: SelectSubset<T, SocialPostFindFirstArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SocialPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindFirstOrThrowArgs} args - Arguments to find a SocialPost
     * @example
     * // Get one SocialPost
     * const socialPost = await prisma.socialPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialPostFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SocialPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialPosts
     * const socialPosts = await prisma.socialPost.findMany()
     * 
     * // Get first 10 SocialPosts
     * const socialPosts = await prisma.socialPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialPostWithIdOnly = await prisma.socialPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialPostFindManyArgs>(args?: SelectSubset<T, SocialPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SocialPost.
     * @param {SocialPostCreateArgs} args - Arguments to create a SocialPost.
     * @example
     * // Create one SocialPost
     * const SocialPost = await prisma.socialPost.create({
     *   data: {
     *     // ... data to create a SocialPost
     *   }
     * })
     * 
     */
    create<T extends SocialPostCreateArgs>(args: SelectSubset<T, SocialPostCreateArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SocialPosts.
     * @param {SocialPostCreateManyArgs} args - Arguments to create many SocialPosts.
     * @example
     * // Create many SocialPosts
     * const socialPost = await prisma.socialPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialPostCreateManyArgs>(args?: SelectSubset<T, SocialPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialPosts and returns the data saved in the database.
     * @param {SocialPostCreateManyAndReturnArgs} args - Arguments to create many SocialPosts.
     * @example
     * // Create many SocialPosts
     * const socialPost = await prisma.socialPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialPosts and only return the `id`
     * const socialPostWithIdOnly = await prisma.socialPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialPostCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SocialPost.
     * @param {SocialPostDeleteArgs} args - Arguments to delete one SocialPost.
     * @example
     * // Delete one SocialPost
     * const SocialPost = await prisma.socialPost.delete({
     *   where: {
     *     // ... filter to delete one SocialPost
     *   }
     * })
     * 
     */
    delete<T extends SocialPostDeleteArgs>(args: SelectSubset<T, SocialPostDeleteArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SocialPost.
     * @param {SocialPostUpdateArgs} args - Arguments to update one SocialPost.
     * @example
     * // Update one SocialPost
     * const socialPost = await prisma.socialPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialPostUpdateArgs>(args: SelectSubset<T, SocialPostUpdateArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SocialPosts.
     * @param {SocialPostDeleteManyArgs} args - Arguments to filter SocialPosts to delete.
     * @example
     * // Delete a few SocialPosts
     * const { count } = await prisma.socialPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialPostDeleteManyArgs>(args?: SelectSubset<T, SocialPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialPosts
     * const socialPost = await prisma.socialPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialPostUpdateManyArgs>(args: SelectSubset<T, SocialPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialPost.
     * @param {SocialPostUpsertArgs} args - Arguments to update or create a SocialPost.
     * @example
     * // Update or create a SocialPost
     * const socialPost = await prisma.socialPost.upsert({
     *   create: {
     *     // ... data to create a SocialPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialPost we want to update
     *   }
     * })
     */
    upsert<T extends SocialPostUpsertArgs>(args: SelectSubset<T, SocialPostUpsertArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SocialPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostCountArgs} args - Arguments to filter SocialPosts to count.
     * @example
     * // Count the number of SocialPosts
     * const count = await prisma.socialPost.count({
     *   where: {
     *     // ... the filter for the SocialPosts we want to count
     *   }
     * })
    **/
    count<T extends SocialPostCountArgs>(
      args?: Subset<T, SocialPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialPostAggregateArgs>(args: Subset<T, SocialPostAggregateArgs>): Prisma.PrismaPromise<GetSocialPostAggregateType<T>>

    /**
     * Group by SocialPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialPostGroupByArgs['orderBy'] }
        : { orderBy?: SocialPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialPost model
   */
  readonly fields: SocialPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tickers<T extends SocialPost$tickersArgs<ExtArgs> = {}>(args?: Subset<T, SocialPost$tickersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findMany"> | Null>
    likes<T extends SocialPost$likesArgs<ExtArgs> = {}>(args?: Subset<T, SocialPost$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialPost model
   */ 
  interface SocialPostFieldRefs {
    readonly id: FieldRef<"SocialPost", 'String'>
    readonly userId: FieldRef<"SocialPost", 'String'>
    readonly content: FieldRef<"SocialPost", 'String'>
    readonly sentiment: FieldRef<"SocialPost", 'String'>
    readonly likesCount: FieldRef<"SocialPost", 'Int'>
    readonly createdAt: FieldRef<"SocialPost", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialPost findUnique
   */
  export type SocialPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where: SocialPostWhereUniqueInput
  }

  /**
   * SocialPost findUniqueOrThrow
   */
  export type SocialPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where: SocialPostWhereUniqueInput
  }

  /**
   * SocialPost findFirst
   */
  export type SocialPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: SocialPostOrderByWithRelationInput | SocialPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPosts.
     */
    distinct?: SocialPostScalarFieldEnum | SocialPostScalarFieldEnum[]
  }

  /**
   * SocialPost findFirstOrThrow
   */
  export type SocialPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPost to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: SocialPostOrderByWithRelationInput | SocialPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPosts.
     */
    distinct?: SocialPostScalarFieldEnum | SocialPostScalarFieldEnum[]
  }

  /**
   * SocialPost findMany
   */
  export type SocialPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter, which SocialPosts to fetch.
     */
    where?: SocialPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPosts to fetch.
     */
    orderBy?: SocialPostOrderByWithRelationInput | SocialPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialPosts.
     */
    cursor?: SocialPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPosts.
     */
    skip?: number
    distinct?: SocialPostScalarFieldEnum | SocialPostScalarFieldEnum[]
  }

  /**
   * SocialPost create
   */
  export type SocialPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialPost.
     */
    data: XOR<SocialPostCreateInput, SocialPostUncheckedCreateInput>
  }

  /**
   * SocialPost createMany
   */
  export type SocialPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialPosts.
     */
    data: SocialPostCreateManyInput | SocialPostCreateManyInput[]
  }

  /**
   * SocialPost createManyAndReturn
   */
  export type SocialPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SocialPosts.
     */
    data: SocialPostCreateManyInput | SocialPostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialPost update
   */
  export type SocialPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialPost.
     */
    data: XOR<SocialPostUpdateInput, SocialPostUncheckedUpdateInput>
    /**
     * Choose, which SocialPost to update.
     */
    where: SocialPostWhereUniqueInput
  }

  /**
   * SocialPost updateMany
   */
  export type SocialPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialPosts.
     */
    data: XOR<SocialPostUpdateManyMutationInput, SocialPostUncheckedUpdateManyInput>
    /**
     * Filter which SocialPosts to update
     */
    where?: SocialPostWhereInput
  }

  /**
   * SocialPost upsert
   */
  export type SocialPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialPost to update in case it exists.
     */
    where: SocialPostWhereUniqueInput
    /**
     * In case the SocialPost found by the `where` argument doesn't exist, create a new SocialPost with this data.
     */
    create: XOR<SocialPostCreateInput, SocialPostUncheckedCreateInput>
    /**
     * In case the SocialPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialPostUpdateInput, SocialPostUncheckedUpdateInput>
  }

  /**
   * SocialPost delete
   */
  export type SocialPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
    /**
     * Filter which SocialPost to delete.
     */
    where: SocialPostWhereUniqueInput
  }

  /**
   * SocialPost deleteMany
   */
  export type SocialPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPosts to delete
     */
    where?: SocialPostWhereInput
  }

  /**
   * SocialPost.tickers
   */
  export type SocialPost$tickersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    where?: PostTickerWhereInput
    orderBy?: PostTickerOrderByWithRelationInput | PostTickerOrderByWithRelationInput[]
    cursor?: PostTickerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTickerScalarFieldEnum | PostTickerScalarFieldEnum[]
  }

  /**
   * SocialPost.likes
   */
  export type SocialPost$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    cursor?: PostLikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * SocialPost without action
   */
  export type SocialPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPost
     */
    select?: SocialPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPostInclude<ExtArgs> | null
  }


  /**
   * Model PostTicker
   */

  export type AggregatePostTicker = {
    _count: PostTickerCountAggregateOutputType | null
    _min: PostTickerMinAggregateOutputType | null
    _max: PostTickerMaxAggregateOutputType | null
  }

  export type PostTickerMinAggregateOutputType = {
    id: string | null
    postId: string | null
    ticker: string | null
  }

  export type PostTickerMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    ticker: string | null
  }

  export type PostTickerCountAggregateOutputType = {
    id: number
    postId: number
    ticker: number
    _all: number
  }


  export type PostTickerMinAggregateInputType = {
    id?: true
    postId?: true
    ticker?: true
  }

  export type PostTickerMaxAggregateInputType = {
    id?: true
    postId?: true
    ticker?: true
  }

  export type PostTickerCountAggregateInputType = {
    id?: true
    postId?: true
    ticker?: true
    _all?: true
  }

  export type PostTickerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTicker to aggregate.
     */
    where?: PostTickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTickers to fetch.
     */
    orderBy?: PostTickerOrderByWithRelationInput | PostTickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTickers
    **/
    _count?: true | PostTickerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTickerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTickerMaxAggregateInputType
  }

  export type GetPostTickerAggregateType<T extends PostTickerAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTicker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTicker[P]>
      : GetScalarType<T[P], AggregatePostTicker[P]>
  }




  export type PostTickerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTickerWhereInput
    orderBy?: PostTickerOrderByWithAggregationInput | PostTickerOrderByWithAggregationInput[]
    by: PostTickerScalarFieldEnum[] | PostTickerScalarFieldEnum
    having?: PostTickerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTickerCountAggregateInputType | true
    _min?: PostTickerMinAggregateInputType
    _max?: PostTickerMaxAggregateInputType
  }

  export type PostTickerGroupByOutputType = {
    id: string
    postId: string
    ticker: string
    _count: PostTickerCountAggregateOutputType | null
    _min: PostTickerMinAggregateOutputType | null
    _max: PostTickerMaxAggregateOutputType | null
  }

  type GetPostTickerGroupByPayload<T extends PostTickerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTickerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTickerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTickerGroupByOutputType[P]>
            : GetScalarType<T[P], PostTickerGroupByOutputType[P]>
        }
      >
    >


  export type PostTickerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    ticker?: boolean
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTicker"]>

  export type PostTickerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    ticker?: boolean
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTicker"]>

  export type PostTickerSelectScalar = {
    id?: boolean
    postId?: boolean
    ticker?: boolean
  }

  export type PostTickerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
  }
  export type PostTickerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
  }

  export type $PostTickerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTicker"
    objects: {
      post: Prisma.$SocialPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      ticker: string
    }, ExtArgs["result"]["postTicker"]>
    composites: {}
  }

  type PostTickerGetPayload<S extends boolean | null | undefined | PostTickerDefaultArgs> = $Result.GetResult<Prisma.$PostTickerPayload, S>

  type PostTickerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostTickerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostTickerCountAggregateInputType | true
    }

  export interface PostTickerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTicker'], meta: { name: 'PostTicker' } }
    /**
     * Find zero or one PostTicker that matches the filter.
     * @param {PostTickerFindUniqueArgs} args - Arguments to find a PostTicker
     * @example
     * // Get one PostTicker
     * const postTicker = await prisma.postTicker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTickerFindUniqueArgs>(args: SelectSubset<T, PostTickerFindUniqueArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostTicker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostTickerFindUniqueOrThrowArgs} args - Arguments to find a PostTicker
     * @example
     * // Get one PostTicker
     * const postTicker = await prisma.postTicker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTickerFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTickerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostTicker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerFindFirstArgs} args - Arguments to find a PostTicker
     * @example
     * // Get one PostTicker
     * const postTicker = await prisma.postTicker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTickerFindFirstArgs>(args?: SelectSubset<T, PostTickerFindFirstArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostTicker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerFindFirstOrThrowArgs} args - Arguments to find a PostTicker
     * @example
     * // Get one PostTicker
     * const postTicker = await prisma.postTicker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTickerFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTickerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostTickers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTickers
     * const postTickers = await prisma.postTicker.findMany()
     * 
     * // Get first 10 PostTickers
     * const postTickers = await prisma.postTicker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postTickerWithIdOnly = await prisma.postTicker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostTickerFindManyArgs>(args?: SelectSubset<T, PostTickerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostTicker.
     * @param {PostTickerCreateArgs} args - Arguments to create a PostTicker.
     * @example
     * // Create one PostTicker
     * const PostTicker = await prisma.postTicker.create({
     *   data: {
     *     // ... data to create a PostTicker
     *   }
     * })
     * 
     */
    create<T extends PostTickerCreateArgs>(args: SelectSubset<T, PostTickerCreateArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostTickers.
     * @param {PostTickerCreateManyArgs} args - Arguments to create many PostTickers.
     * @example
     * // Create many PostTickers
     * const postTicker = await prisma.postTicker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTickerCreateManyArgs>(args?: SelectSubset<T, PostTickerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTickers and returns the data saved in the database.
     * @param {PostTickerCreateManyAndReturnArgs} args - Arguments to create many PostTickers.
     * @example
     * // Create many PostTickers
     * const postTicker = await prisma.postTicker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTickers and only return the `id`
     * const postTickerWithIdOnly = await prisma.postTicker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTickerCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTickerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostTicker.
     * @param {PostTickerDeleteArgs} args - Arguments to delete one PostTicker.
     * @example
     * // Delete one PostTicker
     * const PostTicker = await prisma.postTicker.delete({
     *   where: {
     *     // ... filter to delete one PostTicker
     *   }
     * })
     * 
     */
    delete<T extends PostTickerDeleteArgs>(args: SelectSubset<T, PostTickerDeleteArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostTicker.
     * @param {PostTickerUpdateArgs} args - Arguments to update one PostTicker.
     * @example
     * // Update one PostTicker
     * const postTicker = await prisma.postTicker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTickerUpdateArgs>(args: SelectSubset<T, PostTickerUpdateArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostTickers.
     * @param {PostTickerDeleteManyArgs} args - Arguments to filter PostTickers to delete.
     * @example
     * // Delete a few PostTickers
     * const { count } = await prisma.postTicker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTickerDeleteManyArgs>(args?: SelectSubset<T, PostTickerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTickers
     * const postTicker = await prisma.postTicker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTickerUpdateManyArgs>(args: SelectSubset<T, PostTickerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostTicker.
     * @param {PostTickerUpsertArgs} args - Arguments to update or create a PostTicker.
     * @example
     * // Update or create a PostTicker
     * const postTicker = await prisma.postTicker.upsert({
     *   create: {
     *     // ... data to create a PostTicker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTicker we want to update
     *   }
     * })
     */
    upsert<T extends PostTickerUpsertArgs>(args: SelectSubset<T, PostTickerUpsertArgs<ExtArgs>>): Prisma__PostTickerClient<$Result.GetResult<Prisma.$PostTickerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostTickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerCountArgs} args - Arguments to filter PostTickers to count.
     * @example
     * // Count the number of PostTickers
     * const count = await prisma.postTicker.count({
     *   where: {
     *     // ... the filter for the PostTickers we want to count
     *   }
     * })
    **/
    count<T extends PostTickerCountArgs>(
      args?: Subset<T, PostTickerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTickerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTicker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTickerAggregateArgs>(args: Subset<T, PostTickerAggregateArgs>): Prisma.PrismaPromise<GetPostTickerAggregateType<T>>

    /**
     * Group by PostTicker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTickerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTickerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTickerGroupByArgs['orderBy'] }
        : { orderBy?: PostTickerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTickerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTickerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTicker model
   */
  readonly fields: PostTickerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTicker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTickerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends SocialPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialPostDefaultArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTicker model
   */ 
  interface PostTickerFieldRefs {
    readonly id: FieldRef<"PostTicker", 'String'>
    readonly postId: FieldRef<"PostTicker", 'String'>
    readonly ticker: FieldRef<"PostTicker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostTicker findUnique
   */
  export type PostTickerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter, which PostTicker to fetch.
     */
    where: PostTickerWhereUniqueInput
  }

  /**
   * PostTicker findUniqueOrThrow
   */
  export type PostTickerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter, which PostTicker to fetch.
     */
    where: PostTickerWhereUniqueInput
  }

  /**
   * PostTicker findFirst
   */
  export type PostTickerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter, which PostTicker to fetch.
     */
    where?: PostTickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTickers to fetch.
     */
    orderBy?: PostTickerOrderByWithRelationInput | PostTickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTickers.
     */
    cursor?: PostTickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTickers.
     */
    distinct?: PostTickerScalarFieldEnum | PostTickerScalarFieldEnum[]
  }

  /**
   * PostTicker findFirstOrThrow
   */
  export type PostTickerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter, which PostTicker to fetch.
     */
    where?: PostTickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTickers to fetch.
     */
    orderBy?: PostTickerOrderByWithRelationInput | PostTickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTickers.
     */
    cursor?: PostTickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTickers.
     */
    distinct?: PostTickerScalarFieldEnum | PostTickerScalarFieldEnum[]
  }

  /**
   * PostTicker findMany
   */
  export type PostTickerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter, which PostTickers to fetch.
     */
    where?: PostTickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTickers to fetch.
     */
    orderBy?: PostTickerOrderByWithRelationInput | PostTickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTickers.
     */
    cursor?: PostTickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTickers.
     */
    skip?: number
    distinct?: PostTickerScalarFieldEnum | PostTickerScalarFieldEnum[]
  }

  /**
   * PostTicker create
   */
  export type PostTickerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTicker.
     */
    data: XOR<PostTickerCreateInput, PostTickerUncheckedCreateInput>
  }

  /**
   * PostTicker createMany
   */
  export type PostTickerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTickers.
     */
    data: PostTickerCreateManyInput | PostTickerCreateManyInput[]
  }

  /**
   * PostTicker createManyAndReturn
   */
  export type PostTickerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostTickers.
     */
    data: PostTickerCreateManyInput | PostTickerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTicker update
   */
  export type PostTickerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTicker.
     */
    data: XOR<PostTickerUpdateInput, PostTickerUncheckedUpdateInput>
    /**
     * Choose, which PostTicker to update.
     */
    where: PostTickerWhereUniqueInput
  }

  /**
   * PostTicker updateMany
   */
  export type PostTickerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTickers.
     */
    data: XOR<PostTickerUpdateManyMutationInput, PostTickerUncheckedUpdateManyInput>
    /**
     * Filter which PostTickers to update
     */
    where?: PostTickerWhereInput
  }

  /**
   * PostTicker upsert
   */
  export type PostTickerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTicker to update in case it exists.
     */
    where: PostTickerWhereUniqueInput
    /**
     * In case the PostTicker found by the `where` argument doesn't exist, create a new PostTicker with this data.
     */
    create: XOR<PostTickerCreateInput, PostTickerUncheckedCreateInput>
    /**
     * In case the PostTicker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTickerUpdateInput, PostTickerUncheckedUpdateInput>
  }

  /**
   * PostTicker delete
   */
  export type PostTickerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
    /**
     * Filter which PostTicker to delete.
     */
    where: PostTickerWhereUniqueInput
  }

  /**
   * PostTicker deleteMany
   */
  export type PostTickerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTickers to delete
     */
    where?: PostTickerWhereInput
  }

  /**
   * PostTicker without action
   */
  export type PostTickerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTicker
     */
    select?: PostTickerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTickerInclude<ExtArgs> | null
  }


  /**
   * Model PostLike
   */

  export type AggregatePostLike = {
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  export type PostLikeMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PostLikeMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PostLikeCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PostLikeMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type PostLikeMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
  }

  export type PostLikeCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PostLikeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLike to aggregate.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikeMaxAggregateInputType
  }

  export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLike[P]>
      : GetScalarType<T[P], AggregatePostLike[P]>
  }




  export type PostLikeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostLikeWhereInput
    orderBy?: PostLikeOrderByWithAggregationInput | PostLikeOrderByWithAggregationInput[]
    by: PostLikeScalarFieldEnum[] | PostLikeScalarFieldEnum
    having?: PostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikeCountAggregateInputType | true
    _min?: PostLikeMinAggregateInputType
    _max?: PostLikeMaxAggregateInputType
  }

  export type PostLikeGroupByOutputType = {
    id: string
    postId: string
    userId: string
    createdAt: Date
    _count: PostLikeCountAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostLikeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postLike"]>

  export type PostLikeSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PostLikeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostLikeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | SocialPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostLikePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostLike"
    objects: {
      post: Prisma.$SocialPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["postLike"]>
    composites: {}
  }

  type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeDefaultArgs> = $Result.GetResult<Prisma.$PostLikePayload, S>

  type PostLikeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostLikeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostLikeCountAggregateInputType | true
    }

  export interface PostLikeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostLike'], meta: { name: 'PostLike' } }
    /**
     * Find zero or one PostLike that matches the filter.
     * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostLikeFindUniqueArgs>(args: SelectSubset<T, PostLikeFindUniqueArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostLike that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostLikeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostLikeFindFirstArgs>(args?: SelectSubset<T, PostLikeFindFirstArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLike.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostLikeFindManyArgs>(args?: SelectSubset<T, PostLikeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostLike.
     * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
     * @example
     * // Create one PostLike
     * const PostLike = await prisma.postLike.create({
     *   data: {
     *     // ... data to create a PostLike
     *   }
     * })
     * 
     */
    create<T extends PostLikeCreateArgs>(args: SelectSubset<T, PostLikeCreateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostLikes.
     * @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostLikeCreateManyArgs>(args?: SelectSubset<T, PostLikeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostLikes and returns the data saved in the database.
     * @param {PostLikeCreateManyAndReturnArgs} args - Arguments to create many PostLikes.
     * @example
     * // Create many PostLikes
     * const postLike = await prisma.postLike.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostLikes and only return the `id`
     * const postLikeWithIdOnly = await prisma.postLike.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostLikeCreateManyAndReturnArgs>(args?: SelectSubset<T, PostLikeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostLike.
     * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
     * @example
     * // Delete one PostLike
     * const PostLike = await prisma.postLike.delete({
     *   where: {
     *     // ... filter to delete one PostLike
     *   }
     * })
     * 
     */
    delete<T extends PostLikeDeleteArgs>(args: SelectSubset<T, PostLikeDeleteArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostLike.
     * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
     * @example
     * // Update one PostLike
     * const postLike = await prisma.postLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostLikeUpdateArgs>(args: SelectSubset<T, PostLikeUpdateArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostLikeDeleteManyArgs>(args?: SelectSubset<T, PostLikeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostLikeUpdateManyArgs>(args: SelectSubset<T, PostLikeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostLike.
     * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
     * @example
     * // Update or create a PostLike
     * const postLike = await prisma.postLike.upsert({
     *   create: {
     *     // ... data to create a PostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLike we want to update
     *   }
     * })
     */
    upsert<T extends PostLikeUpsertArgs>(args: SelectSubset<T, PostLikeUpsertArgs<ExtArgs>>): Prisma__PostLikeClient<$Result.GetResult<Prisma.$PostLikePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLike.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikeCountArgs>(
      args?: Subset<T, PostLikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikeAggregateArgs>(args: Subset<T, PostLikeAggregateArgs>): Prisma.PrismaPromise<GetPostLikeAggregateType<T>>

    /**
     * Group by PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostLike model
   */
  readonly fields: PostLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostLikeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends SocialPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialPostDefaultArgs<ExtArgs>>): Prisma__SocialPostClient<$Result.GetResult<Prisma.$SocialPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostLike model
   */ 
  interface PostLikeFieldRefs {
    readonly id: FieldRef<"PostLike", 'String'>
    readonly postId: FieldRef<"PostLike", 'String'>
    readonly userId: FieldRef<"PostLike", 'String'>
    readonly createdAt: FieldRef<"PostLike", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostLike findUnique
   */
  export type PostLikeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findUniqueOrThrow
   */
  export type PostLikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike findFirst
   */
  export type PostLikeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findFirstOrThrow
   */
  export type PostLikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLike to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike findMany
   */
  export type PostLikeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: PostLikeOrderByWithRelationInput | PostLikeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     */
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    distinct?: PostLikeScalarFieldEnum | PostLikeScalarFieldEnum[]
  }

  /**
   * PostLike create
   */
  export type PostLikeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to create a PostLike.
     */
    data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
  }

  /**
   * PostLike createMany
   */
  export type PostLikeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
  }

  /**
   * PostLike createManyAndReturn
   */
  export type PostLikeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostLikes.
     */
    data: PostLikeCreateManyInput | PostLikeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostLike update
   */
  export type PostLikeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The data needed to update a PostLike.
     */
    data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
    /**
     * Choose, which PostLike to update.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike updateMany
   */
  export type PostLikeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikeWhereInput
  }

  /**
   * PostLike upsert
   */
  export type PostLikeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * The filter to search for the PostLike to update in case it exists.
     */
    where: PostLikeWhereUniqueInput
    /**
     * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
     */
    create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
    /**
     * In case the PostLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
  }

  /**
   * PostLike delete
   */
  export type PostLikeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
    /**
     * Filter which PostLike to delete.
     */
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike deleteMany
   */
  export type PostLikeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostLikes to delete
     */
    where?: PostLikeWhereInput
  }

  /**
   * PostLike without action
   */
  export type PostLikeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostLike
     */
    select?: PostLikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostLikeInclude<ExtArgs> | null
  }


  /**
   * Model TrackedAccount
   */

  export type AggregateTrackedAccount = {
    _count: TrackedAccountCountAggregateOutputType | null
    _min: TrackedAccountMinAggregateOutputType | null
    _max: TrackedAccountMaxAggregateOutputType | null
  }

  export type TrackedAccountMinAggregateOutputType = {
    id: string | null
    platform: string | null
    accountHandle: string | null
    accountName: string | null
    accountType: string | null
    isActive: boolean | null
    lastFetchedAt: Date | null
    createdAt: Date | null
  }

  export type TrackedAccountMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    accountHandle: string | null
    accountName: string | null
    accountType: string | null
    isActive: boolean | null
    lastFetchedAt: Date | null
    createdAt: Date | null
  }

  export type TrackedAccountCountAggregateOutputType = {
    id: number
    platform: number
    accountHandle: number
    accountName: number
    accountType: number
    isActive: number
    lastFetchedAt: number
    createdAt: number
    _all: number
  }


  export type TrackedAccountMinAggregateInputType = {
    id?: true
    platform?: true
    accountHandle?: true
    accountName?: true
    accountType?: true
    isActive?: true
    lastFetchedAt?: true
    createdAt?: true
  }

  export type TrackedAccountMaxAggregateInputType = {
    id?: true
    platform?: true
    accountHandle?: true
    accountName?: true
    accountType?: true
    isActive?: true
    lastFetchedAt?: true
    createdAt?: true
  }

  export type TrackedAccountCountAggregateInputType = {
    id?: true
    platform?: true
    accountHandle?: true
    accountName?: true
    accountType?: true
    isActive?: true
    lastFetchedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TrackedAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackedAccount to aggregate.
     */
    where?: TrackedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedAccounts to fetch.
     */
    orderBy?: TrackedAccountOrderByWithRelationInput | TrackedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrackedAccounts
    **/
    _count?: true | TrackedAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackedAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackedAccountMaxAggregateInputType
  }

  export type GetTrackedAccountAggregateType<T extends TrackedAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackedAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackedAccount[P]>
      : GetScalarType<T[P], AggregateTrackedAccount[P]>
  }




  export type TrackedAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackedAccountWhereInput
    orderBy?: TrackedAccountOrderByWithAggregationInput | TrackedAccountOrderByWithAggregationInput[]
    by: TrackedAccountScalarFieldEnum[] | TrackedAccountScalarFieldEnum
    having?: TrackedAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackedAccountCountAggregateInputType | true
    _min?: TrackedAccountMinAggregateInputType
    _max?: TrackedAccountMaxAggregateInputType
  }

  export type TrackedAccountGroupByOutputType = {
    id: string
    platform: string
    accountHandle: string
    accountName: string | null
    accountType: string | null
    isActive: boolean
    lastFetchedAt: Date | null
    createdAt: Date
    _count: TrackedAccountCountAggregateOutputType | null
    _min: TrackedAccountMinAggregateOutputType | null
    _max: TrackedAccountMaxAggregateOutputType | null
  }

  type GetTrackedAccountGroupByPayload<T extends TrackedAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackedAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackedAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackedAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TrackedAccountGroupByOutputType[P]>
        }
      >
    >


  export type TrackedAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accountHandle?: boolean
    accountName?: boolean
    accountType?: boolean
    isActive?: boolean
    lastFetchedAt?: boolean
    createdAt?: boolean
    posts?: boolean | TrackedAccount$postsArgs<ExtArgs>
    _count?: boolean | TrackedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackedAccount"]>

  export type TrackedAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    accountHandle?: boolean
    accountName?: boolean
    accountType?: boolean
    isActive?: boolean
    lastFetchedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["trackedAccount"]>

  export type TrackedAccountSelectScalar = {
    id?: boolean
    platform?: boolean
    accountHandle?: boolean
    accountName?: boolean
    accountType?: boolean
    isActive?: boolean
    lastFetchedAt?: boolean
    createdAt?: boolean
  }

  export type TrackedAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TrackedAccount$postsArgs<ExtArgs>
    _count?: boolean | TrackedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrackedAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrackedAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrackedAccount"
    objects: {
      posts: Prisma.$IngestedPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      accountHandle: string
      accountName: string | null
      accountType: string | null
      isActive: boolean
      lastFetchedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["trackedAccount"]>
    composites: {}
  }

  type TrackedAccountGetPayload<S extends boolean | null | undefined | TrackedAccountDefaultArgs> = $Result.GetResult<Prisma.$TrackedAccountPayload, S>

  type TrackedAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrackedAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrackedAccountCountAggregateInputType | true
    }

  export interface TrackedAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrackedAccount'], meta: { name: 'TrackedAccount' } }
    /**
     * Find zero or one TrackedAccount that matches the filter.
     * @param {TrackedAccountFindUniqueArgs} args - Arguments to find a TrackedAccount
     * @example
     * // Get one TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackedAccountFindUniqueArgs>(args: SelectSubset<T, TrackedAccountFindUniqueArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrackedAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrackedAccountFindUniqueOrThrowArgs} args - Arguments to find a TrackedAccount
     * @example
     * // Get one TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackedAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackedAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrackedAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountFindFirstArgs} args - Arguments to find a TrackedAccount
     * @example
     * // Get one TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackedAccountFindFirstArgs>(args?: SelectSubset<T, TrackedAccountFindFirstArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrackedAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountFindFirstOrThrowArgs} args - Arguments to find a TrackedAccount
     * @example
     * // Get one TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackedAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackedAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrackedAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrackedAccounts
     * const trackedAccounts = await prisma.trackedAccount.findMany()
     * 
     * // Get first 10 TrackedAccounts
     * const trackedAccounts = await prisma.trackedAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackedAccountWithIdOnly = await prisma.trackedAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackedAccountFindManyArgs>(args?: SelectSubset<T, TrackedAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrackedAccount.
     * @param {TrackedAccountCreateArgs} args - Arguments to create a TrackedAccount.
     * @example
     * // Create one TrackedAccount
     * const TrackedAccount = await prisma.trackedAccount.create({
     *   data: {
     *     // ... data to create a TrackedAccount
     *   }
     * })
     * 
     */
    create<T extends TrackedAccountCreateArgs>(args: SelectSubset<T, TrackedAccountCreateArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrackedAccounts.
     * @param {TrackedAccountCreateManyArgs} args - Arguments to create many TrackedAccounts.
     * @example
     * // Create many TrackedAccounts
     * const trackedAccount = await prisma.trackedAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackedAccountCreateManyArgs>(args?: SelectSubset<T, TrackedAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrackedAccounts and returns the data saved in the database.
     * @param {TrackedAccountCreateManyAndReturnArgs} args - Arguments to create many TrackedAccounts.
     * @example
     * // Create many TrackedAccounts
     * const trackedAccount = await prisma.trackedAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrackedAccounts and only return the `id`
     * const trackedAccountWithIdOnly = await prisma.trackedAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackedAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackedAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrackedAccount.
     * @param {TrackedAccountDeleteArgs} args - Arguments to delete one TrackedAccount.
     * @example
     * // Delete one TrackedAccount
     * const TrackedAccount = await prisma.trackedAccount.delete({
     *   where: {
     *     // ... filter to delete one TrackedAccount
     *   }
     * })
     * 
     */
    delete<T extends TrackedAccountDeleteArgs>(args: SelectSubset<T, TrackedAccountDeleteArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrackedAccount.
     * @param {TrackedAccountUpdateArgs} args - Arguments to update one TrackedAccount.
     * @example
     * // Update one TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackedAccountUpdateArgs>(args: SelectSubset<T, TrackedAccountUpdateArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrackedAccounts.
     * @param {TrackedAccountDeleteManyArgs} args - Arguments to filter TrackedAccounts to delete.
     * @example
     * // Delete a few TrackedAccounts
     * const { count } = await prisma.trackedAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackedAccountDeleteManyArgs>(args?: SelectSubset<T, TrackedAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrackedAccounts
     * const trackedAccount = await prisma.trackedAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackedAccountUpdateManyArgs>(args: SelectSubset<T, TrackedAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrackedAccount.
     * @param {TrackedAccountUpsertArgs} args - Arguments to update or create a TrackedAccount.
     * @example
     * // Update or create a TrackedAccount
     * const trackedAccount = await prisma.trackedAccount.upsert({
     *   create: {
     *     // ... data to create a TrackedAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrackedAccount we want to update
     *   }
     * })
     */
    upsert<T extends TrackedAccountUpsertArgs>(args: SelectSubset<T, TrackedAccountUpsertArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrackedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountCountArgs} args - Arguments to filter TrackedAccounts to count.
     * @example
     * // Count the number of TrackedAccounts
     * const count = await prisma.trackedAccount.count({
     *   where: {
     *     // ... the filter for the TrackedAccounts we want to count
     *   }
     * })
    **/
    count<T extends TrackedAccountCountArgs>(
      args?: Subset<T, TrackedAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackedAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrackedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackedAccountAggregateArgs>(args: Subset<T, TrackedAccountAggregateArgs>): Prisma.PrismaPromise<GetTrackedAccountAggregateType<T>>

    /**
     * Group by TrackedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackedAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackedAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackedAccountGroupByArgs['orderBy'] }
        : { orderBy?: TrackedAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackedAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackedAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrackedAccount model
   */
  readonly fields: TrackedAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrackedAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackedAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends TrackedAccount$postsArgs<ExtArgs> = {}>(args?: Subset<T, TrackedAccount$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrackedAccount model
   */ 
  interface TrackedAccountFieldRefs {
    readonly id: FieldRef<"TrackedAccount", 'String'>
    readonly platform: FieldRef<"TrackedAccount", 'String'>
    readonly accountHandle: FieldRef<"TrackedAccount", 'String'>
    readonly accountName: FieldRef<"TrackedAccount", 'String'>
    readonly accountType: FieldRef<"TrackedAccount", 'String'>
    readonly isActive: FieldRef<"TrackedAccount", 'Boolean'>
    readonly lastFetchedAt: FieldRef<"TrackedAccount", 'DateTime'>
    readonly createdAt: FieldRef<"TrackedAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrackedAccount findUnique
   */
  export type TrackedAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter, which TrackedAccount to fetch.
     */
    where: TrackedAccountWhereUniqueInput
  }

  /**
   * TrackedAccount findUniqueOrThrow
   */
  export type TrackedAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter, which TrackedAccount to fetch.
     */
    where: TrackedAccountWhereUniqueInput
  }

  /**
   * TrackedAccount findFirst
   */
  export type TrackedAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter, which TrackedAccount to fetch.
     */
    where?: TrackedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedAccounts to fetch.
     */
    orderBy?: TrackedAccountOrderByWithRelationInput | TrackedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackedAccounts.
     */
    cursor?: TrackedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackedAccounts.
     */
    distinct?: TrackedAccountScalarFieldEnum | TrackedAccountScalarFieldEnum[]
  }

  /**
   * TrackedAccount findFirstOrThrow
   */
  export type TrackedAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter, which TrackedAccount to fetch.
     */
    where?: TrackedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedAccounts to fetch.
     */
    orderBy?: TrackedAccountOrderByWithRelationInput | TrackedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackedAccounts.
     */
    cursor?: TrackedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackedAccounts.
     */
    distinct?: TrackedAccountScalarFieldEnum | TrackedAccountScalarFieldEnum[]
  }

  /**
   * TrackedAccount findMany
   */
  export type TrackedAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter, which TrackedAccounts to fetch.
     */
    where?: TrackedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackedAccounts to fetch.
     */
    orderBy?: TrackedAccountOrderByWithRelationInput | TrackedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrackedAccounts.
     */
    cursor?: TrackedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackedAccounts.
     */
    skip?: number
    distinct?: TrackedAccountScalarFieldEnum | TrackedAccountScalarFieldEnum[]
  }

  /**
   * TrackedAccount create
   */
  export type TrackedAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TrackedAccount.
     */
    data: XOR<TrackedAccountCreateInput, TrackedAccountUncheckedCreateInput>
  }

  /**
   * TrackedAccount createMany
   */
  export type TrackedAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrackedAccounts.
     */
    data: TrackedAccountCreateManyInput | TrackedAccountCreateManyInput[]
  }

  /**
   * TrackedAccount createManyAndReturn
   */
  export type TrackedAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrackedAccounts.
     */
    data: TrackedAccountCreateManyInput | TrackedAccountCreateManyInput[]
  }

  /**
   * TrackedAccount update
   */
  export type TrackedAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TrackedAccount.
     */
    data: XOR<TrackedAccountUpdateInput, TrackedAccountUncheckedUpdateInput>
    /**
     * Choose, which TrackedAccount to update.
     */
    where: TrackedAccountWhereUniqueInput
  }

  /**
   * TrackedAccount updateMany
   */
  export type TrackedAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrackedAccounts.
     */
    data: XOR<TrackedAccountUpdateManyMutationInput, TrackedAccountUncheckedUpdateManyInput>
    /**
     * Filter which TrackedAccounts to update
     */
    where?: TrackedAccountWhereInput
  }

  /**
   * TrackedAccount upsert
   */
  export type TrackedAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TrackedAccount to update in case it exists.
     */
    where: TrackedAccountWhereUniqueInput
    /**
     * In case the TrackedAccount found by the `where` argument doesn't exist, create a new TrackedAccount with this data.
     */
    create: XOR<TrackedAccountCreateInput, TrackedAccountUncheckedCreateInput>
    /**
     * In case the TrackedAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackedAccountUpdateInput, TrackedAccountUncheckedUpdateInput>
  }

  /**
   * TrackedAccount delete
   */
  export type TrackedAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
    /**
     * Filter which TrackedAccount to delete.
     */
    where: TrackedAccountWhereUniqueInput
  }

  /**
   * TrackedAccount deleteMany
   */
  export type TrackedAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackedAccounts to delete
     */
    where?: TrackedAccountWhereInput
  }

  /**
   * TrackedAccount.posts
   */
  export type TrackedAccount$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    where?: IngestedPostWhereInput
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    cursor?: IngestedPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestedPostScalarFieldEnum | IngestedPostScalarFieldEnum[]
  }

  /**
   * TrackedAccount without action
   */
  export type TrackedAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackedAccount
     */
    select?: TrackedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackedAccountInclude<ExtArgs> | null
  }


  /**
   * Model IngestedPost
   */

  export type AggregateIngestedPost = {
    _count: IngestedPostCountAggregateOutputType | null
    _avg: IngestedPostAvgAggregateOutputType | null
    _sum: IngestedPostSumAggregateOutputType | null
    _min: IngestedPostMinAggregateOutputType | null
    _max: IngestedPostMaxAggregateOutputType | null
  }

  export type IngestedPostAvgAggregateOutputType = {
    engagementLikes: number | null
    engagementRetweets: number | null
  }

  export type IngestedPostSumAggregateOutputType = {
    engagementLikes: number | null
    engagementRetweets: number | null
  }

  export type IngestedPostMinAggregateOutputType = {
    id: string | null
    trackedAccountId: string | null
    externalPostId: string | null
    content: string | null
    postedAt: Date | null
    engagementLikes: number | null
    engagementRetweets: number | null
    keywords: string | null
    tickers: string | null
    hashtags: string | null
    narrativeId: string | null
    ingestedAt: Date | null
  }

  export type IngestedPostMaxAggregateOutputType = {
    id: string | null
    trackedAccountId: string | null
    externalPostId: string | null
    content: string | null
    postedAt: Date | null
    engagementLikes: number | null
    engagementRetweets: number | null
    keywords: string | null
    tickers: string | null
    hashtags: string | null
    narrativeId: string | null
    ingestedAt: Date | null
  }

  export type IngestedPostCountAggregateOutputType = {
    id: number
    trackedAccountId: number
    externalPostId: number
    content: number
    postedAt: number
    engagementLikes: number
    engagementRetweets: number
    keywords: number
    tickers: number
    hashtags: number
    narrativeId: number
    ingestedAt: number
    _all: number
  }


  export type IngestedPostAvgAggregateInputType = {
    engagementLikes?: true
    engagementRetweets?: true
  }

  export type IngestedPostSumAggregateInputType = {
    engagementLikes?: true
    engagementRetweets?: true
  }

  export type IngestedPostMinAggregateInputType = {
    id?: true
    trackedAccountId?: true
    externalPostId?: true
    content?: true
    postedAt?: true
    engagementLikes?: true
    engagementRetweets?: true
    keywords?: true
    tickers?: true
    hashtags?: true
    narrativeId?: true
    ingestedAt?: true
  }

  export type IngestedPostMaxAggregateInputType = {
    id?: true
    trackedAccountId?: true
    externalPostId?: true
    content?: true
    postedAt?: true
    engagementLikes?: true
    engagementRetweets?: true
    keywords?: true
    tickers?: true
    hashtags?: true
    narrativeId?: true
    ingestedAt?: true
  }

  export type IngestedPostCountAggregateInputType = {
    id?: true
    trackedAccountId?: true
    externalPostId?: true
    content?: true
    postedAt?: true
    engagementLikes?: true
    engagementRetweets?: true
    keywords?: true
    tickers?: true
    hashtags?: true
    narrativeId?: true
    ingestedAt?: true
    _all?: true
  }

  export type IngestedPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestedPost to aggregate.
     */
    where?: IngestedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedPosts to fetch.
     */
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngestedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngestedPosts
    **/
    _count?: true | IngestedPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngestedPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngestedPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngestedPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngestedPostMaxAggregateInputType
  }

  export type GetIngestedPostAggregateType<T extends IngestedPostAggregateArgs> = {
        [P in keyof T & keyof AggregateIngestedPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestedPost[P]>
      : GetScalarType<T[P], AggregateIngestedPost[P]>
  }




  export type IngestedPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestedPostWhereInput
    orderBy?: IngestedPostOrderByWithAggregationInput | IngestedPostOrderByWithAggregationInput[]
    by: IngestedPostScalarFieldEnum[] | IngestedPostScalarFieldEnum
    having?: IngestedPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestedPostCountAggregateInputType | true
    _avg?: IngestedPostAvgAggregateInputType
    _sum?: IngestedPostSumAggregateInputType
    _min?: IngestedPostMinAggregateInputType
    _max?: IngestedPostMaxAggregateInputType
  }

  export type IngestedPostGroupByOutputType = {
    id: string
    trackedAccountId: string
    externalPostId: string
    content: string
    postedAt: Date
    engagementLikes: number
    engagementRetweets: number
    keywords: string
    tickers: string
    hashtags: string
    narrativeId: string | null
    ingestedAt: Date
    _count: IngestedPostCountAggregateOutputType | null
    _avg: IngestedPostAvgAggregateOutputType | null
    _sum: IngestedPostSumAggregateOutputType | null
    _min: IngestedPostMinAggregateOutputType | null
    _max: IngestedPostMaxAggregateOutputType | null
  }

  type GetIngestedPostGroupByPayload<T extends IngestedPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestedPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngestedPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestedPostGroupByOutputType[P]>
            : GetScalarType<T[P], IngestedPostGroupByOutputType[P]>
        }
      >
    >


  export type IngestedPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackedAccountId?: boolean
    externalPostId?: boolean
    content?: boolean
    postedAt?: boolean
    engagementLikes?: boolean
    engagementRetweets?: boolean
    keywords?: boolean
    tickers?: boolean
    hashtags?: boolean
    narrativeId?: boolean
    ingestedAt?: boolean
    account?: boolean | TrackedAccountDefaultArgs<ExtArgs>
    narrative?: boolean | IngestedPost$narrativeArgs<ExtArgs>
  }, ExtArgs["result"]["ingestedPost"]>

  export type IngestedPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackedAccountId?: boolean
    externalPostId?: boolean
    content?: boolean
    postedAt?: boolean
    engagementLikes?: boolean
    engagementRetweets?: boolean
    keywords?: boolean
    tickers?: boolean
    hashtags?: boolean
    narrativeId?: boolean
    ingestedAt?: boolean
    account?: boolean | TrackedAccountDefaultArgs<ExtArgs>
    narrative?: boolean | IngestedPost$narrativeArgs<ExtArgs>
  }, ExtArgs["result"]["ingestedPost"]>

  export type IngestedPostSelectScalar = {
    id?: boolean
    trackedAccountId?: boolean
    externalPostId?: boolean
    content?: boolean
    postedAt?: boolean
    engagementLikes?: boolean
    engagementRetweets?: boolean
    keywords?: boolean
    tickers?: boolean
    hashtags?: boolean
    narrativeId?: boolean
    ingestedAt?: boolean
  }

  export type IngestedPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | TrackedAccountDefaultArgs<ExtArgs>
    narrative?: boolean | IngestedPost$narrativeArgs<ExtArgs>
  }
  export type IngestedPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | TrackedAccountDefaultArgs<ExtArgs>
    narrative?: boolean | IngestedPost$narrativeArgs<ExtArgs>
  }

  export type $IngestedPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngestedPost"
    objects: {
      account: Prisma.$TrackedAccountPayload<ExtArgs>
      narrative: Prisma.$NarrativePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackedAccountId: string
      externalPostId: string
      content: string
      postedAt: Date
      engagementLikes: number
      engagementRetweets: number
      keywords: string
      tickers: string
      hashtags: string
      narrativeId: string | null
      ingestedAt: Date
    }, ExtArgs["result"]["ingestedPost"]>
    composites: {}
  }

  type IngestedPostGetPayload<S extends boolean | null | undefined | IngestedPostDefaultArgs> = $Result.GetResult<Prisma.$IngestedPostPayload, S>

  type IngestedPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngestedPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngestedPostCountAggregateInputType | true
    }

  export interface IngestedPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngestedPost'], meta: { name: 'IngestedPost' } }
    /**
     * Find zero or one IngestedPost that matches the filter.
     * @param {IngestedPostFindUniqueArgs} args - Arguments to find a IngestedPost
     * @example
     * // Get one IngestedPost
     * const ingestedPost = await prisma.ingestedPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestedPostFindUniqueArgs>(args: SelectSubset<T, IngestedPostFindUniqueArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IngestedPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IngestedPostFindUniqueOrThrowArgs} args - Arguments to find a IngestedPost
     * @example
     * // Get one IngestedPost
     * const ingestedPost = await prisma.ingestedPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestedPostFindUniqueOrThrowArgs>(args: SelectSubset<T, IngestedPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IngestedPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostFindFirstArgs} args - Arguments to find a IngestedPost
     * @example
     * // Get one IngestedPost
     * const ingestedPost = await prisma.ingestedPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestedPostFindFirstArgs>(args?: SelectSubset<T, IngestedPostFindFirstArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IngestedPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostFindFirstOrThrowArgs} args - Arguments to find a IngestedPost
     * @example
     * // Get one IngestedPost
     * const ingestedPost = await prisma.ingestedPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestedPostFindFirstOrThrowArgs>(args?: SelectSubset<T, IngestedPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IngestedPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestedPosts
     * const ingestedPosts = await prisma.ingestedPost.findMany()
     * 
     * // Get first 10 IngestedPosts
     * const ingestedPosts = await prisma.ingestedPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingestedPostWithIdOnly = await prisma.ingestedPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngestedPostFindManyArgs>(args?: SelectSubset<T, IngestedPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IngestedPost.
     * @param {IngestedPostCreateArgs} args - Arguments to create a IngestedPost.
     * @example
     * // Create one IngestedPost
     * const IngestedPost = await prisma.ingestedPost.create({
     *   data: {
     *     // ... data to create a IngestedPost
     *   }
     * })
     * 
     */
    create<T extends IngestedPostCreateArgs>(args: SelectSubset<T, IngestedPostCreateArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IngestedPosts.
     * @param {IngestedPostCreateManyArgs} args - Arguments to create many IngestedPosts.
     * @example
     * // Create many IngestedPosts
     * const ingestedPost = await prisma.ingestedPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngestedPostCreateManyArgs>(args?: SelectSubset<T, IngestedPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestedPosts and returns the data saved in the database.
     * @param {IngestedPostCreateManyAndReturnArgs} args - Arguments to create many IngestedPosts.
     * @example
     * // Create many IngestedPosts
     * const ingestedPost = await prisma.ingestedPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngestedPosts and only return the `id`
     * const ingestedPostWithIdOnly = await prisma.ingestedPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngestedPostCreateManyAndReturnArgs>(args?: SelectSubset<T, IngestedPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IngestedPost.
     * @param {IngestedPostDeleteArgs} args - Arguments to delete one IngestedPost.
     * @example
     * // Delete one IngestedPost
     * const IngestedPost = await prisma.ingestedPost.delete({
     *   where: {
     *     // ... filter to delete one IngestedPost
     *   }
     * })
     * 
     */
    delete<T extends IngestedPostDeleteArgs>(args: SelectSubset<T, IngestedPostDeleteArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IngestedPost.
     * @param {IngestedPostUpdateArgs} args - Arguments to update one IngestedPost.
     * @example
     * // Update one IngestedPost
     * const ingestedPost = await prisma.ingestedPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngestedPostUpdateArgs>(args: SelectSubset<T, IngestedPostUpdateArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IngestedPosts.
     * @param {IngestedPostDeleteManyArgs} args - Arguments to filter IngestedPosts to delete.
     * @example
     * // Delete a few IngestedPosts
     * const { count } = await prisma.ingestedPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngestedPostDeleteManyArgs>(args?: SelectSubset<T, IngestedPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestedPosts
     * const ingestedPost = await prisma.ingestedPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngestedPostUpdateManyArgs>(args: SelectSubset<T, IngestedPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngestedPost.
     * @param {IngestedPostUpsertArgs} args - Arguments to update or create a IngestedPost.
     * @example
     * // Update or create a IngestedPost
     * const ingestedPost = await prisma.ingestedPost.upsert({
     *   create: {
     *     // ... data to create a IngestedPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestedPost we want to update
     *   }
     * })
     */
    upsert<T extends IngestedPostUpsertArgs>(args: SelectSubset<T, IngestedPostUpsertArgs<ExtArgs>>): Prisma__IngestedPostClient<$Result.GetResult<Prisma.$IngestedPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IngestedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostCountArgs} args - Arguments to filter IngestedPosts to count.
     * @example
     * // Count the number of IngestedPosts
     * const count = await prisma.ingestedPost.count({
     *   where: {
     *     // ... the filter for the IngestedPosts we want to count
     *   }
     * })
    **/
    count<T extends IngestedPostCountArgs>(
      args?: Subset<T, IngestedPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestedPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestedPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngestedPostAggregateArgs>(args: Subset<T, IngestedPostAggregateArgs>): Prisma.PrismaPromise<GetIngestedPostAggregateType<T>>

    /**
     * Group by IngestedPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngestedPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestedPostGroupByArgs['orderBy'] }
        : { orderBy?: IngestedPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngestedPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngestedPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngestedPost model
   */
  readonly fields: IngestedPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestedPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestedPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends TrackedAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrackedAccountDefaultArgs<ExtArgs>>): Prisma__TrackedAccountClient<$Result.GetResult<Prisma.$TrackedAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    narrative<T extends IngestedPost$narrativeArgs<ExtArgs> = {}>(args?: Subset<T, IngestedPost$narrativeArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngestedPost model
   */ 
  interface IngestedPostFieldRefs {
    readonly id: FieldRef<"IngestedPost", 'String'>
    readonly trackedAccountId: FieldRef<"IngestedPost", 'String'>
    readonly externalPostId: FieldRef<"IngestedPost", 'String'>
    readonly content: FieldRef<"IngestedPost", 'String'>
    readonly postedAt: FieldRef<"IngestedPost", 'DateTime'>
    readonly engagementLikes: FieldRef<"IngestedPost", 'Int'>
    readonly engagementRetweets: FieldRef<"IngestedPost", 'Int'>
    readonly keywords: FieldRef<"IngestedPost", 'String'>
    readonly tickers: FieldRef<"IngestedPost", 'String'>
    readonly hashtags: FieldRef<"IngestedPost", 'String'>
    readonly narrativeId: FieldRef<"IngestedPost", 'String'>
    readonly ingestedAt: FieldRef<"IngestedPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IngestedPost findUnique
   */
  export type IngestedPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter, which IngestedPost to fetch.
     */
    where: IngestedPostWhereUniqueInput
  }

  /**
   * IngestedPost findUniqueOrThrow
   */
  export type IngestedPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter, which IngestedPost to fetch.
     */
    where: IngestedPostWhereUniqueInput
  }

  /**
   * IngestedPost findFirst
   */
  export type IngestedPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter, which IngestedPost to fetch.
     */
    where?: IngestedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedPosts to fetch.
     */
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestedPosts.
     */
    cursor?: IngestedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestedPosts.
     */
    distinct?: IngestedPostScalarFieldEnum | IngestedPostScalarFieldEnum[]
  }

  /**
   * IngestedPost findFirstOrThrow
   */
  export type IngestedPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter, which IngestedPost to fetch.
     */
    where?: IngestedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedPosts to fetch.
     */
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestedPosts.
     */
    cursor?: IngestedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestedPosts.
     */
    distinct?: IngestedPostScalarFieldEnum | IngestedPostScalarFieldEnum[]
  }

  /**
   * IngestedPost findMany
   */
  export type IngestedPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter, which IngestedPosts to fetch.
     */
    where?: IngestedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedPosts to fetch.
     */
    orderBy?: IngestedPostOrderByWithRelationInput | IngestedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngestedPosts.
     */
    cursor?: IngestedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedPosts.
     */
    skip?: number
    distinct?: IngestedPostScalarFieldEnum | IngestedPostScalarFieldEnum[]
  }

  /**
   * IngestedPost create
   */
  export type IngestedPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * The data needed to create a IngestedPost.
     */
    data: XOR<IngestedPostCreateInput, IngestedPostUncheckedCreateInput>
  }

  /**
   * IngestedPost createMany
   */
  export type IngestedPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngestedPosts.
     */
    data: IngestedPostCreateManyInput | IngestedPostCreateManyInput[]
  }

  /**
   * IngestedPost createManyAndReturn
   */
  export type IngestedPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IngestedPosts.
     */
    data: IngestedPostCreateManyInput | IngestedPostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestedPost update
   */
  export type IngestedPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * The data needed to update a IngestedPost.
     */
    data: XOR<IngestedPostUpdateInput, IngestedPostUncheckedUpdateInput>
    /**
     * Choose, which IngestedPost to update.
     */
    where: IngestedPostWhereUniqueInput
  }

  /**
   * IngestedPost updateMany
   */
  export type IngestedPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngestedPosts.
     */
    data: XOR<IngestedPostUpdateManyMutationInput, IngestedPostUncheckedUpdateManyInput>
    /**
     * Filter which IngestedPosts to update
     */
    where?: IngestedPostWhereInput
  }

  /**
   * IngestedPost upsert
   */
  export type IngestedPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * The filter to search for the IngestedPost to update in case it exists.
     */
    where: IngestedPostWhereUniqueInput
    /**
     * In case the IngestedPost found by the `where` argument doesn't exist, create a new IngestedPost with this data.
     */
    create: XOR<IngestedPostCreateInput, IngestedPostUncheckedCreateInput>
    /**
     * In case the IngestedPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestedPostUpdateInput, IngestedPostUncheckedUpdateInput>
  }

  /**
   * IngestedPost delete
   */
  export type IngestedPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
    /**
     * Filter which IngestedPost to delete.
     */
    where: IngestedPostWhereUniqueInput
  }

  /**
   * IngestedPost deleteMany
   */
  export type IngestedPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestedPosts to delete
     */
    where?: IngestedPostWhereInput
  }

  /**
   * IngestedPost.narrative
   */
  export type IngestedPost$narrativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    where?: NarrativeWhereInput
  }

  /**
   * IngestedPost without action
   */
  export type IngestedPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedPost
     */
    select?: IngestedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedPostInclude<ExtArgs> | null
  }


  /**
   * Model CommunityPulse
   */

  export type AggregateCommunityPulse = {
    _count: CommunityPulseCountAggregateOutputType | null
    _avg: CommunityPulseAvgAggregateOutputType | null
    _sum: CommunityPulseSumAggregateOutputType | null
    _min: CommunityPulseMinAggregateOutputType | null
    _max: CommunityPulseMaxAggregateOutputType | null
  }

  export type CommunityPulseAvgAggregateOutputType = {
    bullishPercent: number | null
    bearishPercent: number | null
    neutralPercent: number | null
    discussionCount: number | null
  }

  export type CommunityPulseSumAggregateOutputType = {
    bullishPercent: number | null
    bearishPercent: number | null
    neutralPercent: number | null
    discussionCount: number | null
  }

  export type CommunityPulseMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    bullishPercent: number | null
    bearishPercent: number | null
    neutralPercent: number | null
    discussionCount: number | null
    calculatedAt: Date | null
    period: string | null
  }

  export type CommunityPulseMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    bullishPercent: number | null
    bearishPercent: number | null
    neutralPercent: number | null
    discussionCount: number | null
    calculatedAt: Date | null
    period: string | null
  }

  export type CommunityPulseCountAggregateOutputType = {
    id: number
    narrativeId: number
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount: number
    calculatedAt: number
    period: number
    _all: number
  }


  export type CommunityPulseAvgAggregateInputType = {
    bullishPercent?: true
    bearishPercent?: true
    neutralPercent?: true
    discussionCount?: true
  }

  export type CommunityPulseSumAggregateInputType = {
    bullishPercent?: true
    bearishPercent?: true
    neutralPercent?: true
    discussionCount?: true
  }

  export type CommunityPulseMinAggregateInputType = {
    id?: true
    narrativeId?: true
    bullishPercent?: true
    bearishPercent?: true
    neutralPercent?: true
    discussionCount?: true
    calculatedAt?: true
    period?: true
  }

  export type CommunityPulseMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    bullishPercent?: true
    bearishPercent?: true
    neutralPercent?: true
    discussionCount?: true
    calculatedAt?: true
    period?: true
  }

  export type CommunityPulseCountAggregateInputType = {
    id?: true
    narrativeId?: true
    bullishPercent?: true
    bearishPercent?: true
    neutralPercent?: true
    discussionCount?: true
    calculatedAt?: true
    period?: true
    _all?: true
  }

  export type CommunityPulseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPulse to aggregate.
     */
    where?: CommunityPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPulses to fetch.
     */
    orderBy?: CommunityPulseOrderByWithRelationInput | CommunityPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPulses
    **/
    _count?: true | CommunityPulseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityPulseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityPulseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityPulseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityPulseMaxAggregateInputType
  }

  export type GetCommunityPulseAggregateType<T extends CommunityPulseAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityPulse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPulse[P]>
      : GetScalarType<T[P], AggregateCommunityPulse[P]>
  }




  export type CommunityPulseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPulseWhereInput
    orderBy?: CommunityPulseOrderByWithAggregationInput | CommunityPulseOrderByWithAggregationInput[]
    by: CommunityPulseScalarFieldEnum[] | CommunityPulseScalarFieldEnum
    having?: CommunityPulseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityPulseCountAggregateInputType | true
    _avg?: CommunityPulseAvgAggregateInputType
    _sum?: CommunityPulseSumAggregateInputType
    _min?: CommunityPulseMinAggregateInputType
    _max?: CommunityPulseMaxAggregateInputType
  }

  export type CommunityPulseGroupByOutputType = {
    id: string
    narrativeId: string | null
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount: number
    calculatedAt: Date
    period: string
    _count: CommunityPulseCountAggregateOutputType | null
    _avg: CommunityPulseAvgAggregateOutputType | null
    _sum: CommunityPulseSumAggregateOutputType | null
    _min: CommunityPulseMinAggregateOutputType | null
    _max: CommunityPulseMaxAggregateOutputType | null
  }

  type GetCommunityPulseGroupByPayload<T extends CommunityPulseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityPulseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityPulseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityPulseGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityPulseGroupByOutputType[P]>
        }
      >
    >


  export type CommunityPulseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    bullishPercent?: boolean
    bearishPercent?: boolean
    neutralPercent?: boolean
    discussionCount?: boolean
    calculatedAt?: boolean
    period?: boolean
    narrative?: boolean | CommunityPulse$narrativeArgs<ExtArgs>
  }, ExtArgs["result"]["communityPulse"]>

  export type CommunityPulseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    bullishPercent?: boolean
    bearishPercent?: boolean
    neutralPercent?: boolean
    discussionCount?: boolean
    calculatedAt?: boolean
    period?: boolean
    narrative?: boolean | CommunityPulse$narrativeArgs<ExtArgs>
  }, ExtArgs["result"]["communityPulse"]>

  export type CommunityPulseSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    bullishPercent?: boolean
    bearishPercent?: boolean
    neutralPercent?: boolean
    discussionCount?: boolean
    calculatedAt?: boolean
    period?: boolean
  }

  export type CommunityPulseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | CommunityPulse$narrativeArgs<ExtArgs>
  }
  export type CommunityPulseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | CommunityPulse$narrativeArgs<ExtArgs>
  }

  export type $CommunityPulsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityPulse"
    objects: {
      narrative: Prisma.$NarrativePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string | null
      bullishPercent: number
      bearishPercent: number
      neutralPercent: number
      discussionCount: number
      calculatedAt: Date
      period: string
    }, ExtArgs["result"]["communityPulse"]>
    composites: {}
  }

  type CommunityPulseGetPayload<S extends boolean | null | undefined | CommunityPulseDefaultArgs> = $Result.GetResult<Prisma.$CommunityPulsePayload, S>

  type CommunityPulseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityPulseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityPulseCountAggregateInputType | true
    }

  export interface CommunityPulseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityPulse'], meta: { name: 'CommunityPulse' } }
    /**
     * Find zero or one CommunityPulse that matches the filter.
     * @param {CommunityPulseFindUniqueArgs} args - Arguments to find a CommunityPulse
     * @example
     * // Get one CommunityPulse
     * const communityPulse = await prisma.communityPulse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityPulseFindUniqueArgs>(args: SelectSubset<T, CommunityPulseFindUniqueArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunityPulse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityPulseFindUniqueOrThrowArgs} args - Arguments to find a CommunityPulse
     * @example
     * // Get one CommunityPulse
     * const communityPulse = await prisma.communityPulse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityPulseFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityPulseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunityPulse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseFindFirstArgs} args - Arguments to find a CommunityPulse
     * @example
     * // Get one CommunityPulse
     * const communityPulse = await prisma.communityPulse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityPulseFindFirstArgs>(args?: SelectSubset<T, CommunityPulseFindFirstArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunityPulse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseFindFirstOrThrowArgs} args - Arguments to find a CommunityPulse
     * @example
     * // Get one CommunityPulse
     * const communityPulse = await prisma.communityPulse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityPulseFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityPulseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunityPulses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPulses
     * const communityPulses = await prisma.communityPulse.findMany()
     * 
     * // Get first 10 CommunityPulses
     * const communityPulses = await prisma.communityPulse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPulseWithIdOnly = await prisma.communityPulse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityPulseFindManyArgs>(args?: SelectSubset<T, CommunityPulseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunityPulse.
     * @param {CommunityPulseCreateArgs} args - Arguments to create a CommunityPulse.
     * @example
     * // Create one CommunityPulse
     * const CommunityPulse = await prisma.communityPulse.create({
     *   data: {
     *     // ... data to create a CommunityPulse
     *   }
     * })
     * 
     */
    create<T extends CommunityPulseCreateArgs>(args: SelectSubset<T, CommunityPulseCreateArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunityPulses.
     * @param {CommunityPulseCreateManyArgs} args - Arguments to create many CommunityPulses.
     * @example
     * // Create many CommunityPulses
     * const communityPulse = await prisma.communityPulse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityPulseCreateManyArgs>(args?: SelectSubset<T, CommunityPulseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityPulses and returns the data saved in the database.
     * @param {CommunityPulseCreateManyAndReturnArgs} args - Arguments to create many CommunityPulses.
     * @example
     * // Create many CommunityPulses
     * const communityPulse = await prisma.communityPulse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityPulses and only return the `id`
     * const communityPulseWithIdOnly = await prisma.communityPulse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityPulseCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityPulseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommunityPulse.
     * @param {CommunityPulseDeleteArgs} args - Arguments to delete one CommunityPulse.
     * @example
     * // Delete one CommunityPulse
     * const CommunityPulse = await prisma.communityPulse.delete({
     *   where: {
     *     // ... filter to delete one CommunityPulse
     *   }
     * })
     * 
     */
    delete<T extends CommunityPulseDeleteArgs>(args: SelectSubset<T, CommunityPulseDeleteArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunityPulse.
     * @param {CommunityPulseUpdateArgs} args - Arguments to update one CommunityPulse.
     * @example
     * // Update one CommunityPulse
     * const communityPulse = await prisma.communityPulse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityPulseUpdateArgs>(args: SelectSubset<T, CommunityPulseUpdateArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunityPulses.
     * @param {CommunityPulseDeleteManyArgs} args - Arguments to filter CommunityPulses to delete.
     * @example
     * // Delete a few CommunityPulses
     * const { count } = await prisma.communityPulse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityPulseDeleteManyArgs>(args?: SelectSubset<T, CommunityPulseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPulses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPulses
     * const communityPulse = await prisma.communityPulse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityPulseUpdateManyArgs>(args: SelectSubset<T, CommunityPulseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunityPulse.
     * @param {CommunityPulseUpsertArgs} args - Arguments to update or create a CommunityPulse.
     * @example
     * // Update or create a CommunityPulse
     * const communityPulse = await prisma.communityPulse.upsert({
     *   create: {
     *     // ... data to create a CommunityPulse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPulse we want to update
     *   }
     * })
     */
    upsert<T extends CommunityPulseUpsertArgs>(args: SelectSubset<T, CommunityPulseUpsertArgs<ExtArgs>>): Prisma__CommunityPulseClient<$Result.GetResult<Prisma.$CommunityPulsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunityPulses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseCountArgs} args - Arguments to filter CommunityPulses to count.
     * @example
     * // Count the number of CommunityPulses
     * const count = await prisma.communityPulse.count({
     *   where: {
     *     // ... the filter for the CommunityPulses we want to count
     *   }
     * })
    **/
    count<T extends CommunityPulseCountArgs>(
      args?: Subset<T, CommunityPulseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPulseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPulse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPulseAggregateArgs>(args: Subset<T, CommunityPulseAggregateArgs>): Prisma.PrismaPromise<GetCommunityPulseAggregateType<T>>

    /**
     * Group by CommunityPulse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPulseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPulseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPulseGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPulseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPulseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPulseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityPulse model
   */
  readonly fields: CommunityPulseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPulse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityPulseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends CommunityPulse$narrativeArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPulse$narrativeArgs<ExtArgs>>): Prisma__NarrativeClient<$Result.GetResult<Prisma.$NarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityPulse model
   */ 
  interface CommunityPulseFieldRefs {
    readonly id: FieldRef<"CommunityPulse", 'String'>
    readonly narrativeId: FieldRef<"CommunityPulse", 'String'>
    readonly bullishPercent: FieldRef<"CommunityPulse", 'Float'>
    readonly bearishPercent: FieldRef<"CommunityPulse", 'Float'>
    readonly neutralPercent: FieldRef<"CommunityPulse", 'Float'>
    readonly discussionCount: FieldRef<"CommunityPulse", 'Int'>
    readonly calculatedAt: FieldRef<"CommunityPulse", 'DateTime'>
    readonly period: FieldRef<"CommunityPulse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommunityPulse findUnique
   */
  export type CommunityPulseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPulse to fetch.
     */
    where: CommunityPulseWhereUniqueInput
  }

  /**
   * CommunityPulse findUniqueOrThrow
   */
  export type CommunityPulseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPulse to fetch.
     */
    where: CommunityPulseWhereUniqueInput
  }

  /**
   * CommunityPulse findFirst
   */
  export type CommunityPulseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPulse to fetch.
     */
    where?: CommunityPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPulses to fetch.
     */
    orderBy?: CommunityPulseOrderByWithRelationInput | CommunityPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPulses.
     */
    cursor?: CommunityPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPulses.
     */
    distinct?: CommunityPulseScalarFieldEnum | CommunityPulseScalarFieldEnum[]
  }

  /**
   * CommunityPulse findFirstOrThrow
   */
  export type CommunityPulseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPulse to fetch.
     */
    where?: CommunityPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPulses to fetch.
     */
    orderBy?: CommunityPulseOrderByWithRelationInput | CommunityPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPulses.
     */
    cursor?: CommunityPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPulses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPulses.
     */
    distinct?: CommunityPulseScalarFieldEnum | CommunityPulseScalarFieldEnum[]
  }

  /**
   * CommunityPulse findMany
   */
  export type CommunityPulseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPulses to fetch.
     */
    where?: CommunityPulseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPulses to fetch.
     */
    orderBy?: CommunityPulseOrderByWithRelationInput | CommunityPulseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPulses.
     */
    cursor?: CommunityPulseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPulses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPulses.
     */
    skip?: number
    distinct?: CommunityPulseScalarFieldEnum | CommunityPulseScalarFieldEnum[]
  }

  /**
   * CommunityPulse create
   */
  export type CommunityPulseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityPulse.
     */
    data: XOR<CommunityPulseCreateInput, CommunityPulseUncheckedCreateInput>
  }

  /**
   * CommunityPulse createMany
   */
  export type CommunityPulseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityPulses.
     */
    data: CommunityPulseCreateManyInput | CommunityPulseCreateManyInput[]
  }

  /**
   * CommunityPulse createManyAndReturn
   */
  export type CommunityPulseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommunityPulses.
     */
    data: CommunityPulseCreateManyInput | CommunityPulseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityPulse update
   */
  export type CommunityPulseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityPulse.
     */
    data: XOR<CommunityPulseUpdateInput, CommunityPulseUncheckedUpdateInput>
    /**
     * Choose, which CommunityPulse to update.
     */
    where: CommunityPulseWhereUniqueInput
  }

  /**
   * CommunityPulse updateMany
   */
  export type CommunityPulseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityPulses.
     */
    data: XOR<CommunityPulseUpdateManyMutationInput, CommunityPulseUncheckedUpdateManyInput>
    /**
     * Filter which CommunityPulses to update
     */
    where?: CommunityPulseWhereInput
  }

  /**
   * CommunityPulse upsert
   */
  export type CommunityPulseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityPulse to update in case it exists.
     */
    where: CommunityPulseWhereUniqueInput
    /**
     * In case the CommunityPulse found by the `where` argument doesn't exist, create a new CommunityPulse with this data.
     */
    create: XOR<CommunityPulseCreateInput, CommunityPulseUncheckedCreateInput>
    /**
     * In case the CommunityPulse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityPulseUpdateInput, CommunityPulseUncheckedUpdateInput>
  }

  /**
   * CommunityPulse delete
   */
  export type CommunityPulseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
    /**
     * Filter which CommunityPulse to delete.
     */
    where: CommunityPulseWhereUniqueInput
  }

  /**
   * CommunityPulse deleteMany
   */
  export type CommunityPulseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPulses to delete
     */
    where?: CommunityPulseWhereInput
  }

  /**
   * CommunityPulse.narrative
   */
  export type CommunityPulse$narrativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Narrative
     */
    select?: NarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeInclude<ExtArgs> | null
    where?: NarrativeWhereInput
  }

  /**
   * CommunityPulse without action
   */
  export type CommunityPulseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPulse
     */
    select?: CommunityPulseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPulseInclude<ExtArgs> | null
  }


  /**
   * Model NewsArticle
   */

  export type AggregateNewsArticle = {
    _count: NewsArticleCountAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  export type NewsArticleMinAggregateOutputType = {
    id: string | null
    source: string | null
    title: string | null
    content: string | null
    url: string | null
    publishedAt: Date | null
    createdAt: Date | null
  }

  export type NewsArticleMaxAggregateOutputType = {
    id: string | null
    source: string | null
    title: string | null
    content: string | null
    url: string | null
    publishedAt: Date | null
    createdAt: Date | null
  }

  export type NewsArticleCountAggregateOutputType = {
    id: number
    source: number
    title: number
    content: number
    url: number
    publishedAt: number
    createdAt: number
    _all: number
  }


  export type NewsArticleMinAggregateInputType = {
    id?: true
    source?: true
    title?: true
    content?: true
    url?: true
    publishedAt?: true
    createdAt?: true
  }

  export type NewsArticleMaxAggregateInputType = {
    id?: true
    source?: true
    title?: true
    content?: true
    url?: true
    publishedAt?: true
    createdAt?: true
  }

  export type NewsArticleCountAggregateInputType = {
    id?: true
    source?: true
    title?: true
    content?: true
    url?: true
    publishedAt?: true
    createdAt?: true
    _all?: true
  }

  export type NewsArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticle to aggregate.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsArticles
    **/
    _count?: true | NewsArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsArticleMaxAggregateInputType
  }

  export type GetNewsArticleAggregateType<T extends NewsArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsArticle[P]>
      : GetScalarType<T[P], AggregateNewsArticle[P]>
  }




  export type NewsArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsArticleWhereInput
    orderBy?: NewsArticleOrderByWithAggregationInput | NewsArticleOrderByWithAggregationInput[]
    by: NewsArticleScalarFieldEnum[] | NewsArticleScalarFieldEnum
    having?: NewsArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsArticleCountAggregateInputType | true
    _min?: NewsArticleMinAggregateInputType
    _max?: NewsArticleMaxAggregateInputType
  }

  export type NewsArticleGroupByOutputType = {
    id: string
    source: string
    title: string
    content: string
    url: string
    publishedAt: Date
    createdAt: Date
    _count: NewsArticleCountAggregateOutputType | null
    _min: NewsArticleMinAggregateOutputType | null
    _max: NewsArticleMaxAggregateOutputType | null
  }

  type GetNewsArticleGroupByPayload<T extends NewsArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
            : GetScalarType<T[P], NewsArticleGroupByOutputType[P]>
        }
      >
    >


  export type NewsArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["newsArticle"]>

  export type NewsArticleSelectScalar = {
    id?: boolean
    source?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    publishedAt?: boolean
    createdAt?: boolean
  }


  export type $NewsArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsArticle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      title: string
      content: string
      url: string
      publishedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["newsArticle"]>
    composites: {}
  }

  type NewsArticleGetPayload<S extends boolean | null | undefined | NewsArticleDefaultArgs> = $Result.GetResult<Prisma.$NewsArticlePayload, S>

  type NewsArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsArticleCountAggregateInputType | true
    }

  export interface NewsArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsArticle'], meta: { name: 'NewsArticle' } }
    /**
     * Find zero or one NewsArticle that matches the filter.
     * @param {NewsArticleFindUniqueArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsArticleFindUniqueArgs>(args: SelectSubset<T, NewsArticleFindUniqueArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsArticleFindUniqueOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsArticleFindFirstArgs>(args?: SelectSubset<T, NewsArticleFindFirstArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindFirstOrThrowArgs} args - Arguments to find a NewsArticle
     * @example
     * // Get one NewsArticle
     * const newsArticle = await prisma.newsArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany()
     * 
     * // Get first 10 NewsArticles
     * const newsArticles = await prisma.newsArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsArticleFindManyArgs>(args?: SelectSubset<T, NewsArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsArticle.
     * @param {NewsArticleCreateArgs} args - Arguments to create a NewsArticle.
     * @example
     * // Create one NewsArticle
     * const NewsArticle = await prisma.newsArticle.create({
     *   data: {
     *     // ... data to create a NewsArticle
     *   }
     * })
     * 
     */
    create<T extends NewsArticleCreateArgs>(args: SelectSubset<T, NewsArticleCreateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsArticles.
     * @param {NewsArticleCreateManyArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsArticleCreateManyArgs>(args?: SelectSubset<T, NewsArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsArticles and returns the data saved in the database.
     * @param {NewsArticleCreateManyAndReturnArgs} args - Arguments to create many NewsArticles.
     * @example
     * // Create many NewsArticles
     * const newsArticle = await prisma.newsArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsArticles and only return the `id`
     * const newsArticleWithIdOnly = await prisma.newsArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsArticle.
     * @param {NewsArticleDeleteArgs} args - Arguments to delete one NewsArticle.
     * @example
     * // Delete one NewsArticle
     * const NewsArticle = await prisma.newsArticle.delete({
     *   where: {
     *     // ... filter to delete one NewsArticle
     *   }
     * })
     * 
     */
    delete<T extends NewsArticleDeleteArgs>(args: SelectSubset<T, NewsArticleDeleteArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsArticle.
     * @param {NewsArticleUpdateArgs} args - Arguments to update one NewsArticle.
     * @example
     * // Update one NewsArticle
     * const newsArticle = await prisma.newsArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsArticleUpdateArgs>(args: SelectSubset<T, NewsArticleUpdateArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsArticles.
     * @param {NewsArticleDeleteManyArgs} args - Arguments to filter NewsArticles to delete.
     * @example
     * // Delete a few NewsArticles
     * const { count } = await prisma.newsArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsArticleDeleteManyArgs>(args?: SelectSubset<T, NewsArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsArticles
     * const newsArticle = await prisma.newsArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsArticleUpdateManyArgs>(args: SelectSubset<T, NewsArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsArticle.
     * @param {NewsArticleUpsertArgs} args - Arguments to update or create a NewsArticle.
     * @example
     * // Update or create a NewsArticle
     * const newsArticle = await prisma.newsArticle.upsert({
     *   create: {
     *     // ... data to create a NewsArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsArticle we want to update
     *   }
     * })
     */
    upsert<T extends NewsArticleUpsertArgs>(args: SelectSubset<T, NewsArticleUpsertArgs<ExtArgs>>): Prisma__NewsArticleClient<$Result.GetResult<Prisma.$NewsArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleCountArgs} args - Arguments to filter NewsArticles to count.
     * @example
     * // Count the number of NewsArticles
     * const count = await prisma.newsArticle.count({
     *   where: {
     *     // ... the filter for the NewsArticles we want to count
     *   }
     * })
    **/
    count<T extends NewsArticleCountArgs>(
      args?: Subset<T, NewsArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsArticleAggregateArgs>(args: Subset<T, NewsArticleAggregateArgs>): Prisma.PrismaPromise<GetNewsArticleAggregateType<T>>

    /**
     * Group by NewsArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsArticleGroupByArgs['orderBy'] }
        : { orderBy?: NewsArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsArticle model
   */
  readonly fields: NewsArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsArticle model
   */ 
  interface NewsArticleFieldRefs {
    readonly id: FieldRef<"NewsArticle", 'String'>
    readonly source: FieldRef<"NewsArticle", 'String'>
    readonly title: FieldRef<"NewsArticle", 'String'>
    readonly content: FieldRef<"NewsArticle", 'String'>
    readonly url: FieldRef<"NewsArticle", 'String'>
    readonly publishedAt: FieldRef<"NewsArticle", 'DateTime'>
    readonly createdAt: FieldRef<"NewsArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsArticle findUnique
   */
  export type NewsArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findUniqueOrThrow
   */
  export type NewsArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle findFirst
   */
  export type NewsArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findFirstOrThrow
   */
  export type NewsArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter, which NewsArticle to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsArticles.
     */
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle findMany
   */
  export type NewsArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter, which NewsArticles to fetch.
     */
    where?: NewsArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsArticles to fetch.
     */
    orderBy?: NewsArticleOrderByWithRelationInput | NewsArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsArticles.
     */
    cursor?: NewsArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsArticles.
     */
    skip?: number
    distinct?: NewsArticleScalarFieldEnum | NewsArticleScalarFieldEnum[]
  }

  /**
   * NewsArticle create
   */
  export type NewsArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * The data needed to create a NewsArticle.
     */
    data: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
  }

  /**
   * NewsArticle createMany
   */
  export type NewsArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
  }

  /**
   * NewsArticle createManyAndReturn
   */
  export type NewsArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsArticles.
     */
    data: NewsArticleCreateManyInput | NewsArticleCreateManyInput[]
  }

  /**
   * NewsArticle update
   */
  export type NewsArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * The data needed to update a NewsArticle.
     */
    data: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
    /**
     * Choose, which NewsArticle to update.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle updateMany
   */
  export type NewsArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsArticles.
     */
    data: XOR<NewsArticleUpdateManyMutationInput, NewsArticleUncheckedUpdateManyInput>
    /**
     * Filter which NewsArticles to update
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle upsert
   */
  export type NewsArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * The filter to search for the NewsArticle to update in case it exists.
     */
    where: NewsArticleWhereUniqueInput
    /**
     * In case the NewsArticle found by the `where` argument doesn't exist, create a new NewsArticle with this data.
     */
    create: XOR<NewsArticleCreateInput, NewsArticleUncheckedCreateInput>
    /**
     * In case the NewsArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsArticleUpdateInput, NewsArticleUncheckedUpdateInput>
  }

  /**
   * NewsArticle delete
   */
  export type NewsArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
    /**
     * Filter which NewsArticle to delete.
     */
    where: NewsArticleWhereUniqueInput
  }

  /**
   * NewsArticle deleteMany
   */
  export type NewsArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsArticles to delete
     */
    where?: NewsArticleWhereInput
  }

  /**
   * NewsArticle without action
   */
  export type NewsArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsArticle
     */
    select?: NewsArticleSelect<ExtArgs> | null
  }


  /**
   * Model NewsSource
   */

  export type AggregateNewsSource = {
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  export type NewsSourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsSourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsSourceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsSourceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsSourceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsSourceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSource to aggregate.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsSources
    **/
    _count?: true | NewsSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsSourceMaxAggregateInputType
  }

  export type GetNewsSourceAggregateType<T extends NewsSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsSource[P]>
      : GetScalarType<T[P], AggregateNewsSource[P]>
  }




  export type NewsSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NewsSourceWhereInput
    orderBy?: NewsSourceOrderByWithAggregationInput | NewsSourceOrderByWithAggregationInput[]
    by: NewsSourceScalarFieldEnum[] | NewsSourceScalarFieldEnum
    having?: NewsSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsSourceCountAggregateInputType | true
    _min?: NewsSourceMinAggregateInputType
    _max?: NewsSourceMaxAggregateInputType
  }

  export type NewsSourceGroupByOutputType = {
    id: string
    name: string
    category: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: NewsSourceCountAggregateOutputType | null
    _min: NewsSourceMinAggregateOutputType | null
    _max: NewsSourceMaxAggregateOutputType | null
  }

  type GetNewsSourceGroupByPayload<T extends NewsSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
            : GetScalarType<T[P], NewsSourceGroupByOutputType[P]>
        }
      >
    >


  export type NewsSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["newsSource"]>

  export type NewsSourceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NewsSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NewsSource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["newsSource"]>
    composites: {}
  }

  type NewsSourceGetPayload<S extends boolean | null | undefined | NewsSourceDefaultArgs> = $Result.GetResult<Prisma.$NewsSourcePayload, S>

  type NewsSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NewsSourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsSourceCountAggregateInputType | true
    }

  export interface NewsSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NewsSource'], meta: { name: 'NewsSource' } }
    /**
     * Find zero or one NewsSource that matches the filter.
     * @param {NewsSourceFindUniqueArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NewsSourceFindUniqueArgs>(args: SelectSubset<T, NewsSourceFindUniqueArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NewsSource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NewsSourceFindUniqueOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NewsSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, NewsSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NewsSourceFindFirstArgs>(args?: SelectSubset<T, NewsSourceFindFirstArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NewsSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindFirstOrThrowArgs} args - Arguments to find a NewsSource
     * @example
     * // Get one NewsSource
     * const newsSource = await prisma.newsSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NewsSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, NewsSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NewsSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsSources
     * const newsSources = await prisma.newsSource.findMany()
     * 
     * // Get first 10 NewsSources
     * const newsSources = await prisma.newsSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NewsSourceFindManyArgs>(args?: SelectSubset<T, NewsSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NewsSource.
     * @param {NewsSourceCreateArgs} args - Arguments to create a NewsSource.
     * @example
     * // Create one NewsSource
     * const NewsSource = await prisma.newsSource.create({
     *   data: {
     *     // ... data to create a NewsSource
     *   }
     * })
     * 
     */
    create<T extends NewsSourceCreateArgs>(args: SelectSubset<T, NewsSourceCreateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NewsSources.
     * @param {NewsSourceCreateManyArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NewsSourceCreateManyArgs>(args?: SelectSubset<T, NewsSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NewsSources and returns the data saved in the database.
     * @param {NewsSourceCreateManyAndReturnArgs} args - Arguments to create many NewsSources.
     * @example
     * // Create many NewsSources
     * const newsSource = await prisma.newsSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NewsSources and only return the `id`
     * const newsSourceWithIdOnly = await prisma.newsSource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NewsSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, NewsSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NewsSource.
     * @param {NewsSourceDeleteArgs} args - Arguments to delete one NewsSource.
     * @example
     * // Delete one NewsSource
     * const NewsSource = await prisma.newsSource.delete({
     *   where: {
     *     // ... filter to delete one NewsSource
     *   }
     * })
     * 
     */
    delete<T extends NewsSourceDeleteArgs>(args: SelectSubset<T, NewsSourceDeleteArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NewsSource.
     * @param {NewsSourceUpdateArgs} args - Arguments to update one NewsSource.
     * @example
     * // Update one NewsSource
     * const newsSource = await prisma.newsSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NewsSourceUpdateArgs>(args: SelectSubset<T, NewsSourceUpdateArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NewsSources.
     * @param {NewsSourceDeleteManyArgs} args - Arguments to filter NewsSources to delete.
     * @example
     * // Delete a few NewsSources
     * const { count } = await prisma.newsSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NewsSourceDeleteManyArgs>(args?: SelectSubset<T, NewsSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsSources
     * const newsSource = await prisma.newsSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NewsSourceUpdateManyArgs>(args: SelectSubset<T, NewsSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsSource.
     * @param {NewsSourceUpsertArgs} args - Arguments to update or create a NewsSource.
     * @example
     * // Update or create a NewsSource
     * const newsSource = await prisma.newsSource.upsert({
     *   create: {
     *     // ... data to create a NewsSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsSource we want to update
     *   }
     * })
     */
    upsert<T extends NewsSourceUpsertArgs>(args: SelectSubset<T, NewsSourceUpsertArgs<ExtArgs>>): Prisma__NewsSourceClient<$Result.GetResult<Prisma.$NewsSourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NewsSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceCountArgs} args - Arguments to filter NewsSources to count.
     * @example
     * // Count the number of NewsSources
     * const count = await prisma.newsSource.count({
     *   where: {
     *     // ... the filter for the NewsSources we want to count
     *   }
     * })
    **/
    count<T extends NewsSourceCountArgs>(
      args?: Subset<T, NewsSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsSourceAggregateArgs>(args: Subset<T, NewsSourceAggregateArgs>): Prisma.PrismaPromise<GetNewsSourceAggregateType<T>>

    /**
     * Group by NewsSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsSourceGroupByArgs['orderBy'] }
        : { orderBy?: NewsSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NewsSource model
   */
  readonly fields: NewsSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NewsSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NewsSource model
   */ 
  interface NewsSourceFieldRefs {
    readonly id: FieldRef<"NewsSource", 'String'>
    readonly name: FieldRef<"NewsSource", 'String'>
    readonly category: FieldRef<"NewsSource", 'String'>
    readonly active: FieldRef<"NewsSource", 'Boolean'>
    readonly createdAt: FieldRef<"NewsSource", 'DateTime'>
    readonly updatedAt: FieldRef<"NewsSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NewsSource findUnique
   */
  export type NewsSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findUniqueOrThrow
   */
  export type NewsSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource findFirst
   */
  export type NewsSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findFirstOrThrow
   */
  export type NewsSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter, which NewsSource to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsSources.
     */
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource findMany
   */
  export type NewsSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter, which NewsSources to fetch.
     */
    where?: NewsSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsSources to fetch.
     */
    orderBy?: NewsSourceOrderByWithRelationInput | NewsSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsSources.
     */
    cursor?: NewsSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsSources.
     */
    skip?: number
    distinct?: NewsSourceScalarFieldEnum | NewsSourceScalarFieldEnum[]
  }

  /**
   * NewsSource create
   */
  export type NewsSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * The data needed to create a NewsSource.
     */
    data: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
  }

  /**
   * NewsSource createMany
   */
  export type NewsSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
  }

  /**
   * NewsSource createManyAndReturn
   */
  export type NewsSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NewsSources.
     */
    data: NewsSourceCreateManyInput | NewsSourceCreateManyInput[]
  }

  /**
   * NewsSource update
   */
  export type NewsSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * The data needed to update a NewsSource.
     */
    data: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
    /**
     * Choose, which NewsSource to update.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource updateMany
   */
  export type NewsSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NewsSources.
     */
    data: XOR<NewsSourceUpdateManyMutationInput, NewsSourceUncheckedUpdateManyInput>
    /**
     * Filter which NewsSources to update
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource upsert
   */
  export type NewsSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * The filter to search for the NewsSource to update in case it exists.
     */
    where: NewsSourceWhereUniqueInput
    /**
     * In case the NewsSource found by the `where` argument doesn't exist, create a new NewsSource with this data.
     */
    create: XOR<NewsSourceCreateInput, NewsSourceUncheckedCreateInput>
    /**
     * In case the NewsSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsSourceUpdateInput, NewsSourceUncheckedUpdateInput>
  }

  /**
   * NewsSource delete
   */
  export type NewsSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
    /**
     * Filter which NewsSource to delete.
     */
    where: NewsSourceWhereUniqueInput
  }

  /**
   * NewsSource deleteMany
   */
  export type NewsSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NewsSources to delete
     */
    where?: NewsSourceWhereInput
  }

  /**
   * NewsSource without action
   */
  export type NewsSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsSource
     */
    select?: NewsSourceSelect<ExtArgs> | null
  }


  /**
   * Model ArticleEntity
   */

  export type AggregateArticleEntity = {
    _count: ArticleEntityCountAggregateOutputType | null
    _min: ArticleEntityMinAggregateOutputType | null
    _max: ArticleEntityMaxAggregateOutputType | null
  }

  export type ArticleEntityMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    entity: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ArticleEntityMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    entity: string | null
    type: string | null
    createdAt: Date | null
  }

  export type ArticleEntityCountAggregateOutputType = {
    id: number
    articleId: number
    entity: number
    type: number
    createdAt: number
    _all: number
  }


  export type ArticleEntityMinAggregateInputType = {
    id?: true
    articleId?: true
    entity?: true
    type?: true
    createdAt?: true
  }

  export type ArticleEntityMaxAggregateInputType = {
    id?: true
    articleId?: true
    entity?: true
    type?: true
    createdAt?: true
  }

  export type ArticleEntityCountAggregateInputType = {
    id?: true
    articleId?: true
    entity?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ArticleEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleEntity to aggregate.
     */
    where?: ArticleEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleEntities to fetch.
     */
    orderBy?: ArticleEntityOrderByWithRelationInput | ArticleEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleEntities
    **/
    _count?: true | ArticleEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleEntityMaxAggregateInputType
  }

  export type GetArticleEntityAggregateType<T extends ArticleEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleEntity[P]>
      : GetScalarType<T[P], AggregateArticleEntity[P]>
  }




  export type ArticleEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleEntityWhereInput
    orderBy?: ArticleEntityOrderByWithAggregationInput | ArticleEntityOrderByWithAggregationInput[]
    by: ArticleEntityScalarFieldEnum[] | ArticleEntityScalarFieldEnum
    having?: ArticleEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleEntityCountAggregateInputType | true
    _min?: ArticleEntityMinAggregateInputType
    _max?: ArticleEntityMaxAggregateInputType
  }

  export type ArticleEntityGroupByOutputType = {
    id: string
    articleId: string
    entity: string
    type: string
    createdAt: Date
    _count: ArticleEntityCountAggregateOutputType | null
    _min: ArticleEntityMinAggregateOutputType | null
    _max: ArticleEntityMaxAggregateOutputType | null
  }

  type GetArticleEntityGroupByPayload<T extends ArticleEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleEntityGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleEntityGroupByOutputType[P]>
        }
      >
    >


  export type ArticleEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    entity?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["articleEntity"]>

  export type ArticleEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    entity?: boolean
    type?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["articleEntity"]>

  export type ArticleEntitySelectScalar = {
    id?: boolean
    articleId?: boolean
    entity?: boolean
    type?: boolean
    createdAt?: boolean
  }


  export type $ArticleEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleEntity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      entity: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["articleEntity"]>
    composites: {}
  }

  type ArticleEntityGetPayload<S extends boolean | null | undefined | ArticleEntityDefaultArgs> = $Result.GetResult<Prisma.$ArticleEntityPayload, S>

  type ArticleEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleEntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleEntityCountAggregateInputType | true
    }

  export interface ArticleEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleEntity'], meta: { name: 'ArticleEntity' } }
    /**
     * Find zero or one ArticleEntity that matches the filter.
     * @param {ArticleEntityFindUniqueArgs} args - Arguments to find a ArticleEntity
     * @example
     * // Get one ArticleEntity
     * const articleEntity = await prisma.articleEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleEntityFindUniqueArgs>(args: SelectSubset<T, ArticleEntityFindUniqueArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ArticleEntity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleEntityFindUniqueOrThrowArgs} args - Arguments to find a ArticleEntity
     * @example
     * // Get one ArticleEntity
     * const articleEntity = await prisma.articleEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ArticleEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityFindFirstArgs} args - Arguments to find a ArticleEntity
     * @example
     * // Get one ArticleEntity
     * const articleEntity = await prisma.articleEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleEntityFindFirstArgs>(args?: SelectSubset<T, ArticleEntityFindFirstArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ArticleEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityFindFirstOrThrowArgs} args - Arguments to find a ArticleEntity
     * @example
     * // Get one ArticleEntity
     * const articleEntity = await prisma.articleEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ArticleEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleEntities
     * const articleEntities = await prisma.articleEntity.findMany()
     * 
     * // Get first 10 ArticleEntities
     * const articleEntities = await prisma.articleEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleEntityWithIdOnly = await prisma.articleEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleEntityFindManyArgs>(args?: SelectSubset<T, ArticleEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ArticleEntity.
     * @param {ArticleEntityCreateArgs} args - Arguments to create a ArticleEntity.
     * @example
     * // Create one ArticleEntity
     * const ArticleEntity = await prisma.articleEntity.create({
     *   data: {
     *     // ... data to create a ArticleEntity
     *   }
     * })
     * 
     */
    create<T extends ArticleEntityCreateArgs>(args: SelectSubset<T, ArticleEntityCreateArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ArticleEntities.
     * @param {ArticleEntityCreateManyArgs} args - Arguments to create many ArticleEntities.
     * @example
     * // Create many ArticleEntities
     * const articleEntity = await prisma.articleEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleEntityCreateManyArgs>(args?: SelectSubset<T, ArticleEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleEntities and returns the data saved in the database.
     * @param {ArticleEntityCreateManyAndReturnArgs} args - Arguments to create many ArticleEntities.
     * @example
     * // Create many ArticleEntities
     * const articleEntity = await prisma.articleEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArticleEntities and only return the `id`
     * const articleEntityWithIdOnly = await prisma.articleEntity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ArticleEntity.
     * @param {ArticleEntityDeleteArgs} args - Arguments to delete one ArticleEntity.
     * @example
     * // Delete one ArticleEntity
     * const ArticleEntity = await prisma.articleEntity.delete({
     *   where: {
     *     // ... filter to delete one ArticleEntity
     *   }
     * })
     * 
     */
    delete<T extends ArticleEntityDeleteArgs>(args: SelectSubset<T, ArticleEntityDeleteArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ArticleEntity.
     * @param {ArticleEntityUpdateArgs} args - Arguments to update one ArticleEntity.
     * @example
     * // Update one ArticleEntity
     * const articleEntity = await prisma.articleEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleEntityUpdateArgs>(args: SelectSubset<T, ArticleEntityUpdateArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ArticleEntities.
     * @param {ArticleEntityDeleteManyArgs} args - Arguments to filter ArticleEntities to delete.
     * @example
     * // Delete a few ArticleEntities
     * const { count } = await prisma.articleEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleEntityDeleteManyArgs>(args?: SelectSubset<T, ArticleEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleEntities
     * const articleEntity = await prisma.articleEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleEntityUpdateManyArgs>(args: SelectSubset<T, ArticleEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleEntity.
     * @param {ArticleEntityUpsertArgs} args - Arguments to update or create a ArticleEntity.
     * @example
     * // Update or create a ArticleEntity
     * const articleEntity = await prisma.articleEntity.upsert({
     *   create: {
     *     // ... data to create a ArticleEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleEntity we want to update
     *   }
     * })
     */
    upsert<T extends ArticleEntityUpsertArgs>(args: SelectSubset<T, ArticleEntityUpsertArgs<ExtArgs>>): Prisma__ArticleEntityClient<$Result.GetResult<Prisma.$ArticleEntityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ArticleEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityCountArgs} args - Arguments to filter ArticleEntities to count.
     * @example
     * // Count the number of ArticleEntities
     * const count = await prisma.articleEntity.count({
     *   where: {
     *     // ... the filter for the ArticleEntities we want to count
     *   }
     * })
    **/
    count<T extends ArticleEntityCountArgs>(
      args?: Subset<T, ArticleEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleEntityAggregateArgs>(args: Subset<T, ArticleEntityAggregateArgs>): Prisma.PrismaPromise<GetArticleEntityAggregateType<T>>

    /**
     * Group by ArticleEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleEntityGroupByArgs['orderBy'] }
        : { orderBy?: ArticleEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleEntity model
   */
  readonly fields: ArticleEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleEntity model
   */ 
  interface ArticleEntityFieldRefs {
    readonly id: FieldRef<"ArticleEntity", 'String'>
    readonly articleId: FieldRef<"ArticleEntity", 'String'>
    readonly entity: FieldRef<"ArticleEntity", 'String'>
    readonly type: FieldRef<"ArticleEntity", 'String'>
    readonly createdAt: FieldRef<"ArticleEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArticleEntity findUnique
   */
  export type ArticleEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter, which ArticleEntity to fetch.
     */
    where: ArticleEntityWhereUniqueInput
  }

  /**
   * ArticleEntity findUniqueOrThrow
   */
  export type ArticleEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter, which ArticleEntity to fetch.
     */
    where: ArticleEntityWhereUniqueInput
  }

  /**
   * ArticleEntity findFirst
   */
  export type ArticleEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter, which ArticleEntity to fetch.
     */
    where?: ArticleEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleEntities to fetch.
     */
    orderBy?: ArticleEntityOrderByWithRelationInput | ArticleEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleEntities.
     */
    cursor?: ArticleEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleEntities.
     */
    distinct?: ArticleEntityScalarFieldEnum | ArticleEntityScalarFieldEnum[]
  }

  /**
   * ArticleEntity findFirstOrThrow
   */
  export type ArticleEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter, which ArticleEntity to fetch.
     */
    where?: ArticleEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleEntities to fetch.
     */
    orderBy?: ArticleEntityOrderByWithRelationInput | ArticleEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleEntities.
     */
    cursor?: ArticleEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleEntities.
     */
    distinct?: ArticleEntityScalarFieldEnum | ArticleEntityScalarFieldEnum[]
  }

  /**
   * ArticleEntity findMany
   */
  export type ArticleEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter, which ArticleEntities to fetch.
     */
    where?: ArticleEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleEntities to fetch.
     */
    orderBy?: ArticleEntityOrderByWithRelationInput | ArticleEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleEntities.
     */
    cursor?: ArticleEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleEntities.
     */
    skip?: number
    distinct?: ArticleEntityScalarFieldEnum | ArticleEntityScalarFieldEnum[]
  }

  /**
   * ArticleEntity create
   */
  export type ArticleEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * The data needed to create a ArticleEntity.
     */
    data: XOR<ArticleEntityCreateInput, ArticleEntityUncheckedCreateInput>
  }

  /**
   * ArticleEntity createMany
   */
  export type ArticleEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleEntities.
     */
    data: ArticleEntityCreateManyInput | ArticleEntityCreateManyInput[]
  }

  /**
   * ArticleEntity createManyAndReturn
   */
  export type ArticleEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ArticleEntities.
     */
    data: ArticleEntityCreateManyInput | ArticleEntityCreateManyInput[]
  }

  /**
   * ArticleEntity update
   */
  export type ArticleEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * The data needed to update a ArticleEntity.
     */
    data: XOR<ArticleEntityUpdateInput, ArticleEntityUncheckedUpdateInput>
    /**
     * Choose, which ArticleEntity to update.
     */
    where: ArticleEntityWhereUniqueInput
  }

  /**
   * ArticleEntity updateMany
   */
  export type ArticleEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleEntities.
     */
    data: XOR<ArticleEntityUpdateManyMutationInput, ArticleEntityUncheckedUpdateManyInput>
    /**
     * Filter which ArticleEntities to update
     */
    where?: ArticleEntityWhereInput
  }

  /**
   * ArticleEntity upsert
   */
  export type ArticleEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * The filter to search for the ArticleEntity to update in case it exists.
     */
    where: ArticleEntityWhereUniqueInput
    /**
     * In case the ArticleEntity found by the `where` argument doesn't exist, create a new ArticleEntity with this data.
     */
    create: XOR<ArticleEntityCreateInput, ArticleEntityUncheckedCreateInput>
    /**
     * In case the ArticleEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleEntityUpdateInput, ArticleEntityUncheckedUpdateInput>
  }

  /**
   * ArticleEntity delete
   */
  export type ArticleEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
    /**
     * Filter which ArticleEntity to delete.
     */
    where: ArticleEntityWhereUniqueInput
  }

  /**
   * ArticleEntity deleteMany
   */
  export type ArticleEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleEntities to delete
     */
    where?: ArticleEntityWhereInput
  }

  /**
   * ArticleEntity without action
   */
  export type ArticleEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleEntity
     */
    select?: ArticleEntitySelect<ExtArgs> | null
  }


  /**
   * Model DetectedNarrative
   */

  export type AggregateDetectedNarrative = {
    _count: DetectedNarrativeCountAggregateOutputType | null
    _min: DetectedNarrativeMinAggregateOutputType | null
    _max: DetectedNarrativeMaxAggregateOutputType | null
  }

  export type DetectedNarrativeMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetectedNarrativeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    sentiment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetectedNarrativeCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    sentiment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetectedNarrativeMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetectedNarrativeMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetectedNarrativeCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    sentiment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetectedNarrativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedNarrative to aggregate.
     */
    where?: DetectedNarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarratives to fetch.
     */
    orderBy?: DetectedNarrativeOrderByWithRelationInput | DetectedNarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectedNarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetectedNarratives
    **/
    _count?: true | DetectedNarrativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectedNarrativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectedNarrativeMaxAggregateInputType
  }

  export type GetDetectedNarrativeAggregateType<T extends DetectedNarrativeAggregateArgs> = {
        [P in keyof T & keyof AggregateDetectedNarrative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetectedNarrative[P]>
      : GetScalarType<T[P], AggregateDetectedNarrative[P]>
  }




  export type DetectedNarrativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectedNarrativeWhereInput
    orderBy?: DetectedNarrativeOrderByWithAggregationInput | DetectedNarrativeOrderByWithAggregationInput[]
    by: DetectedNarrativeScalarFieldEnum[] | DetectedNarrativeScalarFieldEnum
    having?: DetectedNarrativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectedNarrativeCountAggregateInputType | true
    _min?: DetectedNarrativeMinAggregateInputType
    _max?: DetectedNarrativeMaxAggregateInputType
  }

  export type DetectedNarrativeGroupByOutputType = {
    id: string
    title: string
    summary: string
    sentiment: string
    createdAt: Date
    updatedAt: Date
    _count: DetectedNarrativeCountAggregateOutputType | null
    _min: DetectedNarrativeMinAggregateOutputType | null
    _max: DetectedNarrativeMaxAggregateOutputType | null
  }

  type GetDetectedNarrativeGroupByPayload<T extends DetectedNarrativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetectedNarrativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectedNarrativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectedNarrativeGroupByOutputType[P]>
            : GetScalarType<T[P], DetectedNarrativeGroupByOutputType[P]>
        }
      >
    >


  export type DetectedNarrativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articles?: boolean | DetectedNarrative$articlesArgs<ExtArgs>
    metrics?: boolean | DetectedNarrative$metricsArgs<ExtArgs>
    followers?: boolean | DetectedNarrative$followersArgs<ExtArgs>
    messages?: boolean | DetectedNarrative$messagesArgs<ExtArgs>
    stances?: boolean | DetectedNarrative$stancesArgs<ExtArgs>
    _count?: boolean | DetectedNarrativeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detectedNarrative"]>

  export type DetectedNarrativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["detectedNarrative"]>

  export type DetectedNarrativeSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    sentiment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DetectedNarrativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | DetectedNarrative$articlesArgs<ExtArgs>
    metrics?: boolean | DetectedNarrative$metricsArgs<ExtArgs>
    followers?: boolean | DetectedNarrative$followersArgs<ExtArgs>
    messages?: boolean | DetectedNarrative$messagesArgs<ExtArgs>
    stances?: boolean | DetectedNarrative$stancesArgs<ExtArgs>
    _count?: boolean | DetectedNarrativeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DetectedNarrativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DetectedNarrativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetectedNarrative"
    objects: {
      articles: Prisma.$DetectedNarrativeArticlePayload<ExtArgs>[]
      metrics: Prisma.$NarrativeMetricPayload<ExtArgs>[]
      followers: Prisma.$NarrativeFollowerPayload<ExtArgs>[]
      messages: Prisma.$MarketMessagePayload<ExtArgs>[]
      stances: Prisma.$NarrativeStancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string
      sentiment: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["detectedNarrative"]>
    composites: {}
  }

  type DetectedNarrativeGetPayload<S extends boolean | null | undefined | DetectedNarrativeDefaultArgs> = $Result.GetResult<Prisma.$DetectedNarrativePayload, S>

  type DetectedNarrativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetectedNarrativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetectedNarrativeCountAggregateInputType | true
    }

  export interface DetectedNarrativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetectedNarrative'], meta: { name: 'DetectedNarrative' } }
    /**
     * Find zero or one DetectedNarrative that matches the filter.
     * @param {DetectedNarrativeFindUniqueArgs} args - Arguments to find a DetectedNarrative
     * @example
     * // Get one DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetectedNarrativeFindUniqueArgs>(args: SelectSubset<T, DetectedNarrativeFindUniqueArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DetectedNarrative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DetectedNarrativeFindUniqueOrThrowArgs} args - Arguments to find a DetectedNarrative
     * @example
     * // Get one DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetectedNarrativeFindUniqueOrThrowArgs>(args: SelectSubset<T, DetectedNarrativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DetectedNarrative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeFindFirstArgs} args - Arguments to find a DetectedNarrative
     * @example
     * // Get one DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetectedNarrativeFindFirstArgs>(args?: SelectSubset<T, DetectedNarrativeFindFirstArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DetectedNarrative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeFindFirstOrThrowArgs} args - Arguments to find a DetectedNarrative
     * @example
     * // Get one DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetectedNarrativeFindFirstOrThrowArgs>(args?: SelectSubset<T, DetectedNarrativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DetectedNarratives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetectedNarratives
     * const detectedNarratives = await prisma.detectedNarrative.findMany()
     * 
     * // Get first 10 DetectedNarratives
     * const detectedNarratives = await prisma.detectedNarrative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectedNarrativeWithIdOnly = await prisma.detectedNarrative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetectedNarrativeFindManyArgs>(args?: SelectSubset<T, DetectedNarrativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DetectedNarrative.
     * @param {DetectedNarrativeCreateArgs} args - Arguments to create a DetectedNarrative.
     * @example
     * // Create one DetectedNarrative
     * const DetectedNarrative = await prisma.detectedNarrative.create({
     *   data: {
     *     // ... data to create a DetectedNarrative
     *   }
     * })
     * 
     */
    create<T extends DetectedNarrativeCreateArgs>(args: SelectSubset<T, DetectedNarrativeCreateArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DetectedNarratives.
     * @param {DetectedNarrativeCreateManyArgs} args - Arguments to create many DetectedNarratives.
     * @example
     * // Create many DetectedNarratives
     * const detectedNarrative = await prisma.detectedNarrative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetectedNarrativeCreateManyArgs>(args?: SelectSubset<T, DetectedNarrativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetectedNarratives and returns the data saved in the database.
     * @param {DetectedNarrativeCreateManyAndReturnArgs} args - Arguments to create many DetectedNarratives.
     * @example
     * // Create many DetectedNarratives
     * const detectedNarrative = await prisma.detectedNarrative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetectedNarratives and only return the `id`
     * const detectedNarrativeWithIdOnly = await prisma.detectedNarrative.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetectedNarrativeCreateManyAndReturnArgs>(args?: SelectSubset<T, DetectedNarrativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DetectedNarrative.
     * @param {DetectedNarrativeDeleteArgs} args - Arguments to delete one DetectedNarrative.
     * @example
     * // Delete one DetectedNarrative
     * const DetectedNarrative = await prisma.detectedNarrative.delete({
     *   where: {
     *     // ... filter to delete one DetectedNarrative
     *   }
     * })
     * 
     */
    delete<T extends DetectedNarrativeDeleteArgs>(args: SelectSubset<T, DetectedNarrativeDeleteArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DetectedNarrative.
     * @param {DetectedNarrativeUpdateArgs} args - Arguments to update one DetectedNarrative.
     * @example
     * // Update one DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetectedNarrativeUpdateArgs>(args: SelectSubset<T, DetectedNarrativeUpdateArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DetectedNarratives.
     * @param {DetectedNarrativeDeleteManyArgs} args - Arguments to filter DetectedNarratives to delete.
     * @example
     * // Delete a few DetectedNarratives
     * const { count } = await prisma.detectedNarrative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetectedNarrativeDeleteManyArgs>(args?: SelectSubset<T, DetectedNarrativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetectedNarratives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetectedNarratives
     * const detectedNarrative = await prisma.detectedNarrative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetectedNarrativeUpdateManyArgs>(args: SelectSubset<T, DetectedNarrativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetectedNarrative.
     * @param {DetectedNarrativeUpsertArgs} args - Arguments to update or create a DetectedNarrative.
     * @example
     * // Update or create a DetectedNarrative
     * const detectedNarrative = await prisma.detectedNarrative.upsert({
     *   create: {
     *     // ... data to create a DetectedNarrative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetectedNarrative we want to update
     *   }
     * })
     */
    upsert<T extends DetectedNarrativeUpsertArgs>(args: SelectSubset<T, DetectedNarrativeUpsertArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DetectedNarratives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeCountArgs} args - Arguments to filter DetectedNarratives to count.
     * @example
     * // Count the number of DetectedNarratives
     * const count = await prisma.detectedNarrative.count({
     *   where: {
     *     // ... the filter for the DetectedNarratives we want to count
     *   }
     * })
    **/
    count<T extends DetectedNarrativeCountArgs>(
      args?: Subset<T, DetectedNarrativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectedNarrativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetectedNarrative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectedNarrativeAggregateArgs>(args: Subset<T, DetectedNarrativeAggregateArgs>): Prisma.PrismaPromise<GetDetectedNarrativeAggregateType<T>>

    /**
     * Group by DetectedNarrative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectedNarrativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectedNarrativeGroupByArgs['orderBy'] }
        : { orderBy?: DetectedNarrativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectedNarrativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectedNarrativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetectedNarrative model
   */
  readonly fields: DetectedNarrativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetectedNarrative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetectedNarrativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends DetectedNarrative$articlesArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrative$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends DetectedNarrative$metricsArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrative$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findMany"> | Null>
    followers<T extends DetectedNarrative$followersArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrative$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends DetectedNarrative$messagesArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrative$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    stances<T extends DetectedNarrative$stancesArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrative$stancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetectedNarrative model
   */ 
  interface DetectedNarrativeFieldRefs {
    readonly id: FieldRef<"DetectedNarrative", 'String'>
    readonly title: FieldRef<"DetectedNarrative", 'String'>
    readonly summary: FieldRef<"DetectedNarrative", 'String'>
    readonly sentiment: FieldRef<"DetectedNarrative", 'String'>
    readonly createdAt: FieldRef<"DetectedNarrative", 'DateTime'>
    readonly updatedAt: FieldRef<"DetectedNarrative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetectedNarrative findUnique
   */
  export type DetectedNarrativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrative to fetch.
     */
    where: DetectedNarrativeWhereUniqueInput
  }

  /**
   * DetectedNarrative findUniqueOrThrow
   */
  export type DetectedNarrativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrative to fetch.
     */
    where: DetectedNarrativeWhereUniqueInput
  }

  /**
   * DetectedNarrative findFirst
   */
  export type DetectedNarrativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrative to fetch.
     */
    where?: DetectedNarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarratives to fetch.
     */
    orderBy?: DetectedNarrativeOrderByWithRelationInput | DetectedNarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedNarratives.
     */
    cursor?: DetectedNarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedNarratives.
     */
    distinct?: DetectedNarrativeScalarFieldEnum | DetectedNarrativeScalarFieldEnum[]
  }

  /**
   * DetectedNarrative findFirstOrThrow
   */
  export type DetectedNarrativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrative to fetch.
     */
    where?: DetectedNarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarratives to fetch.
     */
    orderBy?: DetectedNarrativeOrderByWithRelationInput | DetectedNarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedNarratives.
     */
    cursor?: DetectedNarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarratives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedNarratives.
     */
    distinct?: DetectedNarrativeScalarFieldEnum | DetectedNarrativeScalarFieldEnum[]
  }

  /**
   * DetectedNarrative findMany
   */
  export type DetectedNarrativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarratives to fetch.
     */
    where?: DetectedNarrativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarratives to fetch.
     */
    orderBy?: DetectedNarrativeOrderByWithRelationInput | DetectedNarrativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetectedNarratives.
     */
    cursor?: DetectedNarrativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarratives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarratives.
     */
    skip?: number
    distinct?: DetectedNarrativeScalarFieldEnum | DetectedNarrativeScalarFieldEnum[]
  }

  /**
   * DetectedNarrative create
   */
  export type DetectedNarrativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * The data needed to create a DetectedNarrative.
     */
    data: XOR<DetectedNarrativeCreateInput, DetectedNarrativeUncheckedCreateInput>
  }

  /**
   * DetectedNarrative createMany
   */
  export type DetectedNarrativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetectedNarratives.
     */
    data: DetectedNarrativeCreateManyInput | DetectedNarrativeCreateManyInput[]
  }

  /**
   * DetectedNarrative createManyAndReturn
   */
  export type DetectedNarrativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DetectedNarratives.
     */
    data: DetectedNarrativeCreateManyInput | DetectedNarrativeCreateManyInput[]
  }

  /**
   * DetectedNarrative update
   */
  export type DetectedNarrativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * The data needed to update a DetectedNarrative.
     */
    data: XOR<DetectedNarrativeUpdateInput, DetectedNarrativeUncheckedUpdateInput>
    /**
     * Choose, which DetectedNarrative to update.
     */
    where: DetectedNarrativeWhereUniqueInput
  }

  /**
   * DetectedNarrative updateMany
   */
  export type DetectedNarrativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetectedNarratives.
     */
    data: XOR<DetectedNarrativeUpdateManyMutationInput, DetectedNarrativeUncheckedUpdateManyInput>
    /**
     * Filter which DetectedNarratives to update
     */
    where?: DetectedNarrativeWhereInput
  }

  /**
   * DetectedNarrative upsert
   */
  export type DetectedNarrativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * The filter to search for the DetectedNarrative to update in case it exists.
     */
    where: DetectedNarrativeWhereUniqueInput
    /**
     * In case the DetectedNarrative found by the `where` argument doesn't exist, create a new DetectedNarrative with this data.
     */
    create: XOR<DetectedNarrativeCreateInput, DetectedNarrativeUncheckedCreateInput>
    /**
     * In case the DetectedNarrative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectedNarrativeUpdateInput, DetectedNarrativeUncheckedUpdateInput>
  }

  /**
   * DetectedNarrative delete
   */
  export type DetectedNarrativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
    /**
     * Filter which DetectedNarrative to delete.
     */
    where: DetectedNarrativeWhereUniqueInput
  }

  /**
   * DetectedNarrative deleteMany
   */
  export type DetectedNarrativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedNarratives to delete
     */
    where?: DetectedNarrativeWhereInput
  }

  /**
   * DetectedNarrative.articles
   */
  export type DetectedNarrative$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    where?: DetectedNarrativeArticleWhereInput
    orderBy?: DetectedNarrativeArticleOrderByWithRelationInput | DetectedNarrativeArticleOrderByWithRelationInput[]
    cursor?: DetectedNarrativeArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetectedNarrativeArticleScalarFieldEnum | DetectedNarrativeArticleScalarFieldEnum[]
  }

  /**
   * DetectedNarrative.metrics
   */
  export type DetectedNarrative$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    where?: NarrativeMetricWhereInput
    orderBy?: NarrativeMetricOrderByWithRelationInput | NarrativeMetricOrderByWithRelationInput[]
    cursor?: NarrativeMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeMetricScalarFieldEnum | NarrativeMetricScalarFieldEnum[]
  }

  /**
   * DetectedNarrative.followers
   */
  export type DetectedNarrative$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    where?: NarrativeFollowerWhereInput
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    cursor?: NarrativeFollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeFollowerScalarFieldEnum | NarrativeFollowerScalarFieldEnum[]
  }

  /**
   * DetectedNarrative.messages
   */
  export type DetectedNarrative$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    where?: MarketMessageWhereInput
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    cursor?: MarketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketMessageScalarFieldEnum | MarketMessageScalarFieldEnum[]
  }

  /**
   * DetectedNarrative.stances
   */
  export type DetectedNarrative$stancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    where?: NarrativeStanceWhereInput
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    cursor?: NarrativeStanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NarrativeStanceScalarFieldEnum | NarrativeStanceScalarFieldEnum[]
  }

  /**
   * DetectedNarrative without action
   */
  export type DetectedNarrativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrative
     */
    select?: DetectedNarrativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeInclude<ExtArgs> | null
  }


  /**
   * Model MarketMessage
   */

  export type AggregateMarketMessage = {
    _count: MarketMessageCountAggregateOutputType | null
    _min: MarketMessageMinAggregateOutputType | null
    _max: MarketMessageMaxAggregateOutputType | null
  }

  export type MarketMessageMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type MarketMessageMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    userId: string | null
    text: string | null
    createdAt: Date | null
  }

  export type MarketMessageCountAggregateOutputType = {
    id: number
    narrativeId: number
    userId: number
    text: number
    createdAt: number
    _all: number
  }


  export type MarketMessageMinAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type MarketMessageMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    text?: true
    createdAt?: true
  }

  export type MarketMessageCountAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    text?: true
    createdAt?: true
    _all?: true
  }

  export type MarketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketMessage to aggregate.
     */
    where?: MarketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMessages to fetch.
     */
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketMessages
    **/
    _count?: true | MarketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketMessageMaxAggregateInputType
  }

  export type GetMarketMessageAggregateType<T extends MarketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketMessage[P]>
      : GetScalarType<T[P], AggregateMarketMessage[P]>
  }




  export type MarketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketMessageWhereInput
    orderBy?: MarketMessageOrderByWithAggregationInput | MarketMessageOrderByWithAggregationInput[]
    by: MarketMessageScalarFieldEnum[] | MarketMessageScalarFieldEnum
    having?: MarketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketMessageCountAggregateInputType | true
    _min?: MarketMessageMinAggregateInputType
    _max?: MarketMessageMaxAggregateInputType
  }

  export type MarketMessageGroupByOutputType = {
    id: string
    narrativeId: string
    userId: string
    text: string
    createdAt: Date
    _count: MarketMessageCountAggregateOutputType | null
    _min: MarketMessageMinAggregateOutputType | null
    _max: MarketMessageMaxAggregateOutputType | null
  }

  type GetMarketMessageGroupByPayload<T extends MarketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], MarketMessageGroupByOutputType[P]>
        }
      >
    >


  export type MarketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketMessage"]>

  export type MarketMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketMessage"]>

  export type MarketMessageSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    text?: boolean
    createdAt?: boolean
  }

  export type MarketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MarketMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MarketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketMessage"
    objects: {
      narrative: Prisma.$DetectedNarrativePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      userId: string
      text: string
      createdAt: Date
    }, ExtArgs["result"]["marketMessage"]>
    composites: {}
  }

  type MarketMessageGetPayload<S extends boolean | null | undefined | MarketMessageDefaultArgs> = $Result.GetResult<Prisma.$MarketMessagePayload, S>

  type MarketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketMessageCountAggregateInputType | true
    }

  export interface MarketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketMessage'], meta: { name: 'MarketMessage' } }
    /**
     * Find zero or one MarketMessage that matches the filter.
     * @param {MarketMessageFindUniqueArgs} args - Arguments to find a MarketMessage
     * @example
     * // Get one MarketMessage
     * const marketMessage = await prisma.marketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketMessageFindUniqueArgs>(args: SelectSubset<T, MarketMessageFindUniqueArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketMessageFindUniqueOrThrowArgs} args - Arguments to find a MarketMessage
     * @example
     * // Get one MarketMessage
     * const marketMessage = await prisma.marketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageFindFirstArgs} args - Arguments to find a MarketMessage
     * @example
     * // Get one MarketMessage
     * const marketMessage = await prisma.marketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketMessageFindFirstArgs>(args?: SelectSubset<T, MarketMessageFindFirstArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageFindFirstOrThrowArgs} args - Arguments to find a MarketMessage
     * @example
     * // Get one MarketMessage
     * const marketMessage = await prisma.marketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketMessages
     * const marketMessages = await prisma.marketMessage.findMany()
     * 
     * // Get first 10 MarketMessages
     * const marketMessages = await prisma.marketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketMessageWithIdOnly = await prisma.marketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketMessageFindManyArgs>(args?: SelectSubset<T, MarketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketMessage.
     * @param {MarketMessageCreateArgs} args - Arguments to create a MarketMessage.
     * @example
     * // Create one MarketMessage
     * const MarketMessage = await prisma.marketMessage.create({
     *   data: {
     *     // ... data to create a MarketMessage
     *   }
     * })
     * 
     */
    create<T extends MarketMessageCreateArgs>(args: SelectSubset<T, MarketMessageCreateArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketMessages.
     * @param {MarketMessageCreateManyArgs} args - Arguments to create many MarketMessages.
     * @example
     * // Create many MarketMessages
     * const marketMessage = await prisma.marketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketMessageCreateManyArgs>(args?: SelectSubset<T, MarketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketMessages and returns the data saved in the database.
     * @param {MarketMessageCreateManyAndReturnArgs} args - Arguments to create many MarketMessages.
     * @example
     * // Create many MarketMessages
     * const marketMessage = await prisma.marketMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketMessages and only return the `id`
     * const marketMessageWithIdOnly = await prisma.marketMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketMessage.
     * @param {MarketMessageDeleteArgs} args - Arguments to delete one MarketMessage.
     * @example
     * // Delete one MarketMessage
     * const MarketMessage = await prisma.marketMessage.delete({
     *   where: {
     *     // ... filter to delete one MarketMessage
     *   }
     * })
     * 
     */
    delete<T extends MarketMessageDeleteArgs>(args: SelectSubset<T, MarketMessageDeleteArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketMessage.
     * @param {MarketMessageUpdateArgs} args - Arguments to update one MarketMessage.
     * @example
     * // Update one MarketMessage
     * const marketMessage = await prisma.marketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketMessageUpdateArgs>(args: SelectSubset<T, MarketMessageUpdateArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketMessages.
     * @param {MarketMessageDeleteManyArgs} args - Arguments to filter MarketMessages to delete.
     * @example
     * // Delete a few MarketMessages
     * const { count } = await prisma.marketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketMessageDeleteManyArgs>(args?: SelectSubset<T, MarketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketMessages
     * const marketMessage = await prisma.marketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketMessageUpdateManyArgs>(args: SelectSubset<T, MarketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketMessage.
     * @param {MarketMessageUpsertArgs} args - Arguments to update or create a MarketMessage.
     * @example
     * // Update or create a MarketMessage
     * const marketMessage = await prisma.marketMessage.upsert({
     *   create: {
     *     // ... data to create a MarketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketMessage we want to update
     *   }
     * })
     */
    upsert<T extends MarketMessageUpsertArgs>(args: SelectSubset<T, MarketMessageUpsertArgs<ExtArgs>>): Prisma__MarketMessageClient<$Result.GetResult<Prisma.$MarketMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageCountArgs} args - Arguments to filter MarketMessages to count.
     * @example
     * // Count the number of MarketMessages
     * const count = await prisma.marketMessage.count({
     *   where: {
     *     // ... the filter for the MarketMessages we want to count
     *   }
     * })
    **/
    count<T extends MarketMessageCountArgs>(
      args?: Subset<T, MarketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketMessageAggregateArgs>(args: Subset<T, MarketMessageAggregateArgs>): Prisma.PrismaPromise<GetMarketMessageAggregateType<T>>

    /**
     * Group by MarketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketMessageGroupByArgs['orderBy'] }
        : { orderBy?: MarketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketMessage model
   */
  readonly fields: MarketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends DetectedNarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrativeDefaultArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketMessage model
   */ 
  interface MarketMessageFieldRefs {
    readonly id: FieldRef<"MarketMessage", 'String'>
    readonly narrativeId: FieldRef<"MarketMessage", 'String'>
    readonly userId: FieldRef<"MarketMessage", 'String'>
    readonly text: FieldRef<"MarketMessage", 'String'>
    readonly createdAt: FieldRef<"MarketMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketMessage findUnique
   */
  export type MarketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter, which MarketMessage to fetch.
     */
    where: MarketMessageWhereUniqueInput
  }

  /**
   * MarketMessage findUniqueOrThrow
   */
  export type MarketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter, which MarketMessage to fetch.
     */
    where: MarketMessageWhereUniqueInput
  }

  /**
   * MarketMessage findFirst
   */
  export type MarketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter, which MarketMessage to fetch.
     */
    where?: MarketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMessages to fetch.
     */
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketMessages.
     */
    cursor?: MarketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketMessages.
     */
    distinct?: MarketMessageScalarFieldEnum | MarketMessageScalarFieldEnum[]
  }

  /**
   * MarketMessage findFirstOrThrow
   */
  export type MarketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter, which MarketMessage to fetch.
     */
    where?: MarketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMessages to fetch.
     */
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketMessages.
     */
    cursor?: MarketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketMessages.
     */
    distinct?: MarketMessageScalarFieldEnum | MarketMessageScalarFieldEnum[]
  }

  /**
   * MarketMessage findMany
   */
  export type MarketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter, which MarketMessages to fetch.
     */
    where?: MarketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketMessages to fetch.
     */
    orderBy?: MarketMessageOrderByWithRelationInput | MarketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketMessages.
     */
    cursor?: MarketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketMessages.
     */
    skip?: number
    distinct?: MarketMessageScalarFieldEnum | MarketMessageScalarFieldEnum[]
  }

  /**
   * MarketMessage create
   */
  export type MarketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketMessage.
     */
    data: XOR<MarketMessageCreateInput, MarketMessageUncheckedCreateInput>
  }

  /**
   * MarketMessage createMany
   */
  export type MarketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketMessages.
     */
    data: MarketMessageCreateManyInput | MarketMessageCreateManyInput[]
  }

  /**
   * MarketMessage createManyAndReturn
   */
  export type MarketMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketMessages.
     */
    data: MarketMessageCreateManyInput | MarketMessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketMessage update
   */
  export type MarketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketMessage.
     */
    data: XOR<MarketMessageUpdateInput, MarketMessageUncheckedUpdateInput>
    /**
     * Choose, which MarketMessage to update.
     */
    where: MarketMessageWhereUniqueInput
  }

  /**
   * MarketMessage updateMany
   */
  export type MarketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketMessages.
     */
    data: XOR<MarketMessageUpdateManyMutationInput, MarketMessageUncheckedUpdateManyInput>
    /**
     * Filter which MarketMessages to update
     */
    where?: MarketMessageWhereInput
  }

  /**
   * MarketMessage upsert
   */
  export type MarketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketMessage to update in case it exists.
     */
    where: MarketMessageWhereUniqueInput
    /**
     * In case the MarketMessage found by the `where` argument doesn't exist, create a new MarketMessage with this data.
     */
    create: XOR<MarketMessageCreateInput, MarketMessageUncheckedCreateInput>
    /**
     * In case the MarketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketMessageUpdateInput, MarketMessageUncheckedUpdateInput>
  }

  /**
   * MarketMessage delete
   */
  export type MarketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
    /**
     * Filter which MarketMessage to delete.
     */
    where: MarketMessageWhereUniqueInput
  }

  /**
   * MarketMessage deleteMany
   */
  export type MarketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketMessages to delete
     */
    where?: MarketMessageWhereInput
  }

  /**
   * MarketMessage without action
   */
  export type MarketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketMessage
     */
    select?: MarketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketMessageInclude<ExtArgs> | null
  }


  /**
   * Model NarrativeFollower
   */

  export type AggregateNarrativeFollower = {
    _count: NarrativeFollowerCountAggregateOutputType | null
    _min: NarrativeFollowerMinAggregateOutputType | null
    _max: NarrativeFollowerMaxAggregateOutputType | null
  }

  export type NarrativeFollowerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    narrativeId: string | null
    createdAt: Date | null
  }

  export type NarrativeFollowerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    narrativeId: string | null
    createdAt: Date | null
  }

  export type NarrativeFollowerCountAggregateOutputType = {
    id: number
    userId: number
    narrativeId: number
    createdAt: number
    _all: number
  }


  export type NarrativeFollowerMinAggregateInputType = {
    id?: true
    userId?: true
    narrativeId?: true
    createdAt?: true
  }

  export type NarrativeFollowerMaxAggregateInputType = {
    id?: true
    userId?: true
    narrativeId?: true
    createdAt?: true
  }

  export type NarrativeFollowerCountAggregateInputType = {
    id?: true
    userId?: true
    narrativeId?: true
    createdAt?: true
    _all?: true
  }

  export type NarrativeFollowerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeFollower to aggregate.
     */
    where?: NarrativeFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeFollowers to fetch.
     */
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NarrativeFollowers
    **/
    _count?: true | NarrativeFollowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeFollowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeFollowerMaxAggregateInputType
  }

  export type GetNarrativeFollowerAggregateType<T extends NarrativeFollowerAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrativeFollower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrativeFollower[P]>
      : GetScalarType<T[P], AggregateNarrativeFollower[P]>
  }




  export type NarrativeFollowerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeFollowerWhereInput
    orderBy?: NarrativeFollowerOrderByWithAggregationInput | NarrativeFollowerOrderByWithAggregationInput[]
    by: NarrativeFollowerScalarFieldEnum[] | NarrativeFollowerScalarFieldEnum
    having?: NarrativeFollowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeFollowerCountAggregateInputType | true
    _min?: NarrativeFollowerMinAggregateInputType
    _max?: NarrativeFollowerMaxAggregateInputType
  }

  export type NarrativeFollowerGroupByOutputType = {
    id: string
    userId: string
    narrativeId: string
    createdAt: Date
    _count: NarrativeFollowerCountAggregateOutputType | null
    _min: NarrativeFollowerMinAggregateOutputType | null
    _max: NarrativeFollowerMaxAggregateOutputType | null
  }

  type GetNarrativeFollowerGroupByPayload<T extends NarrativeFollowerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeFollowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeFollowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeFollowerGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeFollowerGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeFollowerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    narrativeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeFollower"]>

  export type NarrativeFollowerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    narrativeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeFollower"]>

  export type NarrativeFollowerSelectScalar = {
    id?: boolean
    userId?: boolean
    narrativeId?: boolean
    createdAt?: boolean
  }

  export type NarrativeFollowerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }
  export type NarrativeFollowerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }

  export type $NarrativeFollowerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NarrativeFollower"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      narrative: Prisma.$DetectedNarrativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      narrativeId: string
      createdAt: Date
    }, ExtArgs["result"]["narrativeFollower"]>
    composites: {}
  }

  type NarrativeFollowerGetPayload<S extends boolean | null | undefined | NarrativeFollowerDefaultArgs> = $Result.GetResult<Prisma.$NarrativeFollowerPayload, S>

  type NarrativeFollowerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeFollowerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeFollowerCountAggregateInputType | true
    }

  export interface NarrativeFollowerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NarrativeFollower'], meta: { name: 'NarrativeFollower' } }
    /**
     * Find zero or one NarrativeFollower that matches the filter.
     * @param {NarrativeFollowerFindUniqueArgs} args - Arguments to find a NarrativeFollower
     * @example
     * // Get one NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeFollowerFindUniqueArgs>(args: SelectSubset<T, NarrativeFollowerFindUniqueArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NarrativeFollower that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeFollowerFindUniqueOrThrowArgs} args - Arguments to find a NarrativeFollower
     * @example
     * // Get one NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeFollowerFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeFollowerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NarrativeFollower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerFindFirstArgs} args - Arguments to find a NarrativeFollower
     * @example
     * // Get one NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeFollowerFindFirstArgs>(args?: SelectSubset<T, NarrativeFollowerFindFirstArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NarrativeFollower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerFindFirstOrThrowArgs} args - Arguments to find a NarrativeFollower
     * @example
     * // Get one NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeFollowerFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeFollowerFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NarrativeFollowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NarrativeFollowers
     * const narrativeFollowers = await prisma.narrativeFollower.findMany()
     * 
     * // Get first 10 NarrativeFollowers
     * const narrativeFollowers = await prisma.narrativeFollower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeFollowerWithIdOnly = await prisma.narrativeFollower.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeFollowerFindManyArgs>(args?: SelectSubset<T, NarrativeFollowerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NarrativeFollower.
     * @param {NarrativeFollowerCreateArgs} args - Arguments to create a NarrativeFollower.
     * @example
     * // Create one NarrativeFollower
     * const NarrativeFollower = await prisma.narrativeFollower.create({
     *   data: {
     *     // ... data to create a NarrativeFollower
     *   }
     * })
     * 
     */
    create<T extends NarrativeFollowerCreateArgs>(args: SelectSubset<T, NarrativeFollowerCreateArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NarrativeFollowers.
     * @param {NarrativeFollowerCreateManyArgs} args - Arguments to create many NarrativeFollowers.
     * @example
     * // Create many NarrativeFollowers
     * const narrativeFollower = await prisma.narrativeFollower.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeFollowerCreateManyArgs>(args?: SelectSubset<T, NarrativeFollowerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NarrativeFollowers and returns the data saved in the database.
     * @param {NarrativeFollowerCreateManyAndReturnArgs} args - Arguments to create many NarrativeFollowers.
     * @example
     * // Create many NarrativeFollowers
     * const narrativeFollower = await prisma.narrativeFollower.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NarrativeFollowers and only return the `id`
     * const narrativeFollowerWithIdOnly = await prisma.narrativeFollower.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeFollowerCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeFollowerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NarrativeFollower.
     * @param {NarrativeFollowerDeleteArgs} args - Arguments to delete one NarrativeFollower.
     * @example
     * // Delete one NarrativeFollower
     * const NarrativeFollower = await prisma.narrativeFollower.delete({
     *   where: {
     *     // ... filter to delete one NarrativeFollower
     *   }
     * })
     * 
     */
    delete<T extends NarrativeFollowerDeleteArgs>(args: SelectSubset<T, NarrativeFollowerDeleteArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NarrativeFollower.
     * @param {NarrativeFollowerUpdateArgs} args - Arguments to update one NarrativeFollower.
     * @example
     * // Update one NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeFollowerUpdateArgs>(args: SelectSubset<T, NarrativeFollowerUpdateArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NarrativeFollowers.
     * @param {NarrativeFollowerDeleteManyArgs} args - Arguments to filter NarrativeFollowers to delete.
     * @example
     * // Delete a few NarrativeFollowers
     * const { count } = await prisma.narrativeFollower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeFollowerDeleteManyArgs>(args?: SelectSubset<T, NarrativeFollowerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NarrativeFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NarrativeFollowers
     * const narrativeFollower = await prisma.narrativeFollower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeFollowerUpdateManyArgs>(args: SelectSubset<T, NarrativeFollowerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NarrativeFollower.
     * @param {NarrativeFollowerUpsertArgs} args - Arguments to update or create a NarrativeFollower.
     * @example
     * // Update or create a NarrativeFollower
     * const narrativeFollower = await prisma.narrativeFollower.upsert({
     *   create: {
     *     // ... data to create a NarrativeFollower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NarrativeFollower we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeFollowerUpsertArgs>(args: SelectSubset<T, NarrativeFollowerUpsertArgs<ExtArgs>>): Prisma__NarrativeFollowerClient<$Result.GetResult<Prisma.$NarrativeFollowerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NarrativeFollowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerCountArgs} args - Arguments to filter NarrativeFollowers to count.
     * @example
     * // Count the number of NarrativeFollowers
     * const count = await prisma.narrativeFollower.count({
     *   where: {
     *     // ... the filter for the NarrativeFollowers we want to count
     *   }
     * })
    **/
    count<T extends NarrativeFollowerCountArgs>(
      args?: Subset<T, NarrativeFollowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeFollowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NarrativeFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeFollowerAggregateArgs>(args: Subset<T, NarrativeFollowerAggregateArgs>): Prisma.PrismaPromise<GetNarrativeFollowerAggregateType<T>>

    /**
     * Group by NarrativeFollower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeFollowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeFollowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeFollowerGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeFollowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeFollowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeFollowerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NarrativeFollower model
   */
  readonly fields: NarrativeFollowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NarrativeFollower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeFollowerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    narrative<T extends DetectedNarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrativeDefaultArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NarrativeFollower model
   */ 
  interface NarrativeFollowerFieldRefs {
    readonly id: FieldRef<"NarrativeFollower", 'String'>
    readonly userId: FieldRef<"NarrativeFollower", 'String'>
    readonly narrativeId: FieldRef<"NarrativeFollower", 'String'>
    readonly createdAt: FieldRef<"NarrativeFollower", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NarrativeFollower findUnique
   */
  export type NarrativeFollowerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeFollower to fetch.
     */
    where: NarrativeFollowerWhereUniqueInput
  }

  /**
   * NarrativeFollower findUniqueOrThrow
   */
  export type NarrativeFollowerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeFollower to fetch.
     */
    where: NarrativeFollowerWhereUniqueInput
  }

  /**
   * NarrativeFollower findFirst
   */
  export type NarrativeFollowerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeFollower to fetch.
     */
    where?: NarrativeFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeFollowers to fetch.
     */
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeFollowers.
     */
    cursor?: NarrativeFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeFollowers.
     */
    distinct?: NarrativeFollowerScalarFieldEnum | NarrativeFollowerScalarFieldEnum[]
  }

  /**
   * NarrativeFollower findFirstOrThrow
   */
  export type NarrativeFollowerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeFollower to fetch.
     */
    where?: NarrativeFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeFollowers to fetch.
     */
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeFollowers.
     */
    cursor?: NarrativeFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeFollowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeFollowers.
     */
    distinct?: NarrativeFollowerScalarFieldEnum | NarrativeFollowerScalarFieldEnum[]
  }

  /**
   * NarrativeFollower findMany
   */
  export type NarrativeFollowerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeFollowers to fetch.
     */
    where?: NarrativeFollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeFollowers to fetch.
     */
    orderBy?: NarrativeFollowerOrderByWithRelationInput | NarrativeFollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NarrativeFollowers.
     */
    cursor?: NarrativeFollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeFollowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeFollowers.
     */
    skip?: number
    distinct?: NarrativeFollowerScalarFieldEnum | NarrativeFollowerScalarFieldEnum[]
  }

  /**
   * NarrativeFollower create
   */
  export type NarrativeFollowerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * The data needed to create a NarrativeFollower.
     */
    data: XOR<NarrativeFollowerCreateInput, NarrativeFollowerUncheckedCreateInput>
  }

  /**
   * NarrativeFollower createMany
   */
  export type NarrativeFollowerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NarrativeFollowers.
     */
    data: NarrativeFollowerCreateManyInput | NarrativeFollowerCreateManyInput[]
  }

  /**
   * NarrativeFollower createManyAndReturn
   */
  export type NarrativeFollowerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NarrativeFollowers.
     */
    data: NarrativeFollowerCreateManyInput | NarrativeFollowerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NarrativeFollower update
   */
  export type NarrativeFollowerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * The data needed to update a NarrativeFollower.
     */
    data: XOR<NarrativeFollowerUpdateInput, NarrativeFollowerUncheckedUpdateInput>
    /**
     * Choose, which NarrativeFollower to update.
     */
    where: NarrativeFollowerWhereUniqueInput
  }

  /**
   * NarrativeFollower updateMany
   */
  export type NarrativeFollowerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NarrativeFollowers.
     */
    data: XOR<NarrativeFollowerUpdateManyMutationInput, NarrativeFollowerUncheckedUpdateManyInput>
    /**
     * Filter which NarrativeFollowers to update
     */
    where?: NarrativeFollowerWhereInput
  }

  /**
   * NarrativeFollower upsert
   */
  export type NarrativeFollowerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * The filter to search for the NarrativeFollower to update in case it exists.
     */
    where: NarrativeFollowerWhereUniqueInput
    /**
     * In case the NarrativeFollower found by the `where` argument doesn't exist, create a new NarrativeFollower with this data.
     */
    create: XOR<NarrativeFollowerCreateInput, NarrativeFollowerUncheckedCreateInput>
    /**
     * In case the NarrativeFollower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeFollowerUpdateInput, NarrativeFollowerUncheckedUpdateInput>
  }

  /**
   * NarrativeFollower delete
   */
  export type NarrativeFollowerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
    /**
     * Filter which NarrativeFollower to delete.
     */
    where: NarrativeFollowerWhereUniqueInput
  }

  /**
   * NarrativeFollower deleteMany
   */
  export type NarrativeFollowerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeFollowers to delete
     */
    where?: NarrativeFollowerWhereInput
  }

  /**
   * NarrativeFollower without action
   */
  export type NarrativeFollowerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeFollower
     */
    select?: NarrativeFollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeFollowerInclude<ExtArgs> | null
  }


  /**
   * Model NarrativeMetric
   */

  export type AggregateNarrativeMetric = {
    _count: NarrativeMetricCountAggregateOutputType | null
    _avg: NarrativeMetricAvgAggregateOutputType | null
    _sum: NarrativeMetricSumAggregateOutputType | null
    _min: NarrativeMetricMinAggregateOutputType | null
    _max: NarrativeMetricMaxAggregateOutputType | null
  }

  export type NarrativeMetricAvgAggregateOutputType = {
    mentionCount: number | null
    velocity: number | null
  }

  export type NarrativeMetricSumAggregateOutputType = {
    mentionCount: number | null
    velocity: number | null
  }

  export type NarrativeMetricMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    period: string | null
    mentionCount: number | null
    velocity: number | null
    calculatedAt: Date | null
  }

  export type NarrativeMetricMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    period: string | null
    mentionCount: number | null
    velocity: number | null
    calculatedAt: Date | null
  }

  export type NarrativeMetricCountAggregateOutputType = {
    id: number
    narrativeId: number
    period: number
    mentionCount: number
    velocity: number
    calculatedAt: number
    _all: number
  }


  export type NarrativeMetricAvgAggregateInputType = {
    mentionCount?: true
    velocity?: true
  }

  export type NarrativeMetricSumAggregateInputType = {
    mentionCount?: true
    velocity?: true
  }

  export type NarrativeMetricMinAggregateInputType = {
    id?: true
    narrativeId?: true
    period?: true
    mentionCount?: true
    velocity?: true
    calculatedAt?: true
  }

  export type NarrativeMetricMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    period?: true
    mentionCount?: true
    velocity?: true
    calculatedAt?: true
  }

  export type NarrativeMetricCountAggregateInputType = {
    id?: true
    narrativeId?: true
    period?: true
    mentionCount?: true
    velocity?: true
    calculatedAt?: true
    _all?: true
  }

  export type NarrativeMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeMetric to aggregate.
     */
    where?: NarrativeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeMetrics to fetch.
     */
    orderBy?: NarrativeMetricOrderByWithRelationInput | NarrativeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NarrativeMetrics
    **/
    _count?: true | NarrativeMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NarrativeMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NarrativeMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeMetricMaxAggregateInputType
  }

  export type GetNarrativeMetricAggregateType<T extends NarrativeMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrativeMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrativeMetric[P]>
      : GetScalarType<T[P], AggregateNarrativeMetric[P]>
  }




  export type NarrativeMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeMetricWhereInput
    orderBy?: NarrativeMetricOrderByWithAggregationInput | NarrativeMetricOrderByWithAggregationInput[]
    by: NarrativeMetricScalarFieldEnum[] | NarrativeMetricScalarFieldEnum
    having?: NarrativeMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeMetricCountAggregateInputType | true
    _avg?: NarrativeMetricAvgAggregateInputType
    _sum?: NarrativeMetricSumAggregateInputType
    _min?: NarrativeMetricMinAggregateInputType
    _max?: NarrativeMetricMaxAggregateInputType
  }

  export type NarrativeMetricGroupByOutputType = {
    id: string
    narrativeId: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt: Date
    _count: NarrativeMetricCountAggregateOutputType | null
    _avg: NarrativeMetricAvgAggregateOutputType | null
    _sum: NarrativeMetricSumAggregateOutputType | null
    _min: NarrativeMetricMinAggregateOutputType | null
    _max: NarrativeMetricMaxAggregateOutputType | null
  }

  type GetNarrativeMetricGroupByPayload<T extends NarrativeMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeMetricGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeMetricGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    period?: boolean
    mentionCount?: boolean
    velocity?: boolean
    calculatedAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeMetric"]>

  export type NarrativeMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    period?: boolean
    mentionCount?: boolean
    velocity?: boolean
    calculatedAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeMetric"]>

  export type NarrativeMetricSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    period?: boolean
    mentionCount?: boolean
    velocity?: boolean
    calculatedAt?: boolean
  }

  export type NarrativeMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }
  export type NarrativeMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }

  export type $NarrativeMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NarrativeMetric"
    objects: {
      narrative: Prisma.$DetectedNarrativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      period: string
      mentionCount: number
      velocity: number
      calculatedAt: Date
    }, ExtArgs["result"]["narrativeMetric"]>
    composites: {}
  }

  type NarrativeMetricGetPayload<S extends boolean | null | undefined | NarrativeMetricDefaultArgs> = $Result.GetResult<Prisma.$NarrativeMetricPayload, S>

  type NarrativeMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeMetricCountAggregateInputType | true
    }

  export interface NarrativeMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NarrativeMetric'], meta: { name: 'NarrativeMetric' } }
    /**
     * Find zero or one NarrativeMetric that matches the filter.
     * @param {NarrativeMetricFindUniqueArgs} args - Arguments to find a NarrativeMetric
     * @example
     * // Get one NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeMetricFindUniqueArgs>(args: SelectSubset<T, NarrativeMetricFindUniqueArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NarrativeMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeMetricFindUniqueOrThrowArgs} args - Arguments to find a NarrativeMetric
     * @example
     * // Get one NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NarrativeMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricFindFirstArgs} args - Arguments to find a NarrativeMetric
     * @example
     * // Get one NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeMetricFindFirstArgs>(args?: SelectSubset<T, NarrativeMetricFindFirstArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NarrativeMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricFindFirstOrThrowArgs} args - Arguments to find a NarrativeMetric
     * @example
     * // Get one NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NarrativeMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NarrativeMetrics
     * const narrativeMetrics = await prisma.narrativeMetric.findMany()
     * 
     * // Get first 10 NarrativeMetrics
     * const narrativeMetrics = await prisma.narrativeMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeMetricWithIdOnly = await prisma.narrativeMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeMetricFindManyArgs>(args?: SelectSubset<T, NarrativeMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NarrativeMetric.
     * @param {NarrativeMetricCreateArgs} args - Arguments to create a NarrativeMetric.
     * @example
     * // Create one NarrativeMetric
     * const NarrativeMetric = await prisma.narrativeMetric.create({
     *   data: {
     *     // ... data to create a NarrativeMetric
     *   }
     * })
     * 
     */
    create<T extends NarrativeMetricCreateArgs>(args: SelectSubset<T, NarrativeMetricCreateArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NarrativeMetrics.
     * @param {NarrativeMetricCreateManyArgs} args - Arguments to create many NarrativeMetrics.
     * @example
     * // Create many NarrativeMetrics
     * const narrativeMetric = await prisma.narrativeMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeMetricCreateManyArgs>(args?: SelectSubset<T, NarrativeMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NarrativeMetrics and returns the data saved in the database.
     * @param {NarrativeMetricCreateManyAndReturnArgs} args - Arguments to create many NarrativeMetrics.
     * @example
     * // Create many NarrativeMetrics
     * const narrativeMetric = await prisma.narrativeMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NarrativeMetrics and only return the `id`
     * const narrativeMetricWithIdOnly = await prisma.narrativeMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NarrativeMetric.
     * @param {NarrativeMetricDeleteArgs} args - Arguments to delete one NarrativeMetric.
     * @example
     * // Delete one NarrativeMetric
     * const NarrativeMetric = await prisma.narrativeMetric.delete({
     *   where: {
     *     // ... filter to delete one NarrativeMetric
     *   }
     * })
     * 
     */
    delete<T extends NarrativeMetricDeleteArgs>(args: SelectSubset<T, NarrativeMetricDeleteArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NarrativeMetric.
     * @param {NarrativeMetricUpdateArgs} args - Arguments to update one NarrativeMetric.
     * @example
     * // Update one NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeMetricUpdateArgs>(args: SelectSubset<T, NarrativeMetricUpdateArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NarrativeMetrics.
     * @param {NarrativeMetricDeleteManyArgs} args - Arguments to filter NarrativeMetrics to delete.
     * @example
     * // Delete a few NarrativeMetrics
     * const { count } = await prisma.narrativeMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeMetricDeleteManyArgs>(args?: SelectSubset<T, NarrativeMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NarrativeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NarrativeMetrics
     * const narrativeMetric = await prisma.narrativeMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeMetricUpdateManyArgs>(args: SelectSubset<T, NarrativeMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NarrativeMetric.
     * @param {NarrativeMetricUpsertArgs} args - Arguments to update or create a NarrativeMetric.
     * @example
     * // Update or create a NarrativeMetric
     * const narrativeMetric = await prisma.narrativeMetric.upsert({
     *   create: {
     *     // ... data to create a NarrativeMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NarrativeMetric we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeMetricUpsertArgs>(args: SelectSubset<T, NarrativeMetricUpsertArgs<ExtArgs>>): Prisma__NarrativeMetricClient<$Result.GetResult<Prisma.$NarrativeMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NarrativeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricCountArgs} args - Arguments to filter NarrativeMetrics to count.
     * @example
     * // Count the number of NarrativeMetrics
     * const count = await prisma.narrativeMetric.count({
     *   where: {
     *     // ... the filter for the NarrativeMetrics we want to count
     *   }
     * })
    **/
    count<T extends NarrativeMetricCountArgs>(
      args?: Subset<T, NarrativeMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NarrativeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeMetricAggregateArgs>(args: Subset<T, NarrativeMetricAggregateArgs>): Prisma.PrismaPromise<GetNarrativeMetricAggregateType<T>>

    /**
     * Group by NarrativeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeMetricGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NarrativeMetric model
   */
  readonly fields: NarrativeMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NarrativeMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends DetectedNarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrativeDefaultArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NarrativeMetric model
   */ 
  interface NarrativeMetricFieldRefs {
    readonly id: FieldRef<"NarrativeMetric", 'String'>
    readonly narrativeId: FieldRef<"NarrativeMetric", 'String'>
    readonly period: FieldRef<"NarrativeMetric", 'String'>
    readonly mentionCount: FieldRef<"NarrativeMetric", 'Int'>
    readonly velocity: FieldRef<"NarrativeMetric", 'Float'>
    readonly calculatedAt: FieldRef<"NarrativeMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NarrativeMetric findUnique
   */
  export type NarrativeMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeMetric to fetch.
     */
    where: NarrativeMetricWhereUniqueInput
  }

  /**
   * NarrativeMetric findUniqueOrThrow
   */
  export type NarrativeMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeMetric to fetch.
     */
    where: NarrativeMetricWhereUniqueInput
  }

  /**
   * NarrativeMetric findFirst
   */
  export type NarrativeMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeMetric to fetch.
     */
    where?: NarrativeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeMetrics to fetch.
     */
    orderBy?: NarrativeMetricOrderByWithRelationInput | NarrativeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeMetrics.
     */
    cursor?: NarrativeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeMetrics.
     */
    distinct?: NarrativeMetricScalarFieldEnum | NarrativeMetricScalarFieldEnum[]
  }

  /**
   * NarrativeMetric findFirstOrThrow
   */
  export type NarrativeMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeMetric to fetch.
     */
    where?: NarrativeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeMetrics to fetch.
     */
    orderBy?: NarrativeMetricOrderByWithRelationInput | NarrativeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeMetrics.
     */
    cursor?: NarrativeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeMetrics.
     */
    distinct?: NarrativeMetricScalarFieldEnum | NarrativeMetricScalarFieldEnum[]
  }

  /**
   * NarrativeMetric findMany
   */
  export type NarrativeMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeMetrics to fetch.
     */
    where?: NarrativeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeMetrics to fetch.
     */
    orderBy?: NarrativeMetricOrderByWithRelationInput | NarrativeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NarrativeMetrics.
     */
    cursor?: NarrativeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeMetrics.
     */
    skip?: number
    distinct?: NarrativeMetricScalarFieldEnum | NarrativeMetricScalarFieldEnum[]
  }

  /**
   * NarrativeMetric create
   */
  export type NarrativeMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a NarrativeMetric.
     */
    data: XOR<NarrativeMetricCreateInput, NarrativeMetricUncheckedCreateInput>
  }

  /**
   * NarrativeMetric createMany
   */
  export type NarrativeMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NarrativeMetrics.
     */
    data: NarrativeMetricCreateManyInput | NarrativeMetricCreateManyInput[]
  }

  /**
   * NarrativeMetric createManyAndReturn
   */
  export type NarrativeMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NarrativeMetrics.
     */
    data: NarrativeMetricCreateManyInput | NarrativeMetricCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NarrativeMetric update
   */
  export type NarrativeMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a NarrativeMetric.
     */
    data: XOR<NarrativeMetricUpdateInput, NarrativeMetricUncheckedUpdateInput>
    /**
     * Choose, which NarrativeMetric to update.
     */
    where: NarrativeMetricWhereUniqueInput
  }

  /**
   * NarrativeMetric updateMany
   */
  export type NarrativeMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NarrativeMetrics.
     */
    data: XOR<NarrativeMetricUpdateManyMutationInput, NarrativeMetricUncheckedUpdateManyInput>
    /**
     * Filter which NarrativeMetrics to update
     */
    where?: NarrativeMetricWhereInput
  }

  /**
   * NarrativeMetric upsert
   */
  export type NarrativeMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the NarrativeMetric to update in case it exists.
     */
    where: NarrativeMetricWhereUniqueInput
    /**
     * In case the NarrativeMetric found by the `where` argument doesn't exist, create a new NarrativeMetric with this data.
     */
    create: XOR<NarrativeMetricCreateInput, NarrativeMetricUncheckedCreateInput>
    /**
     * In case the NarrativeMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeMetricUpdateInput, NarrativeMetricUncheckedUpdateInput>
  }

  /**
   * NarrativeMetric delete
   */
  export type NarrativeMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
    /**
     * Filter which NarrativeMetric to delete.
     */
    where: NarrativeMetricWhereUniqueInput
  }

  /**
   * NarrativeMetric deleteMany
   */
  export type NarrativeMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeMetrics to delete
     */
    where?: NarrativeMetricWhereInput
  }

  /**
   * NarrativeMetric without action
   */
  export type NarrativeMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeMetric
     */
    select?: NarrativeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeMetricInclude<ExtArgs> | null
  }


  /**
   * Model DetectedNarrativeArticle
   */

  export type AggregateDetectedNarrativeArticle = {
    _count: DetectedNarrativeArticleCountAggregateOutputType | null
    _min: DetectedNarrativeArticleMinAggregateOutputType | null
    _max: DetectedNarrativeArticleMaxAggregateOutputType | null
  }

  export type DetectedNarrativeArticleMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    articleId: string | null
    createdAt: Date | null
  }

  export type DetectedNarrativeArticleMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    articleId: string | null
    createdAt: Date | null
  }

  export type DetectedNarrativeArticleCountAggregateOutputType = {
    id: number
    narrativeId: number
    articleId: number
    createdAt: number
    _all: number
  }


  export type DetectedNarrativeArticleMinAggregateInputType = {
    id?: true
    narrativeId?: true
    articleId?: true
    createdAt?: true
  }

  export type DetectedNarrativeArticleMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    articleId?: true
    createdAt?: true
  }

  export type DetectedNarrativeArticleCountAggregateInputType = {
    id?: true
    narrativeId?: true
    articleId?: true
    createdAt?: true
    _all?: true
  }

  export type DetectedNarrativeArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedNarrativeArticle to aggregate.
     */
    where?: DetectedNarrativeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarrativeArticles to fetch.
     */
    orderBy?: DetectedNarrativeArticleOrderByWithRelationInput | DetectedNarrativeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectedNarrativeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarrativeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarrativeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetectedNarrativeArticles
    **/
    _count?: true | DetectedNarrativeArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectedNarrativeArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectedNarrativeArticleMaxAggregateInputType
  }

  export type GetDetectedNarrativeArticleAggregateType<T extends DetectedNarrativeArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateDetectedNarrativeArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetectedNarrativeArticle[P]>
      : GetScalarType<T[P], AggregateDetectedNarrativeArticle[P]>
  }




  export type DetectedNarrativeArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetectedNarrativeArticleWhereInput
    orderBy?: DetectedNarrativeArticleOrderByWithAggregationInput | DetectedNarrativeArticleOrderByWithAggregationInput[]
    by: DetectedNarrativeArticleScalarFieldEnum[] | DetectedNarrativeArticleScalarFieldEnum
    having?: DetectedNarrativeArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectedNarrativeArticleCountAggregateInputType | true
    _min?: DetectedNarrativeArticleMinAggregateInputType
    _max?: DetectedNarrativeArticleMaxAggregateInputType
  }

  export type DetectedNarrativeArticleGroupByOutputType = {
    id: string
    narrativeId: string
    articleId: string
    createdAt: Date
    _count: DetectedNarrativeArticleCountAggregateOutputType | null
    _min: DetectedNarrativeArticleMinAggregateOutputType | null
    _max: DetectedNarrativeArticleMaxAggregateOutputType | null
  }

  type GetDetectedNarrativeArticleGroupByPayload<T extends DetectedNarrativeArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetectedNarrativeArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectedNarrativeArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectedNarrativeArticleGroupByOutputType[P]>
            : GetScalarType<T[P], DetectedNarrativeArticleGroupByOutputType[P]>
        }
      >
    >


  export type DetectedNarrativeArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    articleId?: boolean
    createdAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detectedNarrativeArticle"]>

  export type DetectedNarrativeArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    articleId?: boolean
    createdAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detectedNarrativeArticle"]>

  export type DetectedNarrativeArticleSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    articleId?: boolean
    createdAt?: boolean
  }

  export type DetectedNarrativeArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }
  export type DetectedNarrativeArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
  }

  export type $DetectedNarrativeArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetectedNarrativeArticle"
    objects: {
      narrative: Prisma.$DetectedNarrativePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      articleId: string
      createdAt: Date
    }, ExtArgs["result"]["detectedNarrativeArticle"]>
    composites: {}
  }

  type DetectedNarrativeArticleGetPayload<S extends boolean | null | undefined | DetectedNarrativeArticleDefaultArgs> = $Result.GetResult<Prisma.$DetectedNarrativeArticlePayload, S>

  type DetectedNarrativeArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetectedNarrativeArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetectedNarrativeArticleCountAggregateInputType | true
    }

  export interface DetectedNarrativeArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetectedNarrativeArticle'], meta: { name: 'DetectedNarrativeArticle' } }
    /**
     * Find zero or one DetectedNarrativeArticle that matches the filter.
     * @param {DetectedNarrativeArticleFindUniqueArgs} args - Arguments to find a DetectedNarrativeArticle
     * @example
     * // Get one DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetectedNarrativeArticleFindUniqueArgs>(args: SelectSubset<T, DetectedNarrativeArticleFindUniqueArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DetectedNarrativeArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DetectedNarrativeArticleFindUniqueOrThrowArgs} args - Arguments to find a DetectedNarrativeArticle
     * @example
     * // Get one DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetectedNarrativeArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, DetectedNarrativeArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DetectedNarrativeArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleFindFirstArgs} args - Arguments to find a DetectedNarrativeArticle
     * @example
     * // Get one DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetectedNarrativeArticleFindFirstArgs>(args?: SelectSubset<T, DetectedNarrativeArticleFindFirstArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DetectedNarrativeArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleFindFirstOrThrowArgs} args - Arguments to find a DetectedNarrativeArticle
     * @example
     * // Get one DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetectedNarrativeArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, DetectedNarrativeArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DetectedNarrativeArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetectedNarrativeArticles
     * const detectedNarrativeArticles = await prisma.detectedNarrativeArticle.findMany()
     * 
     * // Get first 10 DetectedNarrativeArticles
     * const detectedNarrativeArticles = await prisma.detectedNarrativeArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectedNarrativeArticleWithIdOnly = await prisma.detectedNarrativeArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetectedNarrativeArticleFindManyArgs>(args?: SelectSubset<T, DetectedNarrativeArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DetectedNarrativeArticle.
     * @param {DetectedNarrativeArticleCreateArgs} args - Arguments to create a DetectedNarrativeArticle.
     * @example
     * // Create one DetectedNarrativeArticle
     * const DetectedNarrativeArticle = await prisma.detectedNarrativeArticle.create({
     *   data: {
     *     // ... data to create a DetectedNarrativeArticle
     *   }
     * })
     * 
     */
    create<T extends DetectedNarrativeArticleCreateArgs>(args: SelectSubset<T, DetectedNarrativeArticleCreateArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DetectedNarrativeArticles.
     * @param {DetectedNarrativeArticleCreateManyArgs} args - Arguments to create many DetectedNarrativeArticles.
     * @example
     * // Create many DetectedNarrativeArticles
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetectedNarrativeArticleCreateManyArgs>(args?: SelectSubset<T, DetectedNarrativeArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetectedNarrativeArticles and returns the data saved in the database.
     * @param {DetectedNarrativeArticleCreateManyAndReturnArgs} args - Arguments to create many DetectedNarrativeArticles.
     * @example
     * // Create many DetectedNarrativeArticles
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetectedNarrativeArticles and only return the `id`
     * const detectedNarrativeArticleWithIdOnly = await prisma.detectedNarrativeArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetectedNarrativeArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, DetectedNarrativeArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DetectedNarrativeArticle.
     * @param {DetectedNarrativeArticleDeleteArgs} args - Arguments to delete one DetectedNarrativeArticle.
     * @example
     * // Delete one DetectedNarrativeArticle
     * const DetectedNarrativeArticle = await prisma.detectedNarrativeArticle.delete({
     *   where: {
     *     // ... filter to delete one DetectedNarrativeArticle
     *   }
     * })
     * 
     */
    delete<T extends DetectedNarrativeArticleDeleteArgs>(args: SelectSubset<T, DetectedNarrativeArticleDeleteArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DetectedNarrativeArticle.
     * @param {DetectedNarrativeArticleUpdateArgs} args - Arguments to update one DetectedNarrativeArticle.
     * @example
     * // Update one DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetectedNarrativeArticleUpdateArgs>(args: SelectSubset<T, DetectedNarrativeArticleUpdateArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DetectedNarrativeArticles.
     * @param {DetectedNarrativeArticleDeleteManyArgs} args - Arguments to filter DetectedNarrativeArticles to delete.
     * @example
     * // Delete a few DetectedNarrativeArticles
     * const { count } = await prisma.detectedNarrativeArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetectedNarrativeArticleDeleteManyArgs>(args?: SelectSubset<T, DetectedNarrativeArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetectedNarrativeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetectedNarrativeArticles
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetectedNarrativeArticleUpdateManyArgs>(args: SelectSubset<T, DetectedNarrativeArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetectedNarrativeArticle.
     * @param {DetectedNarrativeArticleUpsertArgs} args - Arguments to update or create a DetectedNarrativeArticle.
     * @example
     * // Update or create a DetectedNarrativeArticle
     * const detectedNarrativeArticle = await prisma.detectedNarrativeArticle.upsert({
     *   create: {
     *     // ... data to create a DetectedNarrativeArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetectedNarrativeArticle we want to update
     *   }
     * })
     */
    upsert<T extends DetectedNarrativeArticleUpsertArgs>(args: SelectSubset<T, DetectedNarrativeArticleUpsertArgs<ExtArgs>>): Prisma__DetectedNarrativeArticleClient<$Result.GetResult<Prisma.$DetectedNarrativeArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DetectedNarrativeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleCountArgs} args - Arguments to filter DetectedNarrativeArticles to count.
     * @example
     * // Count the number of DetectedNarrativeArticles
     * const count = await prisma.detectedNarrativeArticle.count({
     *   where: {
     *     // ... the filter for the DetectedNarrativeArticles we want to count
     *   }
     * })
    **/
    count<T extends DetectedNarrativeArticleCountArgs>(
      args?: Subset<T, DetectedNarrativeArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectedNarrativeArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetectedNarrativeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectedNarrativeArticleAggregateArgs>(args: Subset<T, DetectedNarrativeArticleAggregateArgs>): Prisma.PrismaPromise<GetDetectedNarrativeArticleAggregateType<T>>

    /**
     * Group by DetectedNarrativeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedNarrativeArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectedNarrativeArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectedNarrativeArticleGroupByArgs['orderBy'] }
        : { orderBy?: DetectedNarrativeArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectedNarrativeArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectedNarrativeArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetectedNarrativeArticle model
   */
  readonly fields: DetectedNarrativeArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetectedNarrativeArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetectedNarrativeArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends DetectedNarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrativeDefaultArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetectedNarrativeArticle model
   */ 
  interface DetectedNarrativeArticleFieldRefs {
    readonly id: FieldRef<"DetectedNarrativeArticle", 'String'>
    readonly narrativeId: FieldRef<"DetectedNarrativeArticle", 'String'>
    readonly articleId: FieldRef<"DetectedNarrativeArticle", 'String'>
    readonly createdAt: FieldRef<"DetectedNarrativeArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetectedNarrativeArticle findUnique
   */
  export type DetectedNarrativeArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrativeArticle to fetch.
     */
    where: DetectedNarrativeArticleWhereUniqueInput
  }

  /**
   * DetectedNarrativeArticle findUniqueOrThrow
   */
  export type DetectedNarrativeArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrativeArticle to fetch.
     */
    where: DetectedNarrativeArticleWhereUniqueInput
  }

  /**
   * DetectedNarrativeArticle findFirst
   */
  export type DetectedNarrativeArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrativeArticle to fetch.
     */
    where?: DetectedNarrativeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarrativeArticles to fetch.
     */
    orderBy?: DetectedNarrativeArticleOrderByWithRelationInput | DetectedNarrativeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedNarrativeArticles.
     */
    cursor?: DetectedNarrativeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarrativeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarrativeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedNarrativeArticles.
     */
    distinct?: DetectedNarrativeArticleScalarFieldEnum | DetectedNarrativeArticleScalarFieldEnum[]
  }

  /**
   * DetectedNarrativeArticle findFirstOrThrow
   */
  export type DetectedNarrativeArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrativeArticle to fetch.
     */
    where?: DetectedNarrativeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarrativeArticles to fetch.
     */
    orderBy?: DetectedNarrativeArticleOrderByWithRelationInput | DetectedNarrativeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedNarrativeArticles.
     */
    cursor?: DetectedNarrativeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarrativeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarrativeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedNarrativeArticles.
     */
    distinct?: DetectedNarrativeArticleScalarFieldEnum | DetectedNarrativeArticleScalarFieldEnum[]
  }

  /**
   * DetectedNarrativeArticle findMany
   */
  export type DetectedNarrativeArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter, which DetectedNarrativeArticles to fetch.
     */
    where?: DetectedNarrativeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedNarrativeArticles to fetch.
     */
    orderBy?: DetectedNarrativeArticleOrderByWithRelationInput | DetectedNarrativeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetectedNarrativeArticles.
     */
    cursor?: DetectedNarrativeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedNarrativeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedNarrativeArticles.
     */
    skip?: number
    distinct?: DetectedNarrativeArticleScalarFieldEnum | DetectedNarrativeArticleScalarFieldEnum[]
  }

  /**
   * DetectedNarrativeArticle create
   */
  export type DetectedNarrativeArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a DetectedNarrativeArticle.
     */
    data: XOR<DetectedNarrativeArticleCreateInput, DetectedNarrativeArticleUncheckedCreateInput>
  }

  /**
   * DetectedNarrativeArticle createMany
   */
  export type DetectedNarrativeArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetectedNarrativeArticles.
     */
    data: DetectedNarrativeArticleCreateManyInput | DetectedNarrativeArticleCreateManyInput[]
  }

  /**
   * DetectedNarrativeArticle createManyAndReturn
   */
  export type DetectedNarrativeArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DetectedNarrativeArticles.
     */
    data: DetectedNarrativeArticleCreateManyInput | DetectedNarrativeArticleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetectedNarrativeArticle update
   */
  export type DetectedNarrativeArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a DetectedNarrativeArticle.
     */
    data: XOR<DetectedNarrativeArticleUpdateInput, DetectedNarrativeArticleUncheckedUpdateInput>
    /**
     * Choose, which DetectedNarrativeArticle to update.
     */
    where: DetectedNarrativeArticleWhereUniqueInput
  }

  /**
   * DetectedNarrativeArticle updateMany
   */
  export type DetectedNarrativeArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetectedNarrativeArticles.
     */
    data: XOR<DetectedNarrativeArticleUpdateManyMutationInput, DetectedNarrativeArticleUncheckedUpdateManyInput>
    /**
     * Filter which DetectedNarrativeArticles to update
     */
    where?: DetectedNarrativeArticleWhereInput
  }

  /**
   * DetectedNarrativeArticle upsert
   */
  export type DetectedNarrativeArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the DetectedNarrativeArticle to update in case it exists.
     */
    where: DetectedNarrativeArticleWhereUniqueInput
    /**
     * In case the DetectedNarrativeArticle found by the `where` argument doesn't exist, create a new DetectedNarrativeArticle with this data.
     */
    create: XOR<DetectedNarrativeArticleCreateInput, DetectedNarrativeArticleUncheckedCreateInput>
    /**
     * In case the DetectedNarrativeArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectedNarrativeArticleUpdateInput, DetectedNarrativeArticleUncheckedUpdateInput>
  }

  /**
   * DetectedNarrativeArticle delete
   */
  export type DetectedNarrativeArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
    /**
     * Filter which DetectedNarrativeArticle to delete.
     */
    where: DetectedNarrativeArticleWhereUniqueInput
  }

  /**
   * DetectedNarrativeArticle deleteMany
   */
  export type DetectedNarrativeArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetectedNarrativeArticles to delete
     */
    where?: DetectedNarrativeArticleWhereInput
  }

  /**
   * DetectedNarrativeArticle without action
   */
  export type DetectedNarrativeArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetectedNarrativeArticle
     */
    select?: DetectedNarrativeArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetectedNarrativeArticleInclude<ExtArgs> | null
  }


  /**
   * Model NarrativeStance
   */

  export type AggregateNarrativeStance = {
    _count: NarrativeStanceCountAggregateOutputType | null
    _min: NarrativeStanceMinAggregateOutputType | null
    _max: NarrativeStanceMaxAggregateOutputType | null
  }

  export type NarrativeStanceMinAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    userId: string | null
    stance: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NarrativeStanceMaxAggregateOutputType = {
    id: string | null
    narrativeId: string | null
    userId: string | null
    stance: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NarrativeStanceCountAggregateOutputType = {
    id: number
    narrativeId: number
    userId: number
    stance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NarrativeStanceMinAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    stance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NarrativeStanceMaxAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    stance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NarrativeStanceCountAggregateInputType = {
    id?: true
    narrativeId?: true
    userId?: true
    stance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NarrativeStanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeStance to aggregate.
     */
    where?: NarrativeStanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeStances to fetch.
     */
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NarrativeStanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeStances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeStances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NarrativeStances
    **/
    _count?: true | NarrativeStanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NarrativeStanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NarrativeStanceMaxAggregateInputType
  }

  export type GetNarrativeStanceAggregateType<T extends NarrativeStanceAggregateArgs> = {
        [P in keyof T & keyof AggregateNarrativeStance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNarrativeStance[P]>
      : GetScalarType<T[P], AggregateNarrativeStance[P]>
  }




  export type NarrativeStanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NarrativeStanceWhereInput
    orderBy?: NarrativeStanceOrderByWithAggregationInput | NarrativeStanceOrderByWithAggregationInput[]
    by: NarrativeStanceScalarFieldEnum[] | NarrativeStanceScalarFieldEnum
    having?: NarrativeStanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NarrativeStanceCountAggregateInputType | true
    _min?: NarrativeStanceMinAggregateInputType
    _max?: NarrativeStanceMaxAggregateInputType
  }

  export type NarrativeStanceGroupByOutputType = {
    id: string
    narrativeId: string
    userId: string
    stance: string
    createdAt: Date
    updatedAt: Date
    _count: NarrativeStanceCountAggregateOutputType | null
    _min: NarrativeStanceMinAggregateOutputType | null
    _max: NarrativeStanceMaxAggregateOutputType | null
  }

  type GetNarrativeStanceGroupByPayload<T extends NarrativeStanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NarrativeStanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NarrativeStanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NarrativeStanceGroupByOutputType[P]>
            : GetScalarType<T[P], NarrativeStanceGroupByOutputType[P]>
        }
      >
    >


  export type NarrativeStanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    stance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeStance"]>

  export type NarrativeStanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    stance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["narrativeStance"]>

  export type NarrativeStanceSelectScalar = {
    id?: boolean
    narrativeId?: boolean
    userId?: boolean
    stance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NarrativeStanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NarrativeStanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    narrative?: boolean | DetectedNarrativeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NarrativeStancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NarrativeStance"
    objects: {
      narrative: Prisma.$DetectedNarrativePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      narrativeId: string
      userId: string
      stance: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["narrativeStance"]>
    composites: {}
  }

  type NarrativeStanceGetPayload<S extends boolean | null | undefined | NarrativeStanceDefaultArgs> = $Result.GetResult<Prisma.$NarrativeStancePayload, S>

  type NarrativeStanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NarrativeStanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NarrativeStanceCountAggregateInputType | true
    }

  export interface NarrativeStanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NarrativeStance'], meta: { name: 'NarrativeStance' } }
    /**
     * Find zero or one NarrativeStance that matches the filter.
     * @param {NarrativeStanceFindUniqueArgs} args - Arguments to find a NarrativeStance
     * @example
     * // Get one NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NarrativeStanceFindUniqueArgs>(args: SelectSubset<T, NarrativeStanceFindUniqueArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NarrativeStance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NarrativeStanceFindUniqueOrThrowArgs} args - Arguments to find a NarrativeStance
     * @example
     * // Get one NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NarrativeStanceFindUniqueOrThrowArgs>(args: SelectSubset<T, NarrativeStanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NarrativeStance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceFindFirstArgs} args - Arguments to find a NarrativeStance
     * @example
     * // Get one NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NarrativeStanceFindFirstArgs>(args?: SelectSubset<T, NarrativeStanceFindFirstArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NarrativeStance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceFindFirstOrThrowArgs} args - Arguments to find a NarrativeStance
     * @example
     * // Get one NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NarrativeStanceFindFirstOrThrowArgs>(args?: SelectSubset<T, NarrativeStanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NarrativeStances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NarrativeStances
     * const narrativeStances = await prisma.narrativeStance.findMany()
     * 
     * // Get first 10 NarrativeStances
     * const narrativeStances = await prisma.narrativeStance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const narrativeStanceWithIdOnly = await prisma.narrativeStance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NarrativeStanceFindManyArgs>(args?: SelectSubset<T, NarrativeStanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NarrativeStance.
     * @param {NarrativeStanceCreateArgs} args - Arguments to create a NarrativeStance.
     * @example
     * // Create one NarrativeStance
     * const NarrativeStance = await prisma.narrativeStance.create({
     *   data: {
     *     // ... data to create a NarrativeStance
     *   }
     * })
     * 
     */
    create<T extends NarrativeStanceCreateArgs>(args: SelectSubset<T, NarrativeStanceCreateArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NarrativeStances.
     * @param {NarrativeStanceCreateManyArgs} args - Arguments to create many NarrativeStances.
     * @example
     * // Create many NarrativeStances
     * const narrativeStance = await prisma.narrativeStance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NarrativeStanceCreateManyArgs>(args?: SelectSubset<T, NarrativeStanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NarrativeStances and returns the data saved in the database.
     * @param {NarrativeStanceCreateManyAndReturnArgs} args - Arguments to create many NarrativeStances.
     * @example
     * // Create many NarrativeStances
     * const narrativeStance = await prisma.narrativeStance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NarrativeStances and only return the `id`
     * const narrativeStanceWithIdOnly = await prisma.narrativeStance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NarrativeStanceCreateManyAndReturnArgs>(args?: SelectSubset<T, NarrativeStanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NarrativeStance.
     * @param {NarrativeStanceDeleteArgs} args - Arguments to delete one NarrativeStance.
     * @example
     * // Delete one NarrativeStance
     * const NarrativeStance = await prisma.narrativeStance.delete({
     *   where: {
     *     // ... filter to delete one NarrativeStance
     *   }
     * })
     * 
     */
    delete<T extends NarrativeStanceDeleteArgs>(args: SelectSubset<T, NarrativeStanceDeleteArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NarrativeStance.
     * @param {NarrativeStanceUpdateArgs} args - Arguments to update one NarrativeStance.
     * @example
     * // Update one NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NarrativeStanceUpdateArgs>(args: SelectSubset<T, NarrativeStanceUpdateArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NarrativeStances.
     * @param {NarrativeStanceDeleteManyArgs} args - Arguments to filter NarrativeStances to delete.
     * @example
     * // Delete a few NarrativeStances
     * const { count } = await prisma.narrativeStance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NarrativeStanceDeleteManyArgs>(args?: SelectSubset<T, NarrativeStanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NarrativeStances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NarrativeStances
     * const narrativeStance = await prisma.narrativeStance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NarrativeStanceUpdateManyArgs>(args: SelectSubset<T, NarrativeStanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NarrativeStance.
     * @param {NarrativeStanceUpsertArgs} args - Arguments to update or create a NarrativeStance.
     * @example
     * // Update or create a NarrativeStance
     * const narrativeStance = await prisma.narrativeStance.upsert({
     *   create: {
     *     // ... data to create a NarrativeStance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NarrativeStance we want to update
     *   }
     * })
     */
    upsert<T extends NarrativeStanceUpsertArgs>(args: SelectSubset<T, NarrativeStanceUpsertArgs<ExtArgs>>): Prisma__NarrativeStanceClient<$Result.GetResult<Prisma.$NarrativeStancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NarrativeStances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceCountArgs} args - Arguments to filter NarrativeStances to count.
     * @example
     * // Count the number of NarrativeStances
     * const count = await prisma.narrativeStance.count({
     *   where: {
     *     // ... the filter for the NarrativeStances we want to count
     *   }
     * })
    **/
    count<T extends NarrativeStanceCountArgs>(
      args?: Subset<T, NarrativeStanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NarrativeStanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NarrativeStance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NarrativeStanceAggregateArgs>(args: Subset<T, NarrativeStanceAggregateArgs>): Prisma.PrismaPromise<GetNarrativeStanceAggregateType<T>>

    /**
     * Group by NarrativeStance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NarrativeStanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NarrativeStanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NarrativeStanceGroupByArgs['orderBy'] }
        : { orderBy?: NarrativeStanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NarrativeStanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNarrativeStanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NarrativeStance model
   */
  readonly fields: NarrativeStanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NarrativeStance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NarrativeStanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    narrative<T extends DetectedNarrativeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetectedNarrativeDefaultArgs<ExtArgs>>): Prisma__DetectedNarrativeClient<$Result.GetResult<Prisma.$DetectedNarrativePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NarrativeStance model
   */ 
  interface NarrativeStanceFieldRefs {
    readonly id: FieldRef<"NarrativeStance", 'String'>
    readonly narrativeId: FieldRef<"NarrativeStance", 'String'>
    readonly userId: FieldRef<"NarrativeStance", 'String'>
    readonly stance: FieldRef<"NarrativeStance", 'String'>
    readonly createdAt: FieldRef<"NarrativeStance", 'DateTime'>
    readonly updatedAt: FieldRef<"NarrativeStance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NarrativeStance findUnique
   */
  export type NarrativeStanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeStance to fetch.
     */
    where: NarrativeStanceWhereUniqueInput
  }

  /**
   * NarrativeStance findUniqueOrThrow
   */
  export type NarrativeStanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeStance to fetch.
     */
    where: NarrativeStanceWhereUniqueInput
  }

  /**
   * NarrativeStance findFirst
   */
  export type NarrativeStanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeStance to fetch.
     */
    where?: NarrativeStanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeStances to fetch.
     */
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeStances.
     */
    cursor?: NarrativeStanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeStances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeStances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeStances.
     */
    distinct?: NarrativeStanceScalarFieldEnum | NarrativeStanceScalarFieldEnum[]
  }

  /**
   * NarrativeStance findFirstOrThrow
   */
  export type NarrativeStanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeStance to fetch.
     */
    where?: NarrativeStanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeStances to fetch.
     */
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NarrativeStances.
     */
    cursor?: NarrativeStanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeStances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeStances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NarrativeStances.
     */
    distinct?: NarrativeStanceScalarFieldEnum | NarrativeStanceScalarFieldEnum[]
  }

  /**
   * NarrativeStance findMany
   */
  export type NarrativeStanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter, which NarrativeStances to fetch.
     */
    where?: NarrativeStanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NarrativeStances to fetch.
     */
    orderBy?: NarrativeStanceOrderByWithRelationInput | NarrativeStanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NarrativeStances.
     */
    cursor?: NarrativeStanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NarrativeStances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NarrativeStances.
     */
    skip?: number
    distinct?: NarrativeStanceScalarFieldEnum | NarrativeStanceScalarFieldEnum[]
  }

  /**
   * NarrativeStance create
   */
  export type NarrativeStanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * The data needed to create a NarrativeStance.
     */
    data: XOR<NarrativeStanceCreateInput, NarrativeStanceUncheckedCreateInput>
  }

  /**
   * NarrativeStance createMany
   */
  export type NarrativeStanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NarrativeStances.
     */
    data: NarrativeStanceCreateManyInput | NarrativeStanceCreateManyInput[]
  }

  /**
   * NarrativeStance createManyAndReturn
   */
  export type NarrativeStanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NarrativeStances.
     */
    data: NarrativeStanceCreateManyInput | NarrativeStanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NarrativeStance update
   */
  export type NarrativeStanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * The data needed to update a NarrativeStance.
     */
    data: XOR<NarrativeStanceUpdateInput, NarrativeStanceUncheckedUpdateInput>
    /**
     * Choose, which NarrativeStance to update.
     */
    where: NarrativeStanceWhereUniqueInput
  }

  /**
   * NarrativeStance updateMany
   */
  export type NarrativeStanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NarrativeStances.
     */
    data: XOR<NarrativeStanceUpdateManyMutationInput, NarrativeStanceUncheckedUpdateManyInput>
    /**
     * Filter which NarrativeStances to update
     */
    where?: NarrativeStanceWhereInput
  }

  /**
   * NarrativeStance upsert
   */
  export type NarrativeStanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * The filter to search for the NarrativeStance to update in case it exists.
     */
    where: NarrativeStanceWhereUniqueInput
    /**
     * In case the NarrativeStance found by the `where` argument doesn't exist, create a new NarrativeStance with this data.
     */
    create: XOR<NarrativeStanceCreateInput, NarrativeStanceUncheckedCreateInput>
    /**
     * In case the NarrativeStance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NarrativeStanceUpdateInput, NarrativeStanceUncheckedUpdateInput>
  }

  /**
   * NarrativeStance delete
   */
  export type NarrativeStanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
    /**
     * Filter which NarrativeStance to delete.
     */
    where: NarrativeStanceWhereUniqueInput
  }

  /**
   * NarrativeStance deleteMany
   */
  export type NarrativeStanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NarrativeStances to delete
     */
    where?: NarrativeStanceWhereInput
  }

  /**
   * NarrativeStance without action
   */
  export type NarrativeStanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NarrativeStance
     */
    select?: NarrativeStanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NarrativeStanceInclude<ExtArgs> | null
  }


  /**
   * Model ExternalPost
   */

  export type AggregateExternalPost = {
    _count: ExternalPostCountAggregateOutputType | null
    _min: ExternalPostMinAggregateOutputType | null
    _max: ExternalPostMaxAggregateOutputType | null
  }

  export type ExternalPostMinAggregateOutputType = {
    id: string | null
    platform: string | null
    authorHandle: string | null
    content: string | null
    engagement: string | null
    publishedAt: Date | null
    url: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalPostMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    authorHandle: string | null
    content: string | null
    engagement: string | null
    publishedAt: Date | null
    url: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalPostCountAggregateOutputType = {
    id: number
    platform: number
    authorHandle: number
    content: number
    engagement: number
    publishedAt: number
    url: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalPostMinAggregateInputType = {
    id?: true
    platform?: true
    authorHandle?: true
    content?: true
    engagement?: true
    publishedAt?: true
    url?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalPostMaxAggregateInputType = {
    id?: true
    platform?: true
    authorHandle?: true
    content?: true
    engagement?: true
    publishedAt?: true
    url?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalPostCountAggregateInputType = {
    id?: true
    platform?: true
    authorHandle?: true
    content?: true
    engagement?: true
    publishedAt?: true
    url?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalPost to aggregate.
     */
    where?: ExternalPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalPosts to fetch.
     */
    orderBy?: ExternalPostOrderByWithRelationInput | ExternalPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalPosts
    **/
    _count?: true | ExternalPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalPostMaxAggregateInputType
  }

  export type GetExternalPostAggregateType<T extends ExternalPostAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalPost[P]>
      : GetScalarType<T[P], AggregateExternalPost[P]>
  }




  export type ExternalPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalPostWhereInput
    orderBy?: ExternalPostOrderByWithAggregationInput | ExternalPostOrderByWithAggregationInput[]
    by: ExternalPostScalarFieldEnum[] | ExternalPostScalarFieldEnum
    having?: ExternalPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalPostCountAggregateInputType | true
    _min?: ExternalPostMinAggregateInputType
    _max?: ExternalPostMaxAggregateInputType
  }

  export type ExternalPostGroupByOutputType = {
    id: string
    platform: string
    authorHandle: string
    content: string
    engagement: string
    publishedAt: Date
    url: string | null
    postId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExternalPostCountAggregateOutputType | null
    _min: ExternalPostMinAggregateOutputType | null
    _max: ExternalPostMaxAggregateOutputType | null
  }

  type GetExternalPostGroupByPayload<T extends ExternalPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalPostGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalPostGroupByOutputType[P]>
        }
      >
    >


  export type ExternalPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    authorHandle?: boolean
    content?: boolean
    engagement?: boolean
    publishedAt?: boolean
    url?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["externalPost"]>

  export type ExternalPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    authorHandle?: boolean
    content?: boolean
    engagement?: boolean
    publishedAt?: boolean
    url?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["externalPost"]>

  export type ExternalPostSelectScalar = {
    id?: boolean
    platform?: boolean
    authorHandle?: boolean
    content?: boolean
    engagement?: boolean
    publishedAt?: boolean
    url?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ExternalPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      authorHandle: string
      content: string
      engagement: string
      publishedAt: Date
      url: string | null
      postId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalPost"]>
    composites: {}
  }

  type ExternalPostGetPayload<S extends boolean | null | undefined | ExternalPostDefaultArgs> = $Result.GetResult<Prisma.$ExternalPostPayload, S>

  type ExternalPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExternalPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExternalPostCountAggregateInputType | true
    }

  export interface ExternalPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalPost'], meta: { name: 'ExternalPost' } }
    /**
     * Find zero or one ExternalPost that matches the filter.
     * @param {ExternalPostFindUniqueArgs} args - Arguments to find a ExternalPost
     * @example
     * // Get one ExternalPost
     * const externalPost = await prisma.externalPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalPostFindUniqueArgs>(args: SelectSubset<T, ExternalPostFindUniqueArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExternalPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExternalPostFindUniqueOrThrowArgs} args - Arguments to find a ExternalPost
     * @example
     * // Get one ExternalPost
     * const externalPost = await prisma.externalPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExternalPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostFindFirstArgs} args - Arguments to find a ExternalPost
     * @example
     * // Get one ExternalPost
     * const externalPost = await prisma.externalPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalPostFindFirstArgs>(args?: SelectSubset<T, ExternalPostFindFirstArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExternalPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostFindFirstOrThrowArgs} args - Arguments to find a ExternalPost
     * @example
     * // Get one ExternalPost
     * const externalPost = await prisma.externalPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExternalPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalPosts
     * const externalPosts = await prisma.externalPost.findMany()
     * 
     * // Get first 10 ExternalPosts
     * const externalPosts = await prisma.externalPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalPostWithIdOnly = await prisma.externalPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalPostFindManyArgs>(args?: SelectSubset<T, ExternalPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExternalPost.
     * @param {ExternalPostCreateArgs} args - Arguments to create a ExternalPost.
     * @example
     * // Create one ExternalPost
     * const ExternalPost = await prisma.externalPost.create({
     *   data: {
     *     // ... data to create a ExternalPost
     *   }
     * })
     * 
     */
    create<T extends ExternalPostCreateArgs>(args: SelectSubset<T, ExternalPostCreateArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExternalPosts.
     * @param {ExternalPostCreateManyArgs} args - Arguments to create many ExternalPosts.
     * @example
     * // Create many ExternalPosts
     * const externalPost = await prisma.externalPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalPostCreateManyArgs>(args?: SelectSubset<T, ExternalPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalPosts and returns the data saved in the database.
     * @param {ExternalPostCreateManyAndReturnArgs} args - Arguments to create many ExternalPosts.
     * @example
     * // Create many ExternalPosts
     * const externalPost = await prisma.externalPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalPosts and only return the `id`
     * const externalPostWithIdOnly = await prisma.externalPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExternalPost.
     * @param {ExternalPostDeleteArgs} args - Arguments to delete one ExternalPost.
     * @example
     * // Delete one ExternalPost
     * const ExternalPost = await prisma.externalPost.delete({
     *   where: {
     *     // ... filter to delete one ExternalPost
     *   }
     * })
     * 
     */
    delete<T extends ExternalPostDeleteArgs>(args: SelectSubset<T, ExternalPostDeleteArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExternalPost.
     * @param {ExternalPostUpdateArgs} args - Arguments to update one ExternalPost.
     * @example
     * // Update one ExternalPost
     * const externalPost = await prisma.externalPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalPostUpdateArgs>(args: SelectSubset<T, ExternalPostUpdateArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExternalPosts.
     * @param {ExternalPostDeleteManyArgs} args - Arguments to filter ExternalPosts to delete.
     * @example
     * // Delete a few ExternalPosts
     * const { count } = await prisma.externalPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalPostDeleteManyArgs>(args?: SelectSubset<T, ExternalPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalPosts
     * const externalPost = await prisma.externalPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalPostUpdateManyArgs>(args: SelectSubset<T, ExternalPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExternalPost.
     * @param {ExternalPostUpsertArgs} args - Arguments to update or create a ExternalPost.
     * @example
     * // Update or create a ExternalPost
     * const externalPost = await prisma.externalPost.upsert({
     *   create: {
     *     // ... data to create a ExternalPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalPost we want to update
     *   }
     * })
     */
    upsert<T extends ExternalPostUpsertArgs>(args: SelectSubset<T, ExternalPostUpsertArgs<ExtArgs>>): Prisma__ExternalPostClient<$Result.GetResult<Prisma.$ExternalPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExternalPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostCountArgs} args - Arguments to filter ExternalPosts to count.
     * @example
     * // Count the number of ExternalPosts
     * const count = await prisma.externalPost.count({
     *   where: {
     *     // ... the filter for the ExternalPosts we want to count
     *   }
     * })
    **/
    count<T extends ExternalPostCountArgs>(
      args?: Subset<T, ExternalPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalPostAggregateArgs>(args: Subset<T, ExternalPostAggregateArgs>): Prisma.PrismaPromise<GetExternalPostAggregateType<T>>

    /**
     * Group by ExternalPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalPostGroupByArgs['orderBy'] }
        : { orderBy?: ExternalPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalPost model
   */
  readonly fields: ExternalPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalPost model
   */ 
  interface ExternalPostFieldRefs {
    readonly id: FieldRef<"ExternalPost", 'String'>
    readonly platform: FieldRef<"ExternalPost", 'String'>
    readonly authorHandle: FieldRef<"ExternalPost", 'String'>
    readonly content: FieldRef<"ExternalPost", 'String'>
    readonly engagement: FieldRef<"ExternalPost", 'String'>
    readonly publishedAt: FieldRef<"ExternalPost", 'DateTime'>
    readonly url: FieldRef<"ExternalPost", 'String'>
    readonly postId: FieldRef<"ExternalPost", 'String'>
    readonly createdAt: FieldRef<"ExternalPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalPost findUnique
   */
  export type ExternalPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter, which ExternalPost to fetch.
     */
    where: ExternalPostWhereUniqueInput
  }

  /**
   * ExternalPost findUniqueOrThrow
   */
  export type ExternalPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter, which ExternalPost to fetch.
     */
    where: ExternalPostWhereUniqueInput
  }

  /**
   * ExternalPost findFirst
   */
  export type ExternalPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter, which ExternalPost to fetch.
     */
    where?: ExternalPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalPosts to fetch.
     */
    orderBy?: ExternalPostOrderByWithRelationInput | ExternalPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalPosts.
     */
    cursor?: ExternalPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalPosts.
     */
    distinct?: ExternalPostScalarFieldEnum | ExternalPostScalarFieldEnum[]
  }

  /**
   * ExternalPost findFirstOrThrow
   */
  export type ExternalPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter, which ExternalPost to fetch.
     */
    where?: ExternalPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalPosts to fetch.
     */
    orderBy?: ExternalPostOrderByWithRelationInput | ExternalPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalPosts.
     */
    cursor?: ExternalPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalPosts.
     */
    distinct?: ExternalPostScalarFieldEnum | ExternalPostScalarFieldEnum[]
  }

  /**
   * ExternalPost findMany
   */
  export type ExternalPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter, which ExternalPosts to fetch.
     */
    where?: ExternalPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalPosts to fetch.
     */
    orderBy?: ExternalPostOrderByWithRelationInput | ExternalPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalPosts.
     */
    cursor?: ExternalPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalPosts.
     */
    skip?: number
    distinct?: ExternalPostScalarFieldEnum | ExternalPostScalarFieldEnum[]
  }

  /**
   * ExternalPost create
   */
  export type ExternalPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * The data needed to create a ExternalPost.
     */
    data: XOR<ExternalPostCreateInput, ExternalPostUncheckedCreateInput>
  }

  /**
   * ExternalPost createMany
   */
  export type ExternalPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalPosts.
     */
    data: ExternalPostCreateManyInput | ExternalPostCreateManyInput[]
  }

  /**
   * ExternalPost createManyAndReturn
   */
  export type ExternalPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExternalPosts.
     */
    data: ExternalPostCreateManyInput | ExternalPostCreateManyInput[]
  }

  /**
   * ExternalPost update
   */
  export type ExternalPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * The data needed to update a ExternalPost.
     */
    data: XOR<ExternalPostUpdateInput, ExternalPostUncheckedUpdateInput>
    /**
     * Choose, which ExternalPost to update.
     */
    where: ExternalPostWhereUniqueInput
  }

  /**
   * ExternalPost updateMany
   */
  export type ExternalPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalPosts.
     */
    data: XOR<ExternalPostUpdateManyMutationInput, ExternalPostUncheckedUpdateManyInput>
    /**
     * Filter which ExternalPosts to update
     */
    where?: ExternalPostWhereInput
  }

  /**
   * ExternalPost upsert
   */
  export type ExternalPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * The filter to search for the ExternalPost to update in case it exists.
     */
    where: ExternalPostWhereUniqueInput
    /**
     * In case the ExternalPost found by the `where` argument doesn't exist, create a new ExternalPost with this data.
     */
    create: XOR<ExternalPostCreateInput, ExternalPostUncheckedCreateInput>
    /**
     * In case the ExternalPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalPostUpdateInput, ExternalPostUncheckedUpdateInput>
  }

  /**
   * ExternalPost delete
   */
  export type ExternalPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
    /**
     * Filter which ExternalPost to delete.
     */
    where: ExternalPostWhereUniqueInput
  }

  /**
   * ExternalPost deleteMany
   */
  export type ExternalPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalPosts to delete
     */
    where?: ExternalPostWhereInput
  }

  /**
   * ExternalPost without action
   */
  export type ExternalPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalPost
     */
    select?: ExternalPostSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    profileMetadata: 'profileMetadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    friendId: 'friendId',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const UserMetricScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    period: 'period',
    returnPercent: 'returnPercent',
    winRate: 'winRate',
    tradesCount: 'tradesCount',
    calculatedAt: 'calculatedAt'
  };

  export type UserMetricScalarFieldEnum = (typeof UserMetricScalarFieldEnum)[keyof typeof UserMetricScalarFieldEnum]


  export const NarrativeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    triggerType: 'triggerType',
    triggerValue: 'triggerValue',
    sentiment: 'sentiment',
    mentionCount: 'mentionCount',
    velocity: 'velocity',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NarrativeScalarFieldEnum = (typeof NarrativeScalarFieldEnum)[keyof typeof NarrativeScalarFieldEnum]


  export const NarrativeAssetScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    assetSymbol: 'assetSymbol',
    impact: 'impact',
    createdAt: 'createdAt'
  };

  export type NarrativeAssetScalarFieldEnum = (typeof NarrativeAssetScalarFieldEnum)[keyof typeof NarrativeAssetScalarFieldEnum]


  export const NarrativeEventScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    eventTime: 'eventTime',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type NarrativeEventScalarFieldEnum = (typeof NarrativeEventScalarFieldEnum)[keyof typeof NarrativeEventScalarFieldEnum]


  export const SocialPostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    sentiment: 'sentiment',
    likesCount: 'likesCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialPostScalarFieldEnum = (typeof SocialPostScalarFieldEnum)[keyof typeof SocialPostScalarFieldEnum]


  export const PostTickerScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    ticker: 'ticker'
  };

  export type PostTickerScalarFieldEnum = (typeof PostTickerScalarFieldEnum)[keyof typeof PostTickerScalarFieldEnum]


  export const PostLikeScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]


  export const TrackedAccountScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    accountHandle: 'accountHandle',
    accountName: 'accountName',
    accountType: 'accountType',
    isActive: 'isActive',
    lastFetchedAt: 'lastFetchedAt',
    createdAt: 'createdAt'
  };

  export type TrackedAccountScalarFieldEnum = (typeof TrackedAccountScalarFieldEnum)[keyof typeof TrackedAccountScalarFieldEnum]


  export const IngestedPostScalarFieldEnum: {
    id: 'id',
    trackedAccountId: 'trackedAccountId',
    externalPostId: 'externalPostId',
    content: 'content',
    postedAt: 'postedAt',
    engagementLikes: 'engagementLikes',
    engagementRetweets: 'engagementRetweets',
    keywords: 'keywords',
    tickers: 'tickers',
    hashtags: 'hashtags',
    narrativeId: 'narrativeId',
    ingestedAt: 'ingestedAt'
  };

  export type IngestedPostScalarFieldEnum = (typeof IngestedPostScalarFieldEnum)[keyof typeof IngestedPostScalarFieldEnum]


  export const CommunityPulseScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    bullishPercent: 'bullishPercent',
    bearishPercent: 'bearishPercent',
    neutralPercent: 'neutralPercent',
    discussionCount: 'discussionCount',
    calculatedAt: 'calculatedAt',
    period: 'period'
  };

  export type CommunityPulseScalarFieldEnum = (typeof CommunityPulseScalarFieldEnum)[keyof typeof CommunityPulseScalarFieldEnum]


  export const NewsArticleScalarFieldEnum: {
    id: 'id',
    source: 'source',
    title: 'title',
    content: 'content',
    url: 'url',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt'
  };

  export type NewsArticleScalarFieldEnum = (typeof NewsArticleScalarFieldEnum)[keyof typeof NewsArticleScalarFieldEnum]


  export const NewsSourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsSourceScalarFieldEnum = (typeof NewsSourceScalarFieldEnum)[keyof typeof NewsSourceScalarFieldEnum]


  export const ArticleEntityScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    entity: 'entity',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ArticleEntityScalarFieldEnum = (typeof ArticleEntityScalarFieldEnum)[keyof typeof ArticleEntityScalarFieldEnum]


  export const DetectedNarrativeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    sentiment: 'sentiment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetectedNarrativeScalarFieldEnum = (typeof DetectedNarrativeScalarFieldEnum)[keyof typeof DetectedNarrativeScalarFieldEnum]


  export const MarketMessageScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    userId: 'userId',
    text: 'text',
    createdAt: 'createdAt'
  };

  export type MarketMessageScalarFieldEnum = (typeof MarketMessageScalarFieldEnum)[keyof typeof MarketMessageScalarFieldEnum]


  export const NarrativeFollowerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    narrativeId: 'narrativeId',
    createdAt: 'createdAt'
  };

  export type NarrativeFollowerScalarFieldEnum = (typeof NarrativeFollowerScalarFieldEnum)[keyof typeof NarrativeFollowerScalarFieldEnum]


  export const NarrativeMetricScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    period: 'period',
    mentionCount: 'mentionCount',
    velocity: 'velocity',
    calculatedAt: 'calculatedAt'
  };

  export type NarrativeMetricScalarFieldEnum = (typeof NarrativeMetricScalarFieldEnum)[keyof typeof NarrativeMetricScalarFieldEnum]


  export const DetectedNarrativeArticleScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    articleId: 'articleId',
    createdAt: 'createdAt'
  };

  export type DetectedNarrativeArticleScalarFieldEnum = (typeof DetectedNarrativeArticleScalarFieldEnum)[keyof typeof DetectedNarrativeArticleScalarFieldEnum]


  export const NarrativeStanceScalarFieldEnum: {
    id: 'id',
    narrativeId: 'narrativeId',
    userId: 'userId',
    stance: 'stance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NarrativeStanceScalarFieldEnum = (typeof NarrativeStanceScalarFieldEnum)[keyof typeof NarrativeStanceScalarFieldEnum]


  export const ExternalPostScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    authorHandle: 'authorHandle',
    content: 'content',
    engagement: 'engagement',
    publishedAt: 'publishedAt',
    url: 'url',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalPostScalarFieldEnum = (typeof ExternalPostScalarFieldEnum)[keyof typeof ExternalPostScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    profileMetadata?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    friendshipsAsUser?: FriendshipListRelationFilter
    friendshipsAsFriend?: FriendshipListRelationFilter
    narrativeFollowers?: NarrativeFollowerListRelationFilter
    userMetrics?: UserMetricListRelationFilter
    socialPosts?: SocialPostListRelationFilter
    postLikes?: PostLikeListRelationFilter
    marketMessages?: MarketMessageListRelationFilter
    narrativeStances?: NarrativeStanceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    profileMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    friendshipsAsUser?: FriendshipOrderByRelationAggregateInput
    friendshipsAsFriend?: FriendshipOrderByRelationAggregateInput
    narrativeFollowers?: NarrativeFollowerOrderByRelationAggregateInput
    userMetrics?: UserMetricOrderByRelationAggregateInput
    socialPosts?: SocialPostOrderByRelationAggregateInput
    postLikes?: PostLikeOrderByRelationAggregateInput
    marketMessages?: MarketMessageOrderByRelationAggregateInput
    narrativeStances?: NarrativeStanceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    profileMetadata?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    friendshipsAsUser?: FriendshipListRelationFilter
    friendshipsAsFriend?: FriendshipListRelationFilter
    narrativeFollowers?: NarrativeFollowerListRelationFilter
    userMetrics?: UserMetricListRelationFilter
    socialPosts?: SocialPostListRelationFilter
    postLikes?: PostLikeListRelationFilter
    marketMessages?: MarketMessageListRelationFilter
    narrativeStances?: NarrativeStanceListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    profileMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileMetadata?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    friend?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    friend?: UserOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: FriendshipUserIdFriendIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    friend?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_friendId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friendship"> | string
    userId?: StringWithAggregatesFilter<"Friendship"> | string
    friendId?: StringWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type UserMetricWhereInput = {
    AND?: UserMetricWhereInput | UserMetricWhereInput[]
    OR?: UserMetricWhereInput[]
    NOT?: UserMetricWhereInput | UserMetricWhereInput[]
    id?: StringFilter<"UserMetric"> | string
    userId?: StringFilter<"UserMetric"> | string
    period?: StringFilter<"UserMetric"> | string
    returnPercent?: FloatFilter<"UserMetric"> | number
    winRate?: FloatFilter<"UserMetric"> | number
    tradesCount?: IntFilter<"UserMetric"> | number
    calculatedAt?: DateTimeFilter<"UserMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserMetricOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
    calculatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_period?: UserMetricUserIdPeriodCompoundUniqueInput
    AND?: UserMetricWhereInput | UserMetricWhereInput[]
    OR?: UserMetricWhereInput[]
    NOT?: UserMetricWhereInput | UserMetricWhereInput[]
    userId?: StringFilter<"UserMetric"> | string
    period?: StringFilter<"UserMetric"> | string
    returnPercent?: FloatFilter<"UserMetric"> | number
    winRate?: FloatFilter<"UserMetric"> | number
    tradesCount?: IntFilter<"UserMetric"> | number
    calculatedAt?: DateTimeFilter<"UserMetric"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_period">

  export type UserMetricOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
    calculatedAt?: SortOrder
    _count?: UserMetricCountOrderByAggregateInput
    _avg?: UserMetricAvgOrderByAggregateInput
    _max?: UserMetricMaxOrderByAggregateInput
    _min?: UserMetricMinOrderByAggregateInput
    _sum?: UserMetricSumOrderByAggregateInput
  }

  export type UserMetricScalarWhereWithAggregatesInput = {
    AND?: UserMetricScalarWhereWithAggregatesInput | UserMetricScalarWhereWithAggregatesInput[]
    OR?: UserMetricScalarWhereWithAggregatesInput[]
    NOT?: UserMetricScalarWhereWithAggregatesInput | UserMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserMetric"> | string
    userId?: StringWithAggregatesFilter<"UserMetric"> | string
    period?: StringWithAggregatesFilter<"UserMetric"> | string
    returnPercent?: FloatWithAggregatesFilter<"UserMetric"> | number
    winRate?: FloatWithAggregatesFilter<"UserMetric"> | number
    tradesCount?: IntWithAggregatesFilter<"UserMetric"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"UserMetric"> | Date | string
  }

  export type NarrativeWhereInput = {
    AND?: NarrativeWhereInput | NarrativeWhereInput[]
    OR?: NarrativeWhereInput[]
    NOT?: NarrativeWhereInput | NarrativeWhereInput[]
    id?: StringFilter<"Narrative"> | string
    title?: StringFilter<"Narrative"> | string
    description?: StringNullableFilter<"Narrative"> | string | null
    triggerType?: StringFilter<"Narrative"> | string
    triggerValue?: StringNullableFilter<"Narrative"> | string | null
    sentiment?: StringFilter<"Narrative"> | string
    mentionCount?: IntFilter<"Narrative"> | number
    velocity?: FloatFilter<"Narrative"> | number
    status?: StringFilter<"Narrative"> | string
    createdAt?: DateTimeFilter<"Narrative"> | Date | string
    updatedAt?: DateTimeFilter<"Narrative"> | Date | string
    assets?: NarrativeAssetListRelationFilter
    events?: NarrativeEventListRelationFilter
    posts?: IngestedPostListRelationFilter
    pulse?: CommunityPulseListRelationFilter
  }

  export type NarrativeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    sentiment?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assets?: NarrativeAssetOrderByRelationAggregateInput
    events?: NarrativeEventOrderByRelationAggregateInput
    posts?: IngestedPostOrderByRelationAggregateInput
    pulse?: CommunityPulseOrderByRelationAggregateInput
  }

  export type NarrativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NarrativeWhereInput | NarrativeWhereInput[]
    OR?: NarrativeWhereInput[]
    NOT?: NarrativeWhereInput | NarrativeWhereInput[]
    title?: StringFilter<"Narrative"> | string
    description?: StringNullableFilter<"Narrative"> | string | null
    triggerType?: StringFilter<"Narrative"> | string
    triggerValue?: StringNullableFilter<"Narrative"> | string | null
    sentiment?: StringFilter<"Narrative"> | string
    mentionCount?: IntFilter<"Narrative"> | number
    velocity?: FloatFilter<"Narrative"> | number
    status?: StringFilter<"Narrative"> | string
    createdAt?: DateTimeFilter<"Narrative"> | Date | string
    updatedAt?: DateTimeFilter<"Narrative"> | Date | string
    assets?: NarrativeAssetListRelationFilter
    events?: NarrativeEventListRelationFilter
    posts?: IngestedPostListRelationFilter
    pulse?: CommunityPulseListRelationFilter
  }, "id">

  export type NarrativeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrderInput | SortOrder
    sentiment?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NarrativeCountOrderByAggregateInput
    _avg?: NarrativeAvgOrderByAggregateInput
    _max?: NarrativeMaxOrderByAggregateInput
    _min?: NarrativeMinOrderByAggregateInput
    _sum?: NarrativeSumOrderByAggregateInput
  }

  export type NarrativeScalarWhereWithAggregatesInput = {
    AND?: NarrativeScalarWhereWithAggregatesInput | NarrativeScalarWhereWithAggregatesInput[]
    OR?: NarrativeScalarWhereWithAggregatesInput[]
    NOT?: NarrativeScalarWhereWithAggregatesInput | NarrativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Narrative"> | string
    title?: StringWithAggregatesFilter<"Narrative"> | string
    description?: StringNullableWithAggregatesFilter<"Narrative"> | string | null
    triggerType?: StringWithAggregatesFilter<"Narrative"> | string
    triggerValue?: StringNullableWithAggregatesFilter<"Narrative"> | string | null
    sentiment?: StringWithAggregatesFilter<"Narrative"> | string
    mentionCount?: IntWithAggregatesFilter<"Narrative"> | number
    velocity?: FloatWithAggregatesFilter<"Narrative"> | number
    status?: StringWithAggregatesFilter<"Narrative"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Narrative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Narrative"> | Date | string
  }

  export type NarrativeAssetWhereInput = {
    AND?: NarrativeAssetWhereInput | NarrativeAssetWhereInput[]
    OR?: NarrativeAssetWhereInput[]
    NOT?: NarrativeAssetWhereInput | NarrativeAssetWhereInput[]
    id?: StringFilter<"NarrativeAsset"> | string
    narrativeId?: StringFilter<"NarrativeAsset"> | string
    assetSymbol?: StringFilter<"NarrativeAsset"> | string
    impact?: FloatNullableFilter<"NarrativeAsset"> | number | null
    createdAt?: DateTimeFilter<"NarrativeAsset"> | Date | string
    narrative?: XOR<NarrativeRelationFilter, NarrativeWhereInput>
  }

  export type NarrativeAssetOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    assetSymbol?: SortOrder
    impact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    narrative?: NarrativeOrderByWithRelationInput
  }

  export type NarrativeAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    narrativeId_assetSymbol?: NarrativeAssetNarrativeIdAssetSymbolCompoundUniqueInput
    AND?: NarrativeAssetWhereInput | NarrativeAssetWhereInput[]
    OR?: NarrativeAssetWhereInput[]
    NOT?: NarrativeAssetWhereInput | NarrativeAssetWhereInput[]
    narrativeId?: StringFilter<"NarrativeAsset"> | string
    assetSymbol?: StringFilter<"NarrativeAsset"> | string
    impact?: FloatNullableFilter<"NarrativeAsset"> | number | null
    createdAt?: DateTimeFilter<"NarrativeAsset"> | Date | string
    narrative?: XOR<NarrativeRelationFilter, NarrativeWhereInput>
  }, "id" | "narrativeId_assetSymbol">

  export type NarrativeAssetOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    assetSymbol?: SortOrder
    impact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NarrativeAssetCountOrderByAggregateInput
    _avg?: NarrativeAssetAvgOrderByAggregateInput
    _max?: NarrativeAssetMaxOrderByAggregateInput
    _min?: NarrativeAssetMinOrderByAggregateInput
    _sum?: NarrativeAssetSumOrderByAggregateInput
  }

  export type NarrativeAssetScalarWhereWithAggregatesInput = {
    AND?: NarrativeAssetScalarWhereWithAggregatesInput | NarrativeAssetScalarWhereWithAggregatesInput[]
    OR?: NarrativeAssetScalarWhereWithAggregatesInput[]
    NOT?: NarrativeAssetScalarWhereWithAggregatesInput | NarrativeAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NarrativeAsset"> | string
    narrativeId?: StringWithAggregatesFilter<"NarrativeAsset"> | string
    assetSymbol?: StringWithAggregatesFilter<"NarrativeAsset"> | string
    impact?: FloatNullableWithAggregatesFilter<"NarrativeAsset"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"NarrativeAsset"> | Date | string
  }

  export type NarrativeEventWhereInput = {
    AND?: NarrativeEventWhereInput | NarrativeEventWhereInput[]
    OR?: NarrativeEventWhereInput[]
    NOT?: NarrativeEventWhereInput | NarrativeEventWhereInput[]
    id?: StringFilter<"NarrativeEvent"> | string
    narrativeId?: StringFilter<"NarrativeEvent"> | string
    eventTime?: DateTimeFilter<"NarrativeEvent"> | Date | string
    description?: StringNullableFilter<"NarrativeEvent"> | string | null
    createdAt?: DateTimeFilter<"NarrativeEvent"> | Date | string
    narrative?: XOR<NarrativeRelationFilter, NarrativeWhereInput>
  }

  export type NarrativeEventOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    eventTime?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    narrative?: NarrativeOrderByWithRelationInput
  }

  export type NarrativeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NarrativeEventWhereInput | NarrativeEventWhereInput[]
    OR?: NarrativeEventWhereInput[]
    NOT?: NarrativeEventWhereInput | NarrativeEventWhereInput[]
    narrativeId?: StringFilter<"NarrativeEvent"> | string
    eventTime?: DateTimeFilter<"NarrativeEvent"> | Date | string
    description?: StringNullableFilter<"NarrativeEvent"> | string | null
    createdAt?: DateTimeFilter<"NarrativeEvent"> | Date | string
    narrative?: XOR<NarrativeRelationFilter, NarrativeWhereInput>
  }, "id">

  export type NarrativeEventOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    eventTime?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NarrativeEventCountOrderByAggregateInput
    _max?: NarrativeEventMaxOrderByAggregateInput
    _min?: NarrativeEventMinOrderByAggregateInput
  }

  export type NarrativeEventScalarWhereWithAggregatesInput = {
    AND?: NarrativeEventScalarWhereWithAggregatesInput | NarrativeEventScalarWhereWithAggregatesInput[]
    OR?: NarrativeEventScalarWhereWithAggregatesInput[]
    NOT?: NarrativeEventScalarWhereWithAggregatesInput | NarrativeEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NarrativeEvent"> | string
    narrativeId?: StringWithAggregatesFilter<"NarrativeEvent"> | string
    eventTime?: DateTimeWithAggregatesFilter<"NarrativeEvent"> | Date | string
    description?: StringNullableWithAggregatesFilter<"NarrativeEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NarrativeEvent"> | Date | string
  }

  export type SocialPostWhereInput = {
    AND?: SocialPostWhereInput | SocialPostWhereInput[]
    OR?: SocialPostWhereInput[]
    NOT?: SocialPostWhereInput | SocialPostWhereInput[]
    id?: StringFilter<"SocialPost"> | string
    userId?: StringFilter<"SocialPost"> | string
    content?: StringFilter<"SocialPost"> | string
    sentiment?: StringFilter<"SocialPost"> | string
    likesCount?: IntFilter<"SocialPost"> | number
    createdAt?: DateTimeFilter<"SocialPost"> | Date | string
    updatedAt?: DateTimeFilter<"SocialPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tickers?: PostTickerListRelationFilter
    likes?: PostLikeListRelationFilter
  }

  export type SocialPostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    likesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tickers?: PostTickerOrderByRelationAggregateInput
    likes?: PostLikeOrderByRelationAggregateInput
  }

  export type SocialPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialPostWhereInput | SocialPostWhereInput[]
    OR?: SocialPostWhereInput[]
    NOT?: SocialPostWhereInput | SocialPostWhereInput[]
    userId?: StringFilter<"SocialPost"> | string
    content?: StringFilter<"SocialPost"> | string
    sentiment?: StringFilter<"SocialPost"> | string
    likesCount?: IntFilter<"SocialPost"> | number
    createdAt?: DateTimeFilter<"SocialPost"> | Date | string
    updatedAt?: DateTimeFilter<"SocialPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tickers?: PostTickerListRelationFilter
    likes?: PostLikeListRelationFilter
  }, "id">

  export type SocialPostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    likesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialPostCountOrderByAggregateInput
    _avg?: SocialPostAvgOrderByAggregateInput
    _max?: SocialPostMaxOrderByAggregateInput
    _min?: SocialPostMinOrderByAggregateInput
    _sum?: SocialPostSumOrderByAggregateInput
  }

  export type SocialPostScalarWhereWithAggregatesInput = {
    AND?: SocialPostScalarWhereWithAggregatesInput | SocialPostScalarWhereWithAggregatesInput[]
    OR?: SocialPostScalarWhereWithAggregatesInput[]
    NOT?: SocialPostScalarWhereWithAggregatesInput | SocialPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialPost"> | string
    userId?: StringWithAggregatesFilter<"SocialPost"> | string
    content?: StringWithAggregatesFilter<"SocialPost"> | string
    sentiment?: StringWithAggregatesFilter<"SocialPost"> | string
    likesCount?: IntWithAggregatesFilter<"SocialPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SocialPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialPost"> | Date | string
  }

  export type PostTickerWhereInput = {
    AND?: PostTickerWhereInput | PostTickerWhereInput[]
    OR?: PostTickerWhereInput[]
    NOT?: PostTickerWhereInput | PostTickerWhereInput[]
    id?: StringFilter<"PostTicker"> | string
    postId?: StringFilter<"PostTicker"> | string
    ticker?: StringFilter<"PostTicker"> | string
    post?: XOR<SocialPostRelationFilter, SocialPostWhereInput>
  }

  export type PostTickerOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    ticker?: SortOrder
    post?: SocialPostOrderByWithRelationInput
  }

  export type PostTickerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostTickerWhereInput | PostTickerWhereInput[]
    OR?: PostTickerWhereInput[]
    NOT?: PostTickerWhereInput | PostTickerWhereInput[]
    postId?: StringFilter<"PostTicker"> | string
    ticker?: StringFilter<"PostTicker"> | string
    post?: XOR<SocialPostRelationFilter, SocialPostWhereInput>
  }, "id">

  export type PostTickerOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    ticker?: SortOrder
    _count?: PostTickerCountOrderByAggregateInput
    _max?: PostTickerMaxOrderByAggregateInput
    _min?: PostTickerMinOrderByAggregateInput
  }

  export type PostTickerScalarWhereWithAggregatesInput = {
    AND?: PostTickerScalarWhereWithAggregatesInput | PostTickerScalarWhereWithAggregatesInput[]
    OR?: PostTickerScalarWhereWithAggregatesInput[]
    NOT?: PostTickerScalarWhereWithAggregatesInput | PostTickerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostTicker"> | string
    postId?: StringWithAggregatesFilter<"PostTicker"> | string
    ticker?: StringWithAggregatesFilter<"PostTicker"> | string
  }

  export type PostLikeWhereInput = {
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    id?: StringFilter<"PostLike"> | string
    postId?: StringFilter<"PostLike"> | string
    userId?: StringFilter<"PostLike"> | string
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
    post?: XOR<SocialPostRelationFilter, SocialPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostLikeOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    post?: SocialPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostLikeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: PostLikePostIdUserIdCompoundUniqueInput
    AND?: PostLikeWhereInput | PostLikeWhereInput[]
    OR?: PostLikeWhereInput[]
    NOT?: PostLikeWhereInput | PostLikeWhereInput[]
    postId?: StringFilter<"PostLike"> | string
    userId?: StringFilter<"PostLike"> | string
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
    post?: XOR<SocialPostRelationFilter, SocialPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "postId_userId">

  export type PostLikeOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PostLikeCountOrderByAggregateInput
    _max?: PostLikeMaxOrderByAggregateInput
    _min?: PostLikeMinOrderByAggregateInput
  }

  export type PostLikeScalarWhereWithAggregatesInput = {
    AND?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    OR?: PostLikeScalarWhereWithAggregatesInput[]
    NOT?: PostLikeScalarWhereWithAggregatesInput | PostLikeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostLike"> | string
    postId?: StringWithAggregatesFilter<"PostLike"> | string
    userId?: StringWithAggregatesFilter<"PostLike"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostLike"> | Date | string
  }

  export type TrackedAccountWhereInput = {
    AND?: TrackedAccountWhereInput | TrackedAccountWhereInput[]
    OR?: TrackedAccountWhereInput[]
    NOT?: TrackedAccountWhereInput | TrackedAccountWhereInput[]
    id?: StringFilter<"TrackedAccount"> | string
    platform?: StringFilter<"TrackedAccount"> | string
    accountHandle?: StringFilter<"TrackedAccount"> | string
    accountName?: StringNullableFilter<"TrackedAccount"> | string | null
    accountType?: StringNullableFilter<"TrackedAccount"> | string | null
    isActive?: BoolFilter<"TrackedAccount"> | boolean
    lastFetchedAt?: DateTimeNullableFilter<"TrackedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"TrackedAccount"> | Date | string
    posts?: IngestedPostListRelationFilter
  }

  export type TrackedAccountOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    accountHandle?: SortOrder
    accountName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    posts?: IngestedPostOrderByRelationAggregateInput
  }

  export type TrackedAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountHandle?: string
    AND?: TrackedAccountWhereInput | TrackedAccountWhereInput[]
    OR?: TrackedAccountWhereInput[]
    NOT?: TrackedAccountWhereInput | TrackedAccountWhereInput[]
    platform?: StringFilter<"TrackedAccount"> | string
    accountName?: StringNullableFilter<"TrackedAccount"> | string | null
    accountType?: StringNullableFilter<"TrackedAccount"> | string | null
    isActive?: BoolFilter<"TrackedAccount"> | boolean
    lastFetchedAt?: DateTimeNullableFilter<"TrackedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"TrackedAccount"> | Date | string
    posts?: IngestedPostListRelationFilter
  }, "id" | "accountHandle">

  export type TrackedAccountOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    accountHandle?: SortOrder
    accountName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TrackedAccountCountOrderByAggregateInput
    _max?: TrackedAccountMaxOrderByAggregateInput
    _min?: TrackedAccountMinOrderByAggregateInput
  }

  export type TrackedAccountScalarWhereWithAggregatesInput = {
    AND?: TrackedAccountScalarWhereWithAggregatesInput | TrackedAccountScalarWhereWithAggregatesInput[]
    OR?: TrackedAccountScalarWhereWithAggregatesInput[]
    NOT?: TrackedAccountScalarWhereWithAggregatesInput | TrackedAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrackedAccount"> | string
    platform?: StringWithAggregatesFilter<"TrackedAccount"> | string
    accountHandle?: StringWithAggregatesFilter<"TrackedAccount"> | string
    accountName?: StringNullableWithAggregatesFilter<"TrackedAccount"> | string | null
    accountType?: StringNullableWithAggregatesFilter<"TrackedAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"TrackedAccount"> | boolean
    lastFetchedAt?: DateTimeNullableWithAggregatesFilter<"TrackedAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrackedAccount"> | Date | string
  }

  export type IngestedPostWhereInput = {
    AND?: IngestedPostWhereInput | IngestedPostWhereInput[]
    OR?: IngestedPostWhereInput[]
    NOT?: IngestedPostWhereInput | IngestedPostWhereInput[]
    id?: StringFilter<"IngestedPost"> | string
    trackedAccountId?: StringFilter<"IngestedPost"> | string
    externalPostId?: StringFilter<"IngestedPost"> | string
    content?: StringFilter<"IngestedPost"> | string
    postedAt?: DateTimeFilter<"IngestedPost"> | Date | string
    engagementLikes?: IntFilter<"IngestedPost"> | number
    engagementRetweets?: IntFilter<"IngestedPost"> | number
    keywords?: StringFilter<"IngestedPost"> | string
    tickers?: StringFilter<"IngestedPost"> | string
    hashtags?: StringFilter<"IngestedPost"> | string
    narrativeId?: StringNullableFilter<"IngestedPost"> | string | null
    ingestedAt?: DateTimeFilter<"IngestedPost"> | Date | string
    account?: XOR<TrackedAccountRelationFilter, TrackedAccountWhereInput>
    narrative?: XOR<NarrativeNullableRelationFilter, NarrativeWhereInput> | null
  }

  export type IngestedPostOrderByWithRelationInput = {
    id?: SortOrder
    trackedAccountId?: SortOrder
    externalPostId?: SortOrder
    content?: SortOrder
    postedAt?: SortOrder
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
    keywords?: SortOrder
    tickers?: SortOrder
    hashtags?: SortOrder
    narrativeId?: SortOrderInput | SortOrder
    ingestedAt?: SortOrder
    account?: TrackedAccountOrderByWithRelationInput
    narrative?: NarrativeOrderByWithRelationInput
  }

  export type IngestedPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalPostId?: string
    AND?: IngestedPostWhereInput | IngestedPostWhereInput[]
    OR?: IngestedPostWhereInput[]
    NOT?: IngestedPostWhereInput | IngestedPostWhereInput[]
    trackedAccountId?: StringFilter<"IngestedPost"> | string
    content?: StringFilter<"IngestedPost"> | string
    postedAt?: DateTimeFilter<"IngestedPost"> | Date | string
    engagementLikes?: IntFilter<"IngestedPost"> | number
    engagementRetweets?: IntFilter<"IngestedPost"> | number
    keywords?: StringFilter<"IngestedPost"> | string
    tickers?: StringFilter<"IngestedPost"> | string
    hashtags?: StringFilter<"IngestedPost"> | string
    narrativeId?: StringNullableFilter<"IngestedPost"> | string | null
    ingestedAt?: DateTimeFilter<"IngestedPost"> | Date | string
    account?: XOR<TrackedAccountRelationFilter, TrackedAccountWhereInput>
    narrative?: XOR<NarrativeNullableRelationFilter, NarrativeWhereInput> | null
  }, "id" | "externalPostId">

  export type IngestedPostOrderByWithAggregationInput = {
    id?: SortOrder
    trackedAccountId?: SortOrder
    externalPostId?: SortOrder
    content?: SortOrder
    postedAt?: SortOrder
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
    keywords?: SortOrder
    tickers?: SortOrder
    hashtags?: SortOrder
    narrativeId?: SortOrderInput | SortOrder
    ingestedAt?: SortOrder
    _count?: IngestedPostCountOrderByAggregateInput
    _avg?: IngestedPostAvgOrderByAggregateInput
    _max?: IngestedPostMaxOrderByAggregateInput
    _min?: IngestedPostMinOrderByAggregateInput
    _sum?: IngestedPostSumOrderByAggregateInput
  }

  export type IngestedPostScalarWhereWithAggregatesInput = {
    AND?: IngestedPostScalarWhereWithAggregatesInput | IngestedPostScalarWhereWithAggregatesInput[]
    OR?: IngestedPostScalarWhereWithAggregatesInput[]
    NOT?: IngestedPostScalarWhereWithAggregatesInput | IngestedPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngestedPost"> | string
    trackedAccountId?: StringWithAggregatesFilter<"IngestedPost"> | string
    externalPostId?: StringWithAggregatesFilter<"IngestedPost"> | string
    content?: StringWithAggregatesFilter<"IngestedPost"> | string
    postedAt?: DateTimeWithAggregatesFilter<"IngestedPost"> | Date | string
    engagementLikes?: IntWithAggregatesFilter<"IngestedPost"> | number
    engagementRetweets?: IntWithAggregatesFilter<"IngestedPost"> | number
    keywords?: StringWithAggregatesFilter<"IngestedPost"> | string
    tickers?: StringWithAggregatesFilter<"IngestedPost"> | string
    hashtags?: StringWithAggregatesFilter<"IngestedPost"> | string
    narrativeId?: StringNullableWithAggregatesFilter<"IngestedPost"> | string | null
    ingestedAt?: DateTimeWithAggregatesFilter<"IngestedPost"> | Date | string
  }

  export type CommunityPulseWhereInput = {
    AND?: CommunityPulseWhereInput | CommunityPulseWhereInput[]
    OR?: CommunityPulseWhereInput[]
    NOT?: CommunityPulseWhereInput | CommunityPulseWhereInput[]
    id?: StringFilter<"CommunityPulse"> | string
    narrativeId?: StringNullableFilter<"CommunityPulse"> | string | null
    bullishPercent?: FloatFilter<"CommunityPulse"> | number
    bearishPercent?: FloatFilter<"CommunityPulse"> | number
    neutralPercent?: FloatFilter<"CommunityPulse"> | number
    discussionCount?: IntFilter<"CommunityPulse"> | number
    calculatedAt?: DateTimeFilter<"CommunityPulse"> | Date | string
    period?: StringFilter<"CommunityPulse"> | string
    narrative?: XOR<NarrativeNullableRelationFilter, NarrativeWhereInput> | null
  }

  export type CommunityPulseOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrderInput | SortOrder
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
    calculatedAt?: SortOrder
    period?: SortOrder
    narrative?: NarrativeOrderByWithRelationInput
  }

  export type CommunityPulseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityPulseWhereInput | CommunityPulseWhereInput[]
    OR?: CommunityPulseWhereInput[]
    NOT?: CommunityPulseWhereInput | CommunityPulseWhereInput[]
    narrativeId?: StringNullableFilter<"CommunityPulse"> | string | null
    bullishPercent?: FloatFilter<"CommunityPulse"> | number
    bearishPercent?: FloatFilter<"CommunityPulse"> | number
    neutralPercent?: FloatFilter<"CommunityPulse"> | number
    discussionCount?: IntFilter<"CommunityPulse"> | number
    calculatedAt?: DateTimeFilter<"CommunityPulse"> | Date | string
    period?: StringFilter<"CommunityPulse"> | string
    narrative?: XOR<NarrativeNullableRelationFilter, NarrativeWhereInput> | null
  }, "id">

  export type CommunityPulseOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrderInput | SortOrder
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
    calculatedAt?: SortOrder
    period?: SortOrder
    _count?: CommunityPulseCountOrderByAggregateInput
    _avg?: CommunityPulseAvgOrderByAggregateInput
    _max?: CommunityPulseMaxOrderByAggregateInput
    _min?: CommunityPulseMinOrderByAggregateInput
    _sum?: CommunityPulseSumOrderByAggregateInput
  }

  export type CommunityPulseScalarWhereWithAggregatesInput = {
    AND?: CommunityPulseScalarWhereWithAggregatesInput | CommunityPulseScalarWhereWithAggregatesInput[]
    OR?: CommunityPulseScalarWhereWithAggregatesInput[]
    NOT?: CommunityPulseScalarWhereWithAggregatesInput | CommunityPulseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityPulse"> | string
    narrativeId?: StringNullableWithAggregatesFilter<"CommunityPulse"> | string | null
    bullishPercent?: FloatWithAggregatesFilter<"CommunityPulse"> | number
    bearishPercent?: FloatWithAggregatesFilter<"CommunityPulse"> | number
    neutralPercent?: FloatWithAggregatesFilter<"CommunityPulse"> | number
    discussionCount?: IntWithAggregatesFilter<"CommunityPulse"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"CommunityPulse"> | Date | string
    period?: StringWithAggregatesFilter<"CommunityPulse"> | string
  }

  export type NewsArticleWhereInput = {
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    id?: StringFilter<"NewsArticle"> | string
    source?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    content?: StringFilter<"NewsArticle"> | string
    url?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
  }

  export type NewsArticleOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: NewsArticleWhereInput | NewsArticleWhereInput[]
    OR?: NewsArticleWhereInput[]
    NOT?: NewsArticleWhereInput | NewsArticleWhereInput[]
    source?: StringFilter<"NewsArticle"> | string
    title?: StringFilter<"NewsArticle"> | string
    content?: StringFilter<"NewsArticle"> | string
    publishedAt?: DateTimeFilter<"NewsArticle"> | Date | string
    createdAt?: DateTimeFilter<"NewsArticle"> | Date | string
  }, "id" | "url">

  export type NewsArticleOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    _count?: NewsArticleCountOrderByAggregateInput
    _max?: NewsArticleMaxOrderByAggregateInput
    _min?: NewsArticleMinOrderByAggregateInput
  }

  export type NewsArticleScalarWhereWithAggregatesInput = {
    AND?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    OR?: NewsArticleScalarWhereWithAggregatesInput[]
    NOT?: NewsArticleScalarWhereWithAggregatesInput | NewsArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsArticle"> | string
    source?: StringWithAggregatesFilter<"NewsArticle"> | string
    title?: StringWithAggregatesFilter<"NewsArticle"> | string
    content?: StringWithAggregatesFilter<"NewsArticle"> | string
    url?: StringWithAggregatesFilter<"NewsArticle"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"NewsArticle"> | Date | string
  }

  export type NewsSourceWhereInput = {
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    id?: StringFilter<"NewsSource"> | string
    name?: StringFilter<"NewsSource"> | string
    category?: StringFilter<"NewsSource"> | string
    active?: BoolFilter<"NewsSource"> | boolean
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    updatedAt?: DateTimeFilter<"NewsSource"> | Date | string
  }

  export type NewsSourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: NewsSourceWhereInput | NewsSourceWhereInput[]
    OR?: NewsSourceWhereInput[]
    NOT?: NewsSourceWhereInput | NewsSourceWhereInput[]
    category?: StringFilter<"NewsSource"> | string
    active?: BoolFilter<"NewsSource"> | boolean
    createdAt?: DateTimeFilter<"NewsSource"> | Date | string
    updatedAt?: DateTimeFilter<"NewsSource"> | Date | string
  }, "id" | "name">

  export type NewsSourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsSourceCountOrderByAggregateInput
    _max?: NewsSourceMaxOrderByAggregateInput
    _min?: NewsSourceMinOrderByAggregateInput
  }

  export type NewsSourceScalarWhereWithAggregatesInput = {
    AND?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    OR?: NewsSourceScalarWhereWithAggregatesInput[]
    NOT?: NewsSourceScalarWhereWithAggregatesInput | NewsSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NewsSource"> | string
    name?: StringWithAggregatesFilter<"NewsSource"> | string
    category?: StringWithAggregatesFilter<"NewsSource"> | string
    active?: BoolWithAggregatesFilter<"NewsSource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NewsSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NewsSource"> | Date | string
  }

  export type ArticleEntityWhereInput = {
    AND?: ArticleEntityWhereInput | ArticleEntityWhereInput[]
    OR?: ArticleEntityWhereInput[]
    NOT?: ArticleEntityWhereInput | ArticleEntityWhereInput[]
    id?: StringFilter<"ArticleEntity"> | string
    articleId?: StringFilter<"ArticleEntity"> | string
    entity?: StringFilter<"ArticleEntity"> | string
    type?: StringFilter<"ArticleEntity"> | string
    createdAt?: DateTimeFilter<"ArticleEntity"> | Date | string
  }

  export type ArticleEntityOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    entity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArticleEntityWhereInput | ArticleEntityWhereInput[]
    OR?: ArticleEntityWhereInput[]
    NOT?: ArticleEntityWhereInput | ArticleEntityWhereInput[]
    articleId?: StringFilter<"ArticleEntity"> | string
    entity?: StringFilter<"ArticleEntity"> | string
    type?: StringFilter<"ArticleEntity"> | string
    createdAt?: DateTimeFilter<"ArticleEntity"> | Date | string
  }, "id">

  export type ArticleEntityOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    entity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ArticleEntityCountOrderByAggregateInput
    _max?: ArticleEntityMaxOrderByAggregateInput
    _min?: ArticleEntityMinOrderByAggregateInput
  }

  export type ArticleEntityScalarWhereWithAggregatesInput = {
    AND?: ArticleEntityScalarWhereWithAggregatesInput | ArticleEntityScalarWhereWithAggregatesInput[]
    OR?: ArticleEntityScalarWhereWithAggregatesInput[]
    NOT?: ArticleEntityScalarWhereWithAggregatesInput | ArticleEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArticleEntity"> | string
    articleId?: StringWithAggregatesFilter<"ArticleEntity"> | string
    entity?: StringWithAggregatesFilter<"ArticleEntity"> | string
    type?: StringWithAggregatesFilter<"ArticleEntity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ArticleEntity"> | Date | string
  }

  export type DetectedNarrativeWhereInput = {
    AND?: DetectedNarrativeWhereInput | DetectedNarrativeWhereInput[]
    OR?: DetectedNarrativeWhereInput[]
    NOT?: DetectedNarrativeWhereInput | DetectedNarrativeWhereInput[]
    id?: StringFilter<"DetectedNarrative"> | string
    title?: StringFilter<"DetectedNarrative"> | string
    summary?: StringFilter<"DetectedNarrative"> | string
    sentiment?: StringFilter<"DetectedNarrative"> | string
    createdAt?: DateTimeFilter<"DetectedNarrative"> | Date | string
    updatedAt?: DateTimeFilter<"DetectedNarrative"> | Date | string
    articles?: DetectedNarrativeArticleListRelationFilter
    metrics?: NarrativeMetricListRelationFilter
    followers?: NarrativeFollowerListRelationFilter
    messages?: MarketMessageListRelationFilter
    stances?: NarrativeStanceListRelationFilter
  }

  export type DetectedNarrativeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articles?: DetectedNarrativeArticleOrderByRelationAggregateInput
    metrics?: NarrativeMetricOrderByRelationAggregateInput
    followers?: NarrativeFollowerOrderByRelationAggregateInput
    messages?: MarketMessageOrderByRelationAggregateInput
    stances?: NarrativeStanceOrderByRelationAggregateInput
  }

  export type DetectedNarrativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DetectedNarrativeWhereInput | DetectedNarrativeWhereInput[]
    OR?: DetectedNarrativeWhereInput[]
    NOT?: DetectedNarrativeWhereInput | DetectedNarrativeWhereInput[]
    title?: StringFilter<"DetectedNarrative"> | string
    summary?: StringFilter<"DetectedNarrative"> | string
    sentiment?: StringFilter<"DetectedNarrative"> | string
    createdAt?: DateTimeFilter<"DetectedNarrative"> | Date | string
    updatedAt?: DateTimeFilter<"DetectedNarrative"> | Date | string
    articles?: DetectedNarrativeArticleListRelationFilter
    metrics?: NarrativeMetricListRelationFilter
    followers?: NarrativeFollowerListRelationFilter
    messages?: MarketMessageListRelationFilter
    stances?: NarrativeStanceListRelationFilter
  }, "id">

  export type DetectedNarrativeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetectedNarrativeCountOrderByAggregateInput
    _max?: DetectedNarrativeMaxOrderByAggregateInput
    _min?: DetectedNarrativeMinOrderByAggregateInput
  }

  export type DetectedNarrativeScalarWhereWithAggregatesInput = {
    AND?: DetectedNarrativeScalarWhereWithAggregatesInput | DetectedNarrativeScalarWhereWithAggregatesInput[]
    OR?: DetectedNarrativeScalarWhereWithAggregatesInput[]
    NOT?: DetectedNarrativeScalarWhereWithAggregatesInput | DetectedNarrativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DetectedNarrative"> | string
    title?: StringWithAggregatesFilter<"DetectedNarrative"> | string
    summary?: StringWithAggregatesFilter<"DetectedNarrative"> | string
    sentiment?: StringWithAggregatesFilter<"DetectedNarrative"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DetectedNarrative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DetectedNarrative"> | Date | string
  }

  export type MarketMessageWhereInput = {
    AND?: MarketMessageWhereInput | MarketMessageWhereInput[]
    OR?: MarketMessageWhereInput[]
    NOT?: MarketMessageWhereInput | MarketMessageWhereInput[]
    id?: StringFilter<"MarketMessage"> | string
    narrativeId?: StringFilter<"MarketMessage"> | string
    userId?: StringFilter<"MarketMessage"> | string
    text?: StringFilter<"MarketMessage"> | string
    createdAt?: DateTimeFilter<"MarketMessage"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MarketMessageOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    narrative?: DetectedNarrativeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MarketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketMessageWhereInput | MarketMessageWhereInput[]
    OR?: MarketMessageWhereInput[]
    NOT?: MarketMessageWhereInput | MarketMessageWhereInput[]
    narrativeId?: StringFilter<"MarketMessage"> | string
    userId?: StringFilter<"MarketMessage"> | string
    text?: StringFilter<"MarketMessage"> | string
    createdAt?: DateTimeFilter<"MarketMessage"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MarketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    _count?: MarketMessageCountOrderByAggregateInput
    _max?: MarketMessageMaxOrderByAggregateInput
    _min?: MarketMessageMinOrderByAggregateInput
  }

  export type MarketMessageScalarWhereWithAggregatesInput = {
    AND?: MarketMessageScalarWhereWithAggregatesInput | MarketMessageScalarWhereWithAggregatesInput[]
    OR?: MarketMessageScalarWhereWithAggregatesInput[]
    NOT?: MarketMessageScalarWhereWithAggregatesInput | MarketMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketMessage"> | string
    narrativeId?: StringWithAggregatesFilter<"MarketMessage"> | string
    userId?: StringWithAggregatesFilter<"MarketMessage"> | string
    text?: StringWithAggregatesFilter<"MarketMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketMessage"> | Date | string
  }

  export type NarrativeFollowerWhereInput = {
    AND?: NarrativeFollowerWhereInput | NarrativeFollowerWhereInput[]
    OR?: NarrativeFollowerWhereInput[]
    NOT?: NarrativeFollowerWhereInput | NarrativeFollowerWhereInput[]
    id?: StringFilter<"NarrativeFollower"> | string
    userId?: StringFilter<"NarrativeFollower"> | string
    narrativeId?: StringFilter<"NarrativeFollower"> | string
    createdAt?: DateTimeFilter<"NarrativeFollower"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }

  export type NarrativeFollowerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    narrativeId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    narrative?: DetectedNarrativeOrderByWithRelationInput
  }

  export type NarrativeFollowerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_narrativeId?: NarrativeFollowerUserIdNarrativeIdCompoundUniqueInput
    AND?: NarrativeFollowerWhereInput | NarrativeFollowerWhereInput[]
    OR?: NarrativeFollowerWhereInput[]
    NOT?: NarrativeFollowerWhereInput | NarrativeFollowerWhereInput[]
    userId?: StringFilter<"NarrativeFollower"> | string
    narrativeId?: StringFilter<"NarrativeFollower"> | string
    createdAt?: DateTimeFilter<"NarrativeFollower"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }, "id" | "userId_narrativeId">

  export type NarrativeFollowerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    narrativeId?: SortOrder
    createdAt?: SortOrder
    _count?: NarrativeFollowerCountOrderByAggregateInput
    _max?: NarrativeFollowerMaxOrderByAggregateInput
    _min?: NarrativeFollowerMinOrderByAggregateInput
  }

  export type NarrativeFollowerScalarWhereWithAggregatesInput = {
    AND?: NarrativeFollowerScalarWhereWithAggregatesInput | NarrativeFollowerScalarWhereWithAggregatesInput[]
    OR?: NarrativeFollowerScalarWhereWithAggregatesInput[]
    NOT?: NarrativeFollowerScalarWhereWithAggregatesInput | NarrativeFollowerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NarrativeFollower"> | string
    userId?: StringWithAggregatesFilter<"NarrativeFollower"> | string
    narrativeId?: StringWithAggregatesFilter<"NarrativeFollower"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NarrativeFollower"> | Date | string
  }

  export type NarrativeMetricWhereInput = {
    AND?: NarrativeMetricWhereInput | NarrativeMetricWhereInput[]
    OR?: NarrativeMetricWhereInput[]
    NOT?: NarrativeMetricWhereInput | NarrativeMetricWhereInput[]
    id?: StringFilter<"NarrativeMetric"> | string
    narrativeId?: StringFilter<"NarrativeMetric"> | string
    period?: StringFilter<"NarrativeMetric"> | string
    mentionCount?: IntFilter<"NarrativeMetric"> | number
    velocity?: FloatFilter<"NarrativeMetric"> | number
    calculatedAt?: DateTimeFilter<"NarrativeMetric"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }

  export type NarrativeMetricOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    period?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    calculatedAt?: SortOrder
    narrative?: DetectedNarrativeOrderByWithRelationInput
  }

  export type NarrativeMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NarrativeMetricWhereInput | NarrativeMetricWhereInput[]
    OR?: NarrativeMetricWhereInput[]
    NOT?: NarrativeMetricWhereInput | NarrativeMetricWhereInput[]
    narrativeId?: StringFilter<"NarrativeMetric"> | string
    period?: StringFilter<"NarrativeMetric"> | string
    mentionCount?: IntFilter<"NarrativeMetric"> | number
    velocity?: FloatFilter<"NarrativeMetric"> | number
    calculatedAt?: DateTimeFilter<"NarrativeMetric"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }, "id">

  export type NarrativeMetricOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    period?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    calculatedAt?: SortOrder
    _count?: NarrativeMetricCountOrderByAggregateInput
    _avg?: NarrativeMetricAvgOrderByAggregateInput
    _max?: NarrativeMetricMaxOrderByAggregateInput
    _min?: NarrativeMetricMinOrderByAggregateInput
    _sum?: NarrativeMetricSumOrderByAggregateInput
  }

  export type NarrativeMetricScalarWhereWithAggregatesInput = {
    AND?: NarrativeMetricScalarWhereWithAggregatesInput | NarrativeMetricScalarWhereWithAggregatesInput[]
    OR?: NarrativeMetricScalarWhereWithAggregatesInput[]
    NOT?: NarrativeMetricScalarWhereWithAggregatesInput | NarrativeMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NarrativeMetric"> | string
    narrativeId?: StringWithAggregatesFilter<"NarrativeMetric"> | string
    period?: StringWithAggregatesFilter<"NarrativeMetric"> | string
    mentionCount?: IntWithAggregatesFilter<"NarrativeMetric"> | number
    velocity?: FloatWithAggregatesFilter<"NarrativeMetric"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"NarrativeMetric"> | Date | string
  }

  export type DetectedNarrativeArticleWhereInput = {
    AND?: DetectedNarrativeArticleWhereInput | DetectedNarrativeArticleWhereInput[]
    OR?: DetectedNarrativeArticleWhereInput[]
    NOT?: DetectedNarrativeArticleWhereInput | DetectedNarrativeArticleWhereInput[]
    id?: StringFilter<"DetectedNarrativeArticle"> | string
    narrativeId?: StringFilter<"DetectedNarrativeArticle"> | string
    articleId?: StringFilter<"DetectedNarrativeArticle"> | string
    createdAt?: DateTimeFilter<"DetectedNarrativeArticle"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }

  export type DetectedNarrativeArticleOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    narrative?: DetectedNarrativeOrderByWithRelationInput
  }

  export type DetectedNarrativeArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    narrativeId_articleId?: DetectedNarrativeArticleNarrativeIdArticleIdCompoundUniqueInput
    AND?: DetectedNarrativeArticleWhereInput | DetectedNarrativeArticleWhereInput[]
    OR?: DetectedNarrativeArticleWhereInput[]
    NOT?: DetectedNarrativeArticleWhereInput | DetectedNarrativeArticleWhereInput[]
    narrativeId?: StringFilter<"DetectedNarrativeArticle"> | string
    articleId?: StringFilter<"DetectedNarrativeArticle"> | string
    createdAt?: DateTimeFilter<"DetectedNarrativeArticle"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
  }, "id" | "narrativeId_articleId">

  export type DetectedNarrativeArticleOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    _count?: DetectedNarrativeArticleCountOrderByAggregateInput
    _max?: DetectedNarrativeArticleMaxOrderByAggregateInput
    _min?: DetectedNarrativeArticleMinOrderByAggregateInput
  }

  export type DetectedNarrativeArticleScalarWhereWithAggregatesInput = {
    AND?: DetectedNarrativeArticleScalarWhereWithAggregatesInput | DetectedNarrativeArticleScalarWhereWithAggregatesInput[]
    OR?: DetectedNarrativeArticleScalarWhereWithAggregatesInput[]
    NOT?: DetectedNarrativeArticleScalarWhereWithAggregatesInput | DetectedNarrativeArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DetectedNarrativeArticle"> | string
    narrativeId?: StringWithAggregatesFilter<"DetectedNarrativeArticle"> | string
    articleId?: StringWithAggregatesFilter<"DetectedNarrativeArticle"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DetectedNarrativeArticle"> | Date | string
  }

  export type NarrativeStanceWhereInput = {
    AND?: NarrativeStanceWhereInput | NarrativeStanceWhereInput[]
    OR?: NarrativeStanceWhereInput[]
    NOT?: NarrativeStanceWhereInput | NarrativeStanceWhereInput[]
    id?: StringFilter<"NarrativeStance"> | string
    narrativeId?: StringFilter<"NarrativeStance"> | string
    userId?: StringFilter<"NarrativeStance"> | string
    stance?: StringFilter<"NarrativeStance"> | string
    createdAt?: DateTimeFilter<"NarrativeStance"> | Date | string
    updatedAt?: DateTimeFilter<"NarrativeStance"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NarrativeStanceOrderByWithRelationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    stance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    narrative?: DetectedNarrativeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NarrativeStanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_narrativeId?: NarrativeStanceUserIdNarrativeIdCompoundUniqueInput
    AND?: NarrativeStanceWhereInput | NarrativeStanceWhereInput[]
    OR?: NarrativeStanceWhereInput[]
    NOT?: NarrativeStanceWhereInput | NarrativeStanceWhereInput[]
    narrativeId?: StringFilter<"NarrativeStance"> | string
    userId?: StringFilter<"NarrativeStance"> | string
    stance?: StringFilter<"NarrativeStance"> | string
    createdAt?: DateTimeFilter<"NarrativeStance"> | Date | string
    updatedAt?: DateTimeFilter<"NarrativeStance"> | Date | string
    narrative?: XOR<DetectedNarrativeRelationFilter, DetectedNarrativeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_narrativeId">

  export type NarrativeStanceOrderByWithAggregationInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    stance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NarrativeStanceCountOrderByAggregateInput
    _max?: NarrativeStanceMaxOrderByAggregateInput
    _min?: NarrativeStanceMinOrderByAggregateInput
  }

  export type NarrativeStanceScalarWhereWithAggregatesInput = {
    AND?: NarrativeStanceScalarWhereWithAggregatesInput | NarrativeStanceScalarWhereWithAggregatesInput[]
    OR?: NarrativeStanceScalarWhereWithAggregatesInput[]
    NOT?: NarrativeStanceScalarWhereWithAggregatesInput | NarrativeStanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NarrativeStance"> | string
    narrativeId?: StringWithAggregatesFilter<"NarrativeStance"> | string
    userId?: StringWithAggregatesFilter<"NarrativeStance"> | string
    stance?: StringWithAggregatesFilter<"NarrativeStance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NarrativeStance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NarrativeStance"> | Date | string
  }

  export type ExternalPostWhereInput = {
    AND?: ExternalPostWhereInput | ExternalPostWhereInput[]
    OR?: ExternalPostWhereInput[]
    NOT?: ExternalPostWhereInput | ExternalPostWhereInput[]
    id?: StringFilter<"ExternalPost"> | string
    platform?: StringFilter<"ExternalPost"> | string
    authorHandle?: StringFilter<"ExternalPost"> | string
    content?: StringFilter<"ExternalPost"> | string
    engagement?: StringFilter<"ExternalPost"> | string
    publishedAt?: DateTimeFilter<"ExternalPost"> | Date | string
    url?: StringNullableFilter<"ExternalPost"> | string | null
    postId?: StringNullableFilter<"ExternalPost"> | string | null
    createdAt?: DateTimeFilter<"ExternalPost"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalPost"> | Date | string
  }

  export type ExternalPostOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    engagement?: SortOrder
    publishedAt?: SortOrder
    url?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    platform_postId?: ExternalPostPlatformPostIdCompoundUniqueInput
    AND?: ExternalPostWhereInput | ExternalPostWhereInput[]
    OR?: ExternalPostWhereInput[]
    NOT?: ExternalPostWhereInput | ExternalPostWhereInput[]
    platform?: StringFilter<"ExternalPost"> | string
    authorHandle?: StringFilter<"ExternalPost"> | string
    content?: StringFilter<"ExternalPost"> | string
    engagement?: StringFilter<"ExternalPost"> | string
    publishedAt?: DateTimeFilter<"ExternalPost"> | Date | string
    url?: StringNullableFilter<"ExternalPost"> | string | null
    postId?: StringNullableFilter<"ExternalPost"> | string | null
    createdAt?: DateTimeFilter<"ExternalPost"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalPost"> | Date | string
  }, "id" | "platform_postId">

  export type ExternalPostOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    engagement?: SortOrder
    publishedAt?: SortOrder
    url?: SortOrderInput | SortOrder
    postId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalPostCountOrderByAggregateInput
    _max?: ExternalPostMaxOrderByAggregateInput
    _min?: ExternalPostMinOrderByAggregateInput
  }

  export type ExternalPostScalarWhereWithAggregatesInput = {
    AND?: ExternalPostScalarWhereWithAggregatesInput | ExternalPostScalarWhereWithAggregatesInput[]
    OR?: ExternalPostScalarWhereWithAggregatesInput[]
    NOT?: ExternalPostScalarWhereWithAggregatesInput | ExternalPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalPost"> | string
    platform?: StringWithAggregatesFilter<"ExternalPost"> | string
    authorHandle?: StringWithAggregatesFilter<"ExternalPost"> | string
    content?: StringWithAggregatesFilter<"ExternalPost"> | string
    engagement?: StringWithAggregatesFilter<"ExternalPost"> | string
    publishedAt?: DateTimeWithAggregatesFilter<"ExternalPost"> | Date | string
    url?: StringNullableWithAggregatesFilter<"ExternalPost"> | string | null
    postId?: StringNullableWithAggregatesFilter<"ExternalPost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExternalPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalPost"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFriendshipsAsUserInput
    friend: UserCreateNestedOneWithoutFriendshipsAsFriendInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    userId: string
    friendId: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFriendshipsAsUserNestedInput
    friend?: UserUpdateOneRequiredWithoutFriendshipsAsFriendNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    userId: string
    friendId: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricCreateInput = {
    id?: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserMetricsInput
  }

  export type UserMetricUncheckedCreateInput = {
    id?: string
    userId: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
  }

  export type UserMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserMetricsNestedInput
  }

  export type UserMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricCreateManyInput = {
    id?: string
    userId: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
  }

  export type UserMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeCreateInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetUncheckedCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventUncheckedCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostUncheckedCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUncheckedUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUncheckedUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUncheckedUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NarrativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetCreateInput = {
    id?: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
    narrative: NarrativeCreateNestedOneWithoutAssetsInput
  }

  export type NarrativeAssetUncheckedCreateInput = {
    id?: string
    narrativeId: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
  }

  export type NarrativeAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: NarrativeUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type NarrativeAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetCreateManyInput = {
    id?: string
    narrativeId: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
  }

  export type NarrativeAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventCreateInput = {
    id?: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
    narrative: NarrativeCreateNestedOneWithoutEventsInput
  }

  export type NarrativeEventUncheckedCreateInput = {
    id?: string
    narrativeId: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type NarrativeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: NarrativeUpdateOneRequiredWithoutEventsNestedInput
  }

  export type NarrativeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventCreateManyInput = {
    id?: string
    narrativeId: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type NarrativeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialPostCreateInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialPostsInput
    tickers?: PostTickerCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateInput = {
    id?: string
    userId: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickers?: PostTickerUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialPostsNestedInput
    tickers?: PostTickerUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickers?: PostTickerUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SocialPostCreateManyInput = {
    id?: string
    userId: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTickerCreateInput = {
    id?: string
    ticker: string
    post: SocialPostCreateNestedOneWithoutTickersInput
  }

  export type PostTickerUncheckedCreateInput = {
    id?: string
    postId: string
    ticker: string
  }

  export type PostTickerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    post?: SocialPostUpdateOneRequiredWithoutTickersNestedInput
  }

  export type PostTickerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostTickerCreateManyInput = {
    id?: string
    postId: string
    ticker: string
  }

  export type PostTickerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostTickerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeCreateInput = {
    id?: string
    createdAt?: Date | string
    post: SocialPostCreateNestedOneWithoutLikesInput
    user: UserCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type PostLikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: SocialPostUpdateOneRequiredWithoutLikesNestedInput
    user?: UserUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeCreateManyInput = {
    id?: string
    postId: string
    userId: string
    createdAt?: Date | string
  }

  export type PostLikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedAccountCreateInput = {
    id?: string
    platform?: string
    accountHandle: string
    accountName?: string | null
    accountType?: string | null
    isActive?: boolean
    lastFetchedAt?: Date | string | null
    createdAt?: Date | string
    posts?: IngestedPostCreateNestedManyWithoutAccountInput
  }

  export type TrackedAccountUncheckedCreateInput = {
    id?: string
    platform?: string
    accountHandle: string
    accountName?: string | null
    accountType?: string | null
    isActive?: boolean
    lastFetchedAt?: Date | string | null
    createdAt?: Date | string
    posts?: IngestedPostUncheckedCreateNestedManyWithoutAccountInput
  }

  export type TrackedAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: IngestedPostUpdateManyWithoutAccountNestedInput
  }

  export type TrackedAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: IngestedPostUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type TrackedAccountCreateManyInput = {
    id?: string
    platform?: string
    accountHandle: string
    accountName?: string | null
    accountType?: string | null
    isActive?: boolean
    lastFetchedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TrackedAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostCreateInput = {
    id?: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    ingestedAt?: Date | string
    account: TrackedAccountCreateNestedOneWithoutPostsInput
    narrative?: NarrativeCreateNestedOneWithoutPostsInput
  }

  export type IngestedPostUncheckedCreateInput = {
    id?: string
    trackedAccountId: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    narrativeId?: string | null
    ingestedAt?: Date | string
  }

  export type IngestedPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: TrackedAccountUpdateOneRequiredWithoutPostsNestedInput
    narrative?: NarrativeUpdateOneWithoutPostsNestedInput
  }

  export type IngestedPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackedAccountId?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostCreateManyInput = {
    id?: string
    trackedAccountId: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    narrativeId?: string | null
    ingestedAt?: Date | string
  }

  export type IngestedPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackedAccountId?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPulseCreateInput = {
    id?: string
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
    narrative?: NarrativeCreateNestedOneWithoutPulseInput
  }

  export type CommunityPulseUncheckedCreateInput = {
    id?: string
    narrativeId?: string | null
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
  }

  export type CommunityPulseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
    narrative?: NarrativeUpdateOneWithoutPulseNestedInput
  }

  export type CommunityPulseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityPulseCreateManyInput = {
    id?: string
    narrativeId?: string | null
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
  }

  export type CommunityPulseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityPulseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type NewsArticleCreateInput = {
    id?: string
    source: string
    title: string
    content: string
    url: string
    publishedAt: Date | string
    createdAt?: Date | string
  }

  export type NewsArticleUncheckedCreateInput = {
    id?: string
    source: string
    title: string
    content: string
    url: string
    publishedAt: Date | string
    createdAt?: Date | string
  }

  export type NewsArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleCreateManyInput = {
    id?: string
    source: string
    title: string
    content: string
    url: string
    publishedAt: Date | string
    createdAt?: Date | string
  }

  export type NewsArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceCreateInput = {
    id?: string
    name: string
    category: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsSourceUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceCreateManyInput = {
    id?: string
    name: string
    category: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NewsSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NewsSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleEntityCreateInput = {
    id?: string
    articleId: string
    entity: string
    type: string
    createdAt?: Date | string
  }

  export type ArticleEntityUncheckedCreateInput = {
    id?: string
    articleId: string
    entity: string
    type: string
    createdAt?: Date | string
  }

  export type ArticleEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleEntityCreateManyInput = {
    id?: string
    articleId: string
    entity: string
    type: string
    createdAt?: Date | string
  }

  export type ArticleEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeCreateInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeCreateManyInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetectedNarrativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageCreateInput = {
    id?: string
    text: string
    createdAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMarketMessagesInput
  }

  export type MarketMessageUncheckedCreateInput = {
    id?: string
    narrativeId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type MarketMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMarketMessagesNestedInput
  }

  export type MarketMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageCreateManyInput = {
    id?: string
    narrativeId: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type MarketMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNarrativeFollowersInput
    narrative: DetectedNarrativeCreateNestedOneWithoutFollowersInput
  }

  export type NarrativeFollowerUncheckedCreateInput = {
    id?: string
    userId: string
    narrativeId: string
    createdAt?: Date | string
  }

  export type NarrativeFollowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNarrativeFollowersNestedInput
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type NarrativeFollowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerCreateManyInput = {
    id?: string
    userId: string
    narrativeId: string
    createdAt?: Date | string
  }

  export type NarrativeFollowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricCreateInput = {
    id?: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutMetricsInput
  }

  export type NarrativeMetricUncheckedCreateInput = {
    id?: string
    narrativeId: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
  }

  export type NarrativeMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type NarrativeMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricCreateManyInput = {
    id?: string
    narrativeId: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
  }

  export type NarrativeMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleCreateInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutArticlesInput
  }

  export type DetectedNarrativeArticleUncheckedCreateInput = {
    id?: string
    narrativeId: string
    articleId: string
    createdAt?: Date | string
  }

  export type DetectedNarrativeArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type DetectedNarrativeArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleCreateManyInput = {
    id?: string
    narrativeId: string
    articleId: string
    createdAt?: Date | string
  }

  export type DetectedNarrativeArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceCreateInput = {
    id?: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutStancesInput
    user: UserCreateNestedOneWithoutNarrativeStancesInput
  }

  export type NarrativeStanceUncheckedCreateInput = {
    id?: string
    narrativeId: string
    userId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NarrativeStanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutStancesNestedInput
    user?: UserUpdateOneRequiredWithoutNarrativeStancesNestedInput
  }

  export type NarrativeStanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceCreateManyInput = {
    id?: string
    narrativeId: string
    userId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NarrativeStanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalPostCreateInput = {
    id?: string
    platform: string
    authorHandle: string
    content: string
    engagement: string
    publishedAt: Date | string
    url?: string | null
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalPostUncheckedCreateInput = {
    id?: string
    platform: string
    authorHandle: string
    content: string
    engagement: string
    publishedAt: Date | string
    url?: string | null
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    engagement?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    engagement?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalPostCreateManyInput = {
    id?: string
    platform: string
    authorHandle: string
    content: string
    engagement: string
    publishedAt: Date | string
    url?: string | null
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    engagement?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    authorHandle?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    engagement?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type NarrativeFollowerListRelationFilter = {
    every?: NarrativeFollowerWhereInput
    some?: NarrativeFollowerWhereInput
    none?: NarrativeFollowerWhereInput
  }

  export type UserMetricListRelationFilter = {
    every?: UserMetricWhereInput
    some?: UserMetricWhereInput
    none?: UserMetricWhereInput
  }

  export type SocialPostListRelationFilter = {
    every?: SocialPostWhereInput
    some?: SocialPostWhereInput
    none?: SocialPostWhereInput
  }

  export type PostLikeListRelationFilter = {
    every?: PostLikeWhereInput
    some?: PostLikeWhereInput
    none?: PostLikeWhereInput
  }

  export type MarketMessageListRelationFilter = {
    every?: MarketMessageWhereInput
    some?: MarketMessageWhereInput
    none?: MarketMessageWhereInput
  }

  export type NarrativeStanceListRelationFilter = {
    every?: NarrativeStanceWhereInput
    some?: NarrativeStanceWhereInput
    none?: NarrativeStanceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NarrativeFollowerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NarrativeStanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    profileMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    profileMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    profileMetadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FriendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserMetricUserIdPeriodCompoundUniqueInput = {
    userId: string
    period: string
  }

  export type UserMetricCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type UserMetricAvgOrderByAggregateInput = {
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
  }

  export type UserMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type UserMetricMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
    calculatedAt?: SortOrder
  }

  export type UserMetricSumOrderByAggregateInput = {
    returnPercent?: SortOrder
    winRate?: SortOrder
    tradesCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NarrativeAssetListRelationFilter = {
    every?: NarrativeAssetWhereInput
    some?: NarrativeAssetWhereInput
    none?: NarrativeAssetWhereInput
  }

  export type NarrativeEventListRelationFilter = {
    every?: NarrativeEventWhereInput
    some?: NarrativeEventWhereInput
    none?: NarrativeEventWhereInput
  }

  export type IngestedPostListRelationFilter = {
    every?: IngestedPostWhereInput
    some?: IngestedPostWhereInput
    none?: IngestedPostWhereInput
  }

  export type CommunityPulseListRelationFilter = {
    every?: CommunityPulseWhereInput
    some?: CommunityPulseWhereInput
    none?: CommunityPulseWhereInput
  }

  export type NarrativeAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NarrativeEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngestedPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityPulseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NarrativeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    sentiment?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NarrativeAvgOrderByAggregateInput = {
    mentionCount?: SortOrder
    velocity?: SortOrder
  }

  export type NarrativeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    sentiment?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NarrativeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    triggerType?: SortOrder
    triggerValue?: SortOrder
    sentiment?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NarrativeSumOrderByAggregateInput = {
    mentionCount?: SortOrder
    velocity?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NarrativeRelationFilter = {
    is?: NarrativeWhereInput
    isNot?: NarrativeWhereInput
  }

  export type NarrativeAssetNarrativeIdAssetSymbolCompoundUniqueInput = {
    narrativeId: string
    assetSymbol: string
  }

  export type NarrativeAssetCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    assetSymbol?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeAssetAvgOrderByAggregateInput = {
    impact?: SortOrder
  }

  export type NarrativeAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    assetSymbol?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeAssetMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    assetSymbol?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeAssetSumOrderByAggregateInput = {
    impact?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NarrativeEventCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    eventTime?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    eventTime?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeEventMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    eventTime?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PostTickerListRelationFilter = {
    every?: PostTickerWhereInput
    some?: PostTickerWhereInput
    none?: PostTickerWhereInput
  }

  export type PostTickerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialPostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    likesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type SocialPostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    likesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    sentiment?: SortOrder
    likesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialPostSumOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type SocialPostRelationFilter = {
    is?: SocialPostWhereInput
    isNot?: SocialPostWhereInput
  }

  export type PostTickerCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    ticker?: SortOrder
  }

  export type PostTickerMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    ticker?: SortOrder
  }

  export type PostTickerMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    ticker?: SortOrder
  }

  export type PostLikePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type PostLikeCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PostLikeMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TrackedAccountCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountHandle?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    lastFetchedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackedAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountHandle?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    lastFetchedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackedAccountMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    accountHandle?: SortOrder
    accountName?: SortOrder
    accountType?: SortOrder
    isActive?: SortOrder
    lastFetchedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TrackedAccountRelationFilter = {
    is?: TrackedAccountWhereInput
    isNot?: TrackedAccountWhereInput
  }

  export type NarrativeNullableRelationFilter = {
    is?: NarrativeWhereInput | null
    isNot?: NarrativeWhereInput | null
  }

  export type IngestedPostCountOrderByAggregateInput = {
    id?: SortOrder
    trackedAccountId?: SortOrder
    externalPostId?: SortOrder
    content?: SortOrder
    postedAt?: SortOrder
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
    keywords?: SortOrder
    tickers?: SortOrder
    hashtags?: SortOrder
    narrativeId?: SortOrder
    ingestedAt?: SortOrder
  }

  export type IngestedPostAvgOrderByAggregateInput = {
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
  }

  export type IngestedPostMaxOrderByAggregateInput = {
    id?: SortOrder
    trackedAccountId?: SortOrder
    externalPostId?: SortOrder
    content?: SortOrder
    postedAt?: SortOrder
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
    keywords?: SortOrder
    tickers?: SortOrder
    hashtags?: SortOrder
    narrativeId?: SortOrder
    ingestedAt?: SortOrder
  }

  export type IngestedPostMinOrderByAggregateInput = {
    id?: SortOrder
    trackedAccountId?: SortOrder
    externalPostId?: SortOrder
    content?: SortOrder
    postedAt?: SortOrder
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
    keywords?: SortOrder
    tickers?: SortOrder
    hashtags?: SortOrder
    narrativeId?: SortOrder
    ingestedAt?: SortOrder
  }

  export type IngestedPostSumOrderByAggregateInput = {
    engagementLikes?: SortOrder
    engagementRetweets?: SortOrder
  }

  export type CommunityPulseCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
    calculatedAt?: SortOrder
    period?: SortOrder
  }

  export type CommunityPulseAvgOrderByAggregateInput = {
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
  }

  export type CommunityPulseMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
    calculatedAt?: SortOrder
    period?: SortOrder
  }

  export type CommunityPulseMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
    calculatedAt?: SortOrder
    period?: SortOrder
  }

  export type CommunityPulseSumOrderByAggregateInput = {
    bullishPercent?: SortOrder
    bearishPercent?: SortOrder
    neutralPercent?: SortOrder
    discussionCount?: SortOrder
  }

  export type NewsArticleCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsArticleMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NewsSourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsSourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleEntityCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    entity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    entity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleEntityMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    entity?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type DetectedNarrativeArticleListRelationFilter = {
    every?: DetectedNarrativeArticleWhereInput
    some?: DetectedNarrativeArticleWhereInput
    none?: DetectedNarrativeArticleWhereInput
  }

  export type NarrativeMetricListRelationFilter = {
    every?: NarrativeMetricWhereInput
    some?: NarrativeMetricWhereInput
    none?: NarrativeMetricWhereInput
  }

  export type DetectedNarrativeArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NarrativeMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetectedNarrativeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedNarrativeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedNarrativeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedNarrativeRelationFilter = {
    is?: DetectedNarrativeWhereInput
    isNot?: DetectedNarrativeWhereInput
  }

  export type MarketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeFollowerUserIdNarrativeIdCompoundUniqueInput = {
    userId: string
    narrativeId: string
  }

  export type NarrativeFollowerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    narrativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeFollowerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    narrativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeFollowerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    narrativeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeMetricCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    period?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    calculatedAt?: SortOrder
  }

  export type NarrativeMetricAvgOrderByAggregateInput = {
    mentionCount?: SortOrder
    velocity?: SortOrder
  }

  export type NarrativeMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    period?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    calculatedAt?: SortOrder
  }

  export type NarrativeMetricMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    period?: SortOrder
    mentionCount?: SortOrder
    velocity?: SortOrder
    calculatedAt?: SortOrder
  }

  export type NarrativeMetricSumOrderByAggregateInput = {
    mentionCount?: SortOrder
    velocity?: SortOrder
  }

  export type DetectedNarrativeArticleNarrativeIdArticleIdCompoundUniqueInput = {
    narrativeId: string
    articleId: string
  }

  export type DetectedNarrativeArticleCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
  }

  export type DetectedNarrativeArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
  }

  export type DetectedNarrativeArticleMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
  }

  export type NarrativeStanceUserIdNarrativeIdCompoundUniqueInput = {
    userId: string
    narrativeId: string
  }

  export type NarrativeStanceCountOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    stance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NarrativeStanceMaxOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    stance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NarrativeStanceMinOrderByAggregateInput = {
    id?: SortOrder
    narrativeId?: SortOrder
    userId?: SortOrder
    stance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalPostPlatformPostIdCompoundUniqueInput = {
    platform: string
    postId: string
  }

  export type ExternalPostCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    engagement?: SortOrder
    publishedAt?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalPostMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    engagement?: SortOrder
    publishedAt?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalPostMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    authorHandle?: SortOrder
    content?: SortOrder
    engagement?: SortOrder
    publishedAt?: SortOrder
    url?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FriendshipCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type NarrativeFollowerCreateNestedManyWithoutUserInput = {
    create?: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput> | NarrativeFollowerCreateWithoutUserInput[] | NarrativeFollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutUserInput | NarrativeFollowerCreateOrConnectWithoutUserInput[]
    createMany?: NarrativeFollowerCreateManyUserInputEnvelope
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
  }

  export type UserMetricCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput> | UserMetricCreateWithoutUserInput[] | UserMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetricCreateOrConnectWithoutUserInput | UserMetricCreateOrConnectWithoutUserInput[]
    createMany?: UserMetricCreateManyUserInputEnvelope
    connect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
  }

  export type SocialPostCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput> | SocialPostCreateWithoutUserInput[] | SocialPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialPostCreateOrConnectWithoutUserInput | SocialPostCreateOrConnectWithoutUserInput[]
    createMany?: SocialPostCreateManyUserInputEnvelope
    connect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type MarketMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput> | MarketMessageCreateWithoutUserInput[] | MarketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutUserInput | MarketMessageCreateOrConnectWithoutUserInput[]
    createMany?: MarketMessageCreateManyUserInputEnvelope
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
  }

  export type NarrativeStanceCreateNestedManyWithoutUserInput = {
    create?: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput> | NarrativeStanceCreateWithoutUserInput[] | NarrativeStanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutUserInput | NarrativeStanceCreateOrConnectWithoutUserInput[]
    createMany?: NarrativeStanceCreateManyUserInputEnvelope
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutFriendInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput> | NarrativeFollowerCreateWithoutUserInput[] | NarrativeFollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutUserInput | NarrativeFollowerCreateOrConnectWithoutUserInput[]
    createMany?: NarrativeFollowerCreateManyUserInputEnvelope
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
  }

  export type UserMetricUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput> | UserMetricCreateWithoutUserInput[] | UserMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetricCreateOrConnectWithoutUserInput | UserMetricCreateOrConnectWithoutUserInput[]
    createMany?: UserMetricCreateManyUserInputEnvelope
    connect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
  }

  export type SocialPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput> | SocialPostCreateWithoutUserInput[] | SocialPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialPostCreateOrConnectWithoutUserInput | SocialPostCreateOrConnectWithoutUserInput[]
    createMany?: SocialPostCreateManyUserInputEnvelope
    connect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type MarketMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput> | MarketMessageCreateWithoutUserInput[] | MarketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutUserInput | MarketMessageCreateOrConnectWithoutUserInput[]
    createMany?: MarketMessageCreateManyUserInputEnvelope
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
  }

  export type NarrativeStanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput> | NarrativeStanceCreateWithoutUserInput[] | NarrativeStanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutUserInput | NarrativeStanceCreateOrConnectWithoutUserInput[]
    createMany?: NarrativeStanceCreateManyUserInputEnvelope
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FriendshipUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type NarrativeFollowerUpdateManyWithoutUserNestedInput = {
    create?: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput> | NarrativeFollowerCreateWithoutUserInput[] | NarrativeFollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutUserInput | NarrativeFollowerCreateOrConnectWithoutUserInput[]
    upsert?: NarrativeFollowerUpsertWithWhereUniqueWithoutUserInput | NarrativeFollowerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NarrativeFollowerCreateManyUserInputEnvelope
    set?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    disconnect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    delete?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    update?: NarrativeFollowerUpdateWithWhereUniqueWithoutUserInput | NarrativeFollowerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NarrativeFollowerUpdateManyWithWhereWithoutUserInput | NarrativeFollowerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
  }

  export type UserMetricUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput> | UserMetricCreateWithoutUserInput[] | UserMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetricCreateOrConnectWithoutUserInput | UserMetricCreateOrConnectWithoutUserInput[]
    upsert?: UserMetricUpsertWithWhereUniqueWithoutUserInput | UserMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetricCreateManyUserInputEnvelope
    set?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    disconnect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    delete?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    connect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    update?: UserMetricUpdateWithWhereUniqueWithoutUserInput | UserMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMetricUpdateManyWithWhereWithoutUserInput | UserMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetricScalarWhereInput | UserMetricScalarWhereInput[]
  }

  export type SocialPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput> | SocialPostCreateWithoutUserInput[] | SocialPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialPostCreateOrConnectWithoutUserInput | SocialPostCreateOrConnectWithoutUserInput[]
    upsert?: SocialPostUpsertWithWhereUniqueWithoutUserInput | SocialPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialPostCreateManyUserInputEnvelope
    set?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    disconnect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    delete?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    connect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    update?: SocialPostUpdateWithWhereUniqueWithoutUserInput | SocialPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialPostUpdateManyWithWhereWithoutUserInput | SocialPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialPostScalarWhereInput | SocialPostScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutUserInput | PostLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutUserInput | PostLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutUserInput | PostLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type MarketMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput> | MarketMessageCreateWithoutUserInput[] | MarketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutUserInput | MarketMessageCreateOrConnectWithoutUserInput[]
    upsert?: MarketMessageUpsertWithWhereUniqueWithoutUserInput | MarketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketMessageCreateManyUserInputEnvelope
    set?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    disconnect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    delete?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    update?: MarketMessageUpdateWithWhereUniqueWithoutUserInput | MarketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketMessageUpdateManyWithWhereWithoutUserInput | MarketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
  }

  export type NarrativeStanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput> | NarrativeStanceCreateWithoutUserInput[] | NarrativeStanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutUserInput | NarrativeStanceCreateOrConnectWithoutUserInput[]
    upsert?: NarrativeStanceUpsertWithWhereUniqueWithoutUserInput | NarrativeStanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NarrativeStanceCreateManyUserInputEnvelope
    set?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    disconnect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    delete?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    update?: NarrativeStanceUpdateWithWhereUniqueWithoutUserInput | NarrativeStanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NarrativeStanceUpdateManyWithWhereWithoutUserInput | NarrativeStanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput> | FriendshipCreateWithoutUserInput[] | FriendshipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserInput | FriendshipCreateOrConnectWithoutUserInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserInput | FriendshipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FriendshipCreateManyUserInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserInput | FriendshipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserInput | FriendshipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendNestedInput = {
    create?: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput> | FriendshipCreateWithoutFriendInput[] | FriendshipUncheckedCreateWithoutFriendInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutFriendInput | FriendshipCreateOrConnectWithoutFriendInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutFriendInput | FriendshipUpsertWithWhereUniqueWithoutFriendInput[]
    createMany?: FriendshipCreateManyFriendInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutFriendInput | FriendshipUpdateWithWhereUniqueWithoutFriendInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutFriendInput | FriendshipUpdateManyWithWhereWithoutFriendInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput> | NarrativeFollowerCreateWithoutUserInput[] | NarrativeFollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutUserInput | NarrativeFollowerCreateOrConnectWithoutUserInput[]
    upsert?: NarrativeFollowerUpsertWithWhereUniqueWithoutUserInput | NarrativeFollowerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NarrativeFollowerCreateManyUserInputEnvelope
    set?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    disconnect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    delete?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    update?: NarrativeFollowerUpdateWithWhereUniqueWithoutUserInput | NarrativeFollowerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NarrativeFollowerUpdateManyWithWhereWithoutUserInput | NarrativeFollowerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
  }

  export type UserMetricUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput> | UserMetricCreateWithoutUserInput[] | UserMetricUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserMetricCreateOrConnectWithoutUserInput | UserMetricCreateOrConnectWithoutUserInput[]
    upsert?: UserMetricUpsertWithWhereUniqueWithoutUserInput | UserMetricUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserMetricCreateManyUserInputEnvelope
    set?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    disconnect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    delete?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    connect?: UserMetricWhereUniqueInput | UserMetricWhereUniqueInput[]
    update?: UserMetricUpdateWithWhereUniqueWithoutUserInput | UserMetricUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserMetricUpdateManyWithWhereWithoutUserInput | UserMetricUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserMetricScalarWhereInput | UserMetricScalarWhereInput[]
  }

  export type SocialPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput> | SocialPostCreateWithoutUserInput[] | SocialPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialPostCreateOrConnectWithoutUserInput | SocialPostCreateOrConnectWithoutUserInput[]
    upsert?: SocialPostUpsertWithWhereUniqueWithoutUserInput | SocialPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialPostCreateManyUserInputEnvelope
    set?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    disconnect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    delete?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    connect?: SocialPostWhereUniqueInput | SocialPostWhereUniqueInput[]
    update?: SocialPostUpdateWithWhereUniqueWithoutUserInput | SocialPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialPostUpdateManyWithWhereWithoutUserInput | SocialPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialPostScalarWhereInput | SocialPostScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput> | PostLikeCreateWithoutUserInput[] | PostLikeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutUserInput | PostLikeCreateOrConnectWithoutUserInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutUserInput | PostLikeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutUserInput | PostLikeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutUserInput | PostLikeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type MarketMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput> | MarketMessageCreateWithoutUserInput[] | MarketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutUserInput | MarketMessageCreateOrConnectWithoutUserInput[]
    upsert?: MarketMessageUpsertWithWhereUniqueWithoutUserInput | MarketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MarketMessageCreateManyUserInputEnvelope
    set?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    disconnect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    delete?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    update?: MarketMessageUpdateWithWhereUniqueWithoutUserInput | MarketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MarketMessageUpdateManyWithWhereWithoutUserInput | MarketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
  }

  export type NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput> | NarrativeStanceCreateWithoutUserInput[] | NarrativeStanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutUserInput | NarrativeStanceCreateOrConnectWithoutUserInput[]
    upsert?: NarrativeStanceUpsertWithWhereUniqueWithoutUserInput | NarrativeStanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NarrativeStanceCreateManyUserInputEnvelope
    set?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    disconnect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    delete?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    update?: NarrativeStanceUpdateWithWhereUniqueWithoutUserInput | NarrativeStanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NarrativeStanceUpdateManyWithWhereWithoutUserInput | NarrativeStanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFriendshipsAsUserInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsUserInput, UserUncheckedCreateWithoutFriendshipsAsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsUserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendshipsAsFriendInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsFriendInput, UserUncheckedCreateWithoutFriendshipsAsFriendInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsFriendInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFriendshipsAsUserNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsUserInput, UserUncheckedCreateWithoutFriendshipsAsUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsUserInput
    upsert?: UserUpsertWithoutFriendshipsAsUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipsAsUserInput, UserUpdateWithoutFriendshipsAsUserInput>, UserUncheckedUpdateWithoutFriendshipsAsUserInput>
  }

  export type UserUpdateOneRequiredWithoutFriendshipsAsFriendNestedInput = {
    create?: XOR<UserCreateWithoutFriendshipsAsFriendInput, UserUncheckedCreateWithoutFriendshipsAsFriendInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendshipsAsFriendInput
    upsert?: UserUpsertWithoutFriendshipsAsFriendInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendshipsAsFriendInput, UserUpdateWithoutFriendshipsAsFriendInput>, UserUncheckedUpdateWithoutFriendshipsAsFriendInput>
  }

  export type UserCreateNestedOneWithoutUserMetricsInput = {
    create?: XOR<UserCreateWithoutUserMetricsInput, UserUncheckedCreateWithoutUserMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserMetricsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserMetricsNestedInput = {
    create?: XOR<UserCreateWithoutUserMetricsInput, UserUncheckedCreateWithoutUserMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserMetricsInput
    upsert?: UserUpsertWithoutUserMetricsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserMetricsInput, UserUpdateWithoutUserMetricsInput>, UserUncheckedUpdateWithoutUserMetricsInput>
  }

  export type NarrativeAssetCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput> | NarrativeAssetCreateWithoutNarrativeInput[] | NarrativeAssetUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeAssetCreateOrConnectWithoutNarrativeInput | NarrativeAssetCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeAssetCreateManyNarrativeInputEnvelope
    connect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
  }

  export type NarrativeEventCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput> | NarrativeEventCreateWithoutNarrativeInput[] | NarrativeEventUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeEventCreateOrConnectWithoutNarrativeInput | NarrativeEventCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeEventCreateManyNarrativeInputEnvelope
    connect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
  }

  export type IngestedPostCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput> | IngestedPostCreateWithoutNarrativeInput[] | IngestedPostUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutNarrativeInput | IngestedPostCreateOrConnectWithoutNarrativeInput[]
    createMany?: IngestedPostCreateManyNarrativeInputEnvelope
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
  }

  export type CommunityPulseCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput> | CommunityPulseCreateWithoutNarrativeInput[] | CommunityPulseUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: CommunityPulseCreateOrConnectWithoutNarrativeInput | CommunityPulseCreateOrConnectWithoutNarrativeInput[]
    createMany?: CommunityPulseCreateManyNarrativeInputEnvelope
    connect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
  }

  export type NarrativeAssetUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput> | NarrativeAssetCreateWithoutNarrativeInput[] | NarrativeAssetUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeAssetCreateOrConnectWithoutNarrativeInput | NarrativeAssetCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeAssetCreateManyNarrativeInputEnvelope
    connect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
  }

  export type NarrativeEventUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput> | NarrativeEventCreateWithoutNarrativeInput[] | NarrativeEventUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeEventCreateOrConnectWithoutNarrativeInput | NarrativeEventCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeEventCreateManyNarrativeInputEnvelope
    connect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
  }

  export type IngestedPostUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput> | IngestedPostCreateWithoutNarrativeInput[] | IngestedPostUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutNarrativeInput | IngestedPostCreateOrConnectWithoutNarrativeInput[]
    createMany?: IngestedPostCreateManyNarrativeInputEnvelope
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
  }

  export type CommunityPulseUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput> | CommunityPulseCreateWithoutNarrativeInput[] | CommunityPulseUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: CommunityPulseCreateOrConnectWithoutNarrativeInput | CommunityPulseCreateOrConnectWithoutNarrativeInput[]
    createMany?: CommunityPulseCreateManyNarrativeInputEnvelope
    connect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
  }

  export type NarrativeAssetUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput> | NarrativeAssetCreateWithoutNarrativeInput[] | NarrativeAssetUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeAssetCreateOrConnectWithoutNarrativeInput | NarrativeAssetCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeAssetUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeAssetUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeAssetCreateManyNarrativeInputEnvelope
    set?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    disconnect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    delete?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    connect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    update?: NarrativeAssetUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeAssetUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeAssetUpdateManyWithWhereWithoutNarrativeInput | NarrativeAssetUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeAssetScalarWhereInput | NarrativeAssetScalarWhereInput[]
  }

  export type NarrativeEventUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput> | NarrativeEventCreateWithoutNarrativeInput[] | NarrativeEventUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeEventCreateOrConnectWithoutNarrativeInput | NarrativeEventCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeEventUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeEventUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeEventCreateManyNarrativeInputEnvelope
    set?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    disconnect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    delete?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    connect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    update?: NarrativeEventUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeEventUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeEventUpdateManyWithWhereWithoutNarrativeInput | NarrativeEventUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeEventScalarWhereInput | NarrativeEventScalarWhereInput[]
  }

  export type IngestedPostUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput> | IngestedPostCreateWithoutNarrativeInput[] | IngestedPostUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutNarrativeInput | IngestedPostCreateOrConnectWithoutNarrativeInput[]
    upsert?: IngestedPostUpsertWithWhereUniqueWithoutNarrativeInput | IngestedPostUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: IngestedPostCreateManyNarrativeInputEnvelope
    set?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    disconnect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    delete?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    update?: IngestedPostUpdateWithWhereUniqueWithoutNarrativeInput | IngestedPostUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: IngestedPostUpdateManyWithWhereWithoutNarrativeInput | IngestedPostUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
  }

  export type CommunityPulseUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput> | CommunityPulseCreateWithoutNarrativeInput[] | CommunityPulseUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: CommunityPulseCreateOrConnectWithoutNarrativeInput | CommunityPulseCreateOrConnectWithoutNarrativeInput[]
    upsert?: CommunityPulseUpsertWithWhereUniqueWithoutNarrativeInput | CommunityPulseUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: CommunityPulseCreateManyNarrativeInputEnvelope
    set?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    disconnect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    delete?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    connect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    update?: CommunityPulseUpdateWithWhereUniqueWithoutNarrativeInput | CommunityPulseUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: CommunityPulseUpdateManyWithWhereWithoutNarrativeInput | CommunityPulseUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: CommunityPulseScalarWhereInput | CommunityPulseScalarWhereInput[]
  }

  export type NarrativeAssetUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput> | NarrativeAssetCreateWithoutNarrativeInput[] | NarrativeAssetUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeAssetCreateOrConnectWithoutNarrativeInput | NarrativeAssetCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeAssetUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeAssetUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeAssetCreateManyNarrativeInputEnvelope
    set?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    disconnect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    delete?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    connect?: NarrativeAssetWhereUniqueInput | NarrativeAssetWhereUniqueInput[]
    update?: NarrativeAssetUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeAssetUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeAssetUpdateManyWithWhereWithoutNarrativeInput | NarrativeAssetUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeAssetScalarWhereInput | NarrativeAssetScalarWhereInput[]
  }

  export type NarrativeEventUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput> | NarrativeEventCreateWithoutNarrativeInput[] | NarrativeEventUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeEventCreateOrConnectWithoutNarrativeInput | NarrativeEventCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeEventUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeEventUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeEventCreateManyNarrativeInputEnvelope
    set?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    disconnect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    delete?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    connect?: NarrativeEventWhereUniqueInput | NarrativeEventWhereUniqueInput[]
    update?: NarrativeEventUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeEventUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeEventUpdateManyWithWhereWithoutNarrativeInput | NarrativeEventUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeEventScalarWhereInput | NarrativeEventScalarWhereInput[]
  }

  export type IngestedPostUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput> | IngestedPostCreateWithoutNarrativeInput[] | IngestedPostUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutNarrativeInput | IngestedPostCreateOrConnectWithoutNarrativeInput[]
    upsert?: IngestedPostUpsertWithWhereUniqueWithoutNarrativeInput | IngestedPostUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: IngestedPostCreateManyNarrativeInputEnvelope
    set?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    disconnect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    delete?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    update?: IngestedPostUpdateWithWhereUniqueWithoutNarrativeInput | IngestedPostUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: IngestedPostUpdateManyWithWhereWithoutNarrativeInput | IngestedPostUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
  }

  export type CommunityPulseUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput> | CommunityPulseCreateWithoutNarrativeInput[] | CommunityPulseUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: CommunityPulseCreateOrConnectWithoutNarrativeInput | CommunityPulseCreateOrConnectWithoutNarrativeInput[]
    upsert?: CommunityPulseUpsertWithWhereUniqueWithoutNarrativeInput | CommunityPulseUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: CommunityPulseCreateManyNarrativeInputEnvelope
    set?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    disconnect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    delete?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    connect?: CommunityPulseWhereUniqueInput | CommunityPulseWhereUniqueInput[]
    update?: CommunityPulseUpdateWithWhereUniqueWithoutNarrativeInput | CommunityPulseUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: CommunityPulseUpdateManyWithWhereWithoutNarrativeInput | CommunityPulseUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: CommunityPulseScalarWhereInput | CommunityPulseScalarWhereInput[]
  }

  export type NarrativeCreateNestedOneWithoutAssetsInput = {
    create?: XOR<NarrativeCreateWithoutAssetsInput, NarrativeUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutAssetsInput
    connect?: NarrativeWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NarrativeUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<NarrativeCreateWithoutAssetsInput, NarrativeUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutAssetsInput
    upsert?: NarrativeUpsertWithoutAssetsInput
    connect?: NarrativeWhereUniqueInput
    update?: XOR<XOR<NarrativeUpdateToOneWithWhereWithoutAssetsInput, NarrativeUpdateWithoutAssetsInput>, NarrativeUncheckedUpdateWithoutAssetsInput>
  }

  export type NarrativeCreateNestedOneWithoutEventsInput = {
    create?: XOR<NarrativeCreateWithoutEventsInput, NarrativeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutEventsInput
    connect?: NarrativeWhereUniqueInput
  }

  export type NarrativeUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<NarrativeCreateWithoutEventsInput, NarrativeUncheckedCreateWithoutEventsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutEventsInput
    upsert?: NarrativeUpsertWithoutEventsInput
    connect?: NarrativeWhereUniqueInput
    update?: XOR<XOR<NarrativeUpdateToOneWithWhereWithoutEventsInput, NarrativeUpdateWithoutEventsInput>, NarrativeUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutSocialPostsInput = {
    create?: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostTickerCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput> | PostTickerCreateWithoutPostInput[] | PostTickerUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTickerCreateOrConnectWithoutPostInput | PostTickerCreateOrConnectWithoutPostInput[]
    createMany?: PostTickerCreateManyPostInputEnvelope
    connect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
  }

  export type PostLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type PostTickerUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput> | PostTickerCreateWithoutPostInput[] | PostTickerUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTickerCreateOrConnectWithoutPostInput | PostTickerCreateOrConnectWithoutPostInput[]
    createMany?: PostTickerCreateManyPostInputEnvelope
    connect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
  }

  export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSocialPostsNestedInput = {
    create?: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialPostsInput
    upsert?: UserUpsertWithoutSocialPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialPostsInput, UserUpdateWithoutSocialPostsInput>, UserUncheckedUpdateWithoutSocialPostsInput>
  }

  export type PostTickerUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput> | PostTickerCreateWithoutPostInput[] | PostTickerUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTickerCreateOrConnectWithoutPostInput | PostTickerCreateOrConnectWithoutPostInput[]
    upsert?: PostTickerUpsertWithWhereUniqueWithoutPostInput | PostTickerUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTickerCreateManyPostInputEnvelope
    set?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    disconnect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    delete?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    connect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    update?: PostTickerUpdateWithWhereUniqueWithoutPostInput | PostTickerUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTickerUpdateManyWithWhereWithoutPostInput | PostTickerUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTickerScalarWhereInput | PostTickerScalarWhereInput[]
  }

  export type PostLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type PostTickerUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput> | PostTickerCreateWithoutPostInput[] | PostTickerUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTickerCreateOrConnectWithoutPostInput | PostTickerCreateOrConnectWithoutPostInput[]
    upsert?: PostTickerUpsertWithWhereUniqueWithoutPostInput | PostTickerUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTickerCreateManyPostInputEnvelope
    set?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    disconnect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    delete?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    connect?: PostTickerWhereUniqueInput | PostTickerWhereUniqueInput[]
    update?: PostTickerUpdateWithWhereUniqueWithoutPostInput | PostTickerUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTickerUpdateManyWithWhereWithoutPostInput | PostTickerUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTickerScalarWhereInput | PostTickerScalarWhereInput[]
  }

  export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput> | PostLikeCreateWithoutPostInput[] | PostLikeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostLikeCreateOrConnectWithoutPostInput | PostLikeCreateOrConnectWithoutPostInput[]
    upsert?: PostLikeUpsertWithWhereUniqueWithoutPostInput | PostLikeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    disconnect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    delete?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    connect?: PostLikeWhereUniqueInput | PostLikeWhereUniqueInput[]
    update?: PostLikeUpdateWithWhereUniqueWithoutPostInput | PostLikeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostLikeUpdateManyWithWhereWithoutPostInput | PostLikeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
  }

  export type SocialPostCreateNestedOneWithoutTickersInput = {
    create?: XOR<SocialPostCreateWithoutTickersInput, SocialPostUncheckedCreateWithoutTickersInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutTickersInput
    connect?: SocialPostWhereUniqueInput
  }

  export type SocialPostUpdateOneRequiredWithoutTickersNestedInput = {
    create?: XOR<SocialPostCreateWithoutTickersInput, SocialPostUncheckedCreateWithoutTickersInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutTickersInput
    upsert?: SocialPostUpsertWithoutTickersInput
    connect?: SocialPostWhereUniqueInput
    update?: XOR<XOR<SocialPostUpdateToOneWithWhereWithoutTickersInput, SocialPostUpdateWithoutTickersInput>, SocialPostUncheckedUpdateWithoutTickersInput>
  }

  export type SocialPostCreateNestedOneWithoutLikesInput = {
    create?: XOR<SocialPostCreateWithoutLikesInput, SocialPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutLikesInput
    connect?: SocialPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    connect?: UserWhereUniqueInput
  }

  export type SocialPostUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<SocialPostCreateWithoutLikesInput, SocialPostUncheckedCreateWithoutLikesInput>
    connectOrCreate?: SocialPostCreateOrConnectWithoutLikesInput
    upsert?: SocialPostUpsertWithoutLikesInput
    connect?: SocialPostWhereUniqueInput
    update?: XOR<XOR<SocialPostUpdateToOneWithWhereWithoutLikesInput, SocialPostUpdateWithoutLikesInput>, SocialPostUncheckedUpdateWithoutLikesInput>
  }

  export type UserUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    upsert?: UserUpsertWithoutPostLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostLikesInput, UserUpdateWithoutPostLikesInput>, UserUncheckedUpdateWithoutPostLikesInput>
  }

  export type IngestedPostCreateNestedManyWithoutAccountInput = {
    create?: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput> | IngestedPostCreateWithoutAccountInput[] | IngestedPostUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutAccountInput | IngestedPostCreateOrConnectWithoutAccountInput[]
    createMany?: IngestedPostCreateManyAccountInputEnvelope
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
  }

  export type IngestedPostUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput> | IngestedPostCreateWithoutAccountInput[] | IngestedPostUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutAccountInput | IngestedPostCreateOrConnectWithoutAccountInput[]
    createMany?: IngestedPostCreateManyAccountInputEnvelope
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IngestedPostUpdateManyWithoutAccountNestedInput = {
    create?: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput> | IngestedPostCreateWithoutAccountInput[] | IngestedPostUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutAccountInput | IngestedPostCreateOrConnectWithoutAccountInput[]
    upsert?: IngestedPostUpsertWithWhereUniqueWithoutAccountInput | IngestedPostUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: IngestedPostCreateManyAccountInputEnvelope
    set?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    disconnect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    delete?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    update?: IngestedPostUpdateWithWhereUniqueWithoutAccountInput | IngestedPostUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: IngestedPostUpdateManyWithWhereWithoutAccountInput | IngestedPostUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
  }

  export type IngestedPostUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput> | IngestedPostCreateWithoutAccountInput[] | IngestedPostUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: IngestedPostCreateOrConnectWithoutAccountInput | IngestedPostCreateOrConnectWithoutAccountInput[]
    upsert?: IngestedPostUpsertWithWhereUniqueWithoutAccountInput | IngestedPostUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: IngestedPostCreateManyAccountInputEnvelope
    set?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    disconnect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    delete?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    connect?: IngestedPostWhereUniqueInput | IngestedPostWhereUniqueInput[]
    update?: IngestedPostUpdateWithWhereUniqueWithoutAccountInput | IngestedPostUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: IngestedPostUpdateManyWithWhereWithoutAccountInput | IngestedPostUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
  }

  export type TrackedAccountCreateNestedOneWithoutPostsInput = {
    create?: XOR<TrackedAccountCreateWithoutPostsInput, TrackedAccountUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TrackedAccountCreateOrConnectWithoutPostsInput
    connect?: TrackedAccountWhereUniqueInput
  }

  export type NarrativeCreateNestedOneWithoutPostsInput = {
    create?: XOR<NarrativeCreateWithoutPostsInput, NarrativeUncheckedCreateWithoutPostsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutPostsInput
    connect?: NarrativeWhereUniqueInput
  }

  export type TrackedAccountUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TrackedAccountCreateWithoutPostsInput, TrackedAccountUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TrackedAccountCreateOrConnectWithoutPostsInput
    upsert?: TrackedAccountUpsertWithoutPostsInput
    connect?: TrackedAccountWhereUniqueInput
    update?: XOR<XOR<TrackedAccountUpdateToOneWithWhereWithoutPostsInput, TrackedAccountUpdateWithoutPostsInput>, TrackedAccountUncheckedUpdateWithoutPostsInput>
  }

  export type NarrativeUpdateOneWithoutPostsNestedInput = {
    create?: XOR<NarrativeCreateWithoutPostsInput, NarrativeUncheckedCreateWithoutPostsInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutPostsInput
    upsert?: NarrativeUpsertWithoutPostsInput
    disconnect?: NarrativeWhereInput | boolean
    delete?: NarrativeWhereInput | boolean
    connect?: NarrativeWhereUniqueInput
    update?: XOR<XOR<NarrativeUpdateToOneWithWhereWithoutPostsInput, NarrativeUpdateWithoutPostsInput>, NarrativeUncheckedUpdateWithoutPostsInput>
  }

  export type NarrativeCreateNestedOneWithoutPulseInput = {
    create?: XOR<NarrativeCreateWithoutPulseInput, NarrativeUncheckedCreateWithoutPulseInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutPulseInput
    connect?: NarrativeWhereUniqueInput
  }

  export type NarrativeUpdateOneWithoutPulseNestedInput = {
    create?: XOR<NarrativeCreateWithoutPulseInput, NarrativeUncheckedCreateWithoutPulseInput>
    connectOrCreate?: NarrativeCreateOrConnectWithoutPulseInput
    upsert?: NarrativeUpsertWithoutPulseInput
    disconnect?: NarrativeWhereInput | boolean
    delete?: NarrativeWhereInput | boolean
    connect?: NarrativeWhereUniqueInput
    update?: XOR<XOR<NarrativeUpdateToOneWithWhereWithoutPulseInput, NarrativeUpdateWithoutPulseInput>, NarrativeUncheckedUpdateWithoutPulseInput>
  }

  export type DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput> | DetectedNarrativeArticleCreateWithoutNarrativeInput[] | DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput | DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput[]
    createMany?: DetectedNarrativeArticleCreateManyNarrativeInputEnvelope
    connect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
  }

  export type NarrativeMetricCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput> | NarrativeMetricCreateWithoutNarrativeInput[] | NarrativeMetricUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeMetricCreateOrConnectWithoutNarrativeInput | NarrativeMetricCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeMetricCreateManyNarrativeInputEnvelope
    connect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
  }

  export type NarrativeFollowerCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput> | NarrativeFollowerCreateWithoutNarrativeInput[] | NarrativeFollowerUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutNarrativeInput | NarrativeFollowerCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeFollowerCreateManyNarrativeInputEnvelope
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
  }

  export type MarketMessageCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput> | MarketMessageCreateWithoutNarrativeInput[] | MarketMessageUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutNarrativeInput | MarketMessageCreateOrConnectWithoutNarrativeInput[]
    createMany?: MarketMessageCreateManyNarrativeInputEnvelope
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
  }

  export type NarrativeStanceCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput> | NarrativeStanceCreateWithoutNarrativeInput[] | NarrativeStanceUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutNarrativeInput | NarrativeStanceCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeStanceCreateManyNarrativeInputEnvelope
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
  }

  export type DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput> | DetectedNarrativeArticleCreateWithoutNarrativeInput[] | DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput | DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput[]
    createMany?: DetectedNarrativeArticleCreateManyNarrativeInputEnvelope
    connect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
  }

  export type NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput> | NarrativeMetricCreateWithoutNarrativeInput[] | NarrativeMetricUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeMetricCreateOrConnectWithoutNarrativeInput | NarrativeMetricCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeMetricCreateManyNarrativeInputEnvelope
    connect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
  }

  export type NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput> | NarrativeFollowerCreateWithoutNarrativeInput[] | NarrativeFollowerUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutNarrativeInput | NarrativeFollowerCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeFollowerCreateManyNarrativeInputEnvelope
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
  }

  export type MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput> | MarketMessageCreateWithoutNarrativeInput[] | MarketMessageUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutNarrativeInput | MarketMessageCreateOrConnectWithoutNarrativeInput[]
    createMany?: MarketMessageCreateManyNarrativeInputEnvelope
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
  }

  export type NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput = {
    create?: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput> | NarrativeStanceCreateWithoutNarrativeInput[] | NarrativeStanceUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutNarrativeInput | NarrativeStanceCreateOrConnectWithoutNarrativeInput[]
    createMany?: NarrativeStanceCreateManyNarrativeInputEnvelope
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
  }

  export type DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput> | DetectedNarrativeArticleCreateWithoutNarrativeInput[] | DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput | DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput[]
    upsert?: DetectedNarrativeArticleUpsertWithWhereUniqueWithoutNarrativeInput | DetectedNarrativeArticleUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: DetectedNarrativeArticleCreateManyNarrativeInputEnvelope
    set?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    disconnect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    delete?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    connect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    update?: DetectedNarrativeArticleUpdateWithWhereUniqueWithoutNarrativeInput | DetectedNarrativeArticleUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: DetectedNarrativeArticleUpdateManyWithWhereWithoutNarrativeInput | DetectedNarrativeArticleUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: DetectedNarrativeArticleScalarWhereInput | DetectedNarrativeArticleScalarWhereInput[]
  }

  export type NarrativeMetricUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput> | NarrativeMetricCreateWithoutNarrativeInput[] | NarrativeMetricUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeMetricCreateOrConnectWithoutNarrativeInput | NarrativeMetricCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeMetricUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeMetricUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeMetricCreateManyNarrativeInputEnvelope
    set?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    disconnect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    delete?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    connect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    update?: NarrativeMetricUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeMetricUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeMetricUpdateManyWithWhereWithoutNarrativeInput | NarrativeMetricUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeMetricScalarWhereInput | NarrativeMetricScalarWhereInput[]
  }

  export type NarrativeFollowerUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput> | NarrativeFollowerCreateWithoutNarrativeInput[] | NarrativeFollowerUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutNarrativeInput | NarrativeFollowerCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeFollowerUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeFollowerUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeFollowerCreateManyNarrativeInputEnvelope
    set?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    disconnect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    delete?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    update?: NarrativeFollowerUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeFollowerUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeFollowerUpdateManyWithWhereWithoutNarrativeInput | NarrativeFollowerUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
  }

  export type MarketMessageUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput> | MarketMessageCreateWithoutNarrativeInput[] | MarketMessageUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutNarrativeInput | MarketMessageCreateOrConnectWithoutNarrativeInput[]
    upsert?: MarketMessageUpsertWithWhereUniqueWithoutNarrativeInput | MarketMessageUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: MarketMessageCreateManyNarrativeInputEnvelope
    set?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    disconnect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    delete?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    update?: MarketMessageUpdateWithWhereUniqueWithoutNarrativeInput | MarketMessageUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: MarketMessageUpdateManyWithWhereWithoutNarrativeInput | MarketMessageUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
  }

  export type NarrativeStanceUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput> | NarrativeStanceCreateWithoutNarrativeInput[] | NarrativeStanceUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutNarrativeInput | NarrativeStanceCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeStanceUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeStanceUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeStanceCreateManyNarrativeInputEnvelope
    set?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    disconnect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    delete?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    update?: NarrativeStanceUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeStanceUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeStanceUpdateManyWithWhereWithoutNarrativeInput | NarrativeStanceUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
  }

  export type DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput> | DetectedNarrativeArticleCreateWithoutNarrativeInput[] | DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput | DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput[]
    upsert?: DetectedNarrativeArticleUpsertWithWhereUniqueWithoutNarrativeInput | DetectedNarrativeArticleUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: DetectedNarrativeArticleCreateManyNarrativeInputEnvelope
    set?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    disconnect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    delete?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    connect?: DetectedNarrativeArticleWhereUniqueInput | DetectedNarrativeArticleWhereUniqueInput[]
    update?: DetectedNarrativeArticleUpdateWithWhereUniqueWithoutNarrativeInput | DetectedNarrativeArticleUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: DetectedNarrativeArticleUpdateManyWithWhereWithoutNarrativeInput | DetectedNarrativeArticleUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: DetectedNarrativeArticleScalarWhereInput | DetectedNarrativeArticleScalarWhereInput[]
  }

  export type NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput> | NarrativeMetricCreateWithoutNarrativeInput[] | NarrativeMetricUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeMetricCreateOrConnectWithoutNarrativeInput | NarrativeMetricCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeMetricUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeMetricUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeMetricCreateManyNarrativeInputEnvelope
    set?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    disconnect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    delete?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    connect?: NarrativeMetricWhereUniqueInput | NarrativeMetricWhereUniqueInput[]
    update?: NarrativeMetricUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeMetricUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeMetricUpdateManyWithWhereWithoutNarrativeInput | NarrativeMetricUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeMetricScalarWhereInput | NarrativeMetricScalarWhereInput[]
  }

  export type NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput> | NarrativeFollowerCreateWithoutNarrativeInput[] | NarrativeFollowerUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeFollowerCreateOrConnectWithoutNarrativeInput | NarrativeFollowerCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeFollowerUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeFollowerUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeFollowerCreateManyNarrativeInputEnvelope
    set?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    disconnect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    delete?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    connect?: NarrativeFollowerWhereUniqueInput | NarrativeFollowerWhereUniqueInput[]
    update?: NarrativeFollowerUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeFollowerUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeFollowerUpdateManyWithWhereWithoutNarrativeInput | NarrativeFollowerUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
  }

  export type MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput> | MarketMessageCreateWithoutNarrativeInput[] | MarketMessageUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: MarketMessageCreateOrConnectWithoutNarrativeInput | MarketMessageCreateOrConnectWithoutNarrativeInput[]
    upsert?: MarketMessageUpsertWithWhereUniqueWithoutNarrativeInput | MarketMessageUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: MarketMessageCreateManyNarrativeInputEnvelope
    set?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    disconnect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    delete?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    connect?: MarketMessageWhereUniqueInput | MarketMessageWhereUniqueInput[]
    update?: MarketMessageUpdateWithWhereUniqueWithoutNarrativeInput | MarketMessageUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: MarketMessageUpdateManyWithWhereWithoutNarrativeInput | MarketMessageUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
  }

  export type NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput = {
    create?: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput> | NarrativeStanceCreateWithoutNarrativeInput[] | NarrativeStanceUncheckedCreateWithoutNarrativeInput[]
    connectOrCreate?: NarrativeStanceCreateOrConnectWithoutNarrativeInput | NarrativeStanceCreateOrConnectWithoutNarrativeInput[]
    upsert?: NarrativeStanceUpsertWithWhereUniqueWithoutNarrativeInput | NarrativeStanceUpsertWithWhereUniqueWithoutNarrativeInput[]
    createMany?: NarrativeStanceCreateManyNarrativeInputEnvelope
    set?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    disconnect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    delete?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    connect?: NarrativeStanceWhereUniqueInput | NarrativeStanceWhereUniqueInput[]
    update?: NarrativeStanceUpdateWithWhereUniqueWithoutNarrativeInput | NarrativeStanceUpdateWithWhereUniqueWithoutNarrativeInput[]
    updateMany?: NarrativeStanceUpdateManyWithWhereWithoutNarrativeInput | NarrativeStanceUpdateManyWithWhereWithoutNarrativeInput[]
    deleteMany?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
  }

  export type DetectedNarrativeCreateNestedOneWithoutMessagesInput = {
    create?: XOR<DetectedNarrativeCreateWithoutMessagesInput, DetectedNarrativeUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutMessagesInput
    connect?: DetectedNarrativeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMarketMessagesInput = {
    create?: XOR<UserCreateWithoutMarketMessagesInput, UserUncheckedCreateWithoutMarketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type DetectedNarrativeUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<DetectedNarrativeCreateWithoutMessagesInput, DetectedNarrativeUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutMessagesInput
    upsert?: DetectedNarrativeUpsertWithoutMessagesInput
    connect?: DetectedNarrativeWhereUniqueInput
    update?: XOR<XOR<DetectedNarrativeUpdateToOneWithWhereWithoutMessagesInput, DetectedNarrativeUpdateWithoutMessagesInput>, DetectedNarrativeUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMarketMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMarketMessagesInput, UserUncheckedCreateWithoutMarketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarketMessagesInput
    upsert?: UserUpsertWithoutMarketMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMarketMessagesInput, UserUpdateWithoutMarketMessagesInput>, UserUncheckedUpdateWithoutMarketMessagesInput>
  }

  export type UserCreateNestedOneWithoutNarrativeFollowersInput = {
    create?: XOR<UserCreateWithoutNarrativeFollowersInput, UserUncheckedCreateWithoutNarrativeFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNarrativeFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type DetectedNarrativeCreateNestedOneWithoutFollowersInput = {
    create?: XOR<DetectedNarrativeCreateWithoutFollowersInput, DetectedNarrativeUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutFollowersInput
    connect?: DetectedNarrativeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNarrativeFollowersNestedInput = {
    create?: XOR<UserCreateWithoutNarrativeFollowersInput, UserUncheckedCreateWithoutNarrativeFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutNarrativeFollowersInput
    upsert?: UserUpsertWithoutNarrativeFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNarrativeFollowersInput, UserUpdateWithoutNarrativeFollowersInput>, UserUncheckedUpdateWithoutNarrativeFollowersInput>
  }

  export type DetectedNarrativeUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<DetectedNarrativeCreateWithoutFollowersInput, DetectedNarrativeUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutFollowersInput
    upsert?: DetectedNarrativeUpsertWithoutFollowersInput
    connect?: DetectedNarrativeWhereUniqueInput
    update?: XOR<XOR<DetectedNarrativeUpdateToOneWithWhereWithoutFollowersInput, DetectedNarrativeUpdateWithoutFollowersInput>, DetectedNarrativeUncheckedUpdateWithoutFollowersInput>
  }

  export type DetectedNarrativeCreateNestedOneWithoutMetricsInput = {
    create?: XOR<DetectedNarrativeCreateWithoutMetricsInput, DetectedNarrativeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutMetricsInput
    connect?: DetectedNarrativeWhereUniqueInput
  }

  export type DetectedNarrativeUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<DetectedNarrativeCreateWithoutMetricsInput, DetectedNarrativeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutMetricsInput
    upsert?: DetectedNarrativeUpsertWithoutMetricsInput
    connect?: DetectedNarrativeWhereUniqueInput
    update?: XOR<XOR<DetectedNarrativeUpdateToOneWithWhereWithoutMetricsInput, DetectedNarrativeUpdateWithoutMetricsInput>, DetectedNarrativeUncheckedUpdateWithoutMetricsInput>
  }

  export type DetectedNarrativeCreateNestedOneWithoutArticlesInput = {
    create?: XOR<DetectedNarrativeCreateWithoutArticlesInput, DetectedNarrativeUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutArticlesInput
    connect?: DetectedNarrativeWhereUniqueInput
  }

  export type DetectedNarrativeUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<DetectedNarrativeCreateWithoutArticlesInput, DetectedNarrativeUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutArticlesInput
    upsert?: DetectedNarrativeUpsertWithoutArticlesInput
    connect?: DetectedNarrativeWhereUniqueInput
    update?: XOR<XOR<DetectedNarrativeUpdateToOneWithWhereWithoutArticlesInput, DetectedNarrativeUpdateWithoutArticlesInput>, DetectedNarrativeUncheckedUpdateWithoutArticlesInput>
  }

  export type DetectedNarrativeCreateNestedOneWithoutStancesInput = {
    create?: XOR<DetectedNarrativeCreateWithoutStancesInput, DetectedNarrativeUncheckedCreateWithoutStancesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutStancesInput
    connect?: DetectedNarrativeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNarrativeStancesInput = {
    create?: XOR<UserCreateWithoutNarrativeStancesInput, UserUncheckedCreateWithoutNarrativeStancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNarrativeStancesInput
    connect?: UserWhereUniqueInput
  }

  export type DetectedNarrativeUpdateOneRequiredWithoutStancesNestedInput = {
    create?: XOR<DetectedNarrativeCreateWithoutStancesInput, DetectedNarrativeUncheckedCreateWithoutStancesInput>
    connectOrCreate?: DetectedNarrativeCreateOrConnectWithoutStancesInput
    upsert?: DetectedNarrativeUpsertWithoutStancesInput
    connect?: DetectedNarrativeWhereUniqueInput
    update?: XOR<XOR<DetectedNarrativeUpdateToOneWithWhereWithoutStancesInput, DetectedNarrativeUpdateWithoutStancesInput>, DetectedNarrativeUncheckedUpdateWithoutStancesInput>
  }

  export type UserUpdateOneRequiredWithoutNarrativeStancesNestedInput = {
    create?: XOR<UserCreateWithoutNarrativeStancesInput, UserUncheckedCreateWithoutNarrativeStancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNarrativeStancesInput
    upsert?: UserUpsertWithoutNarrativeStancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNarrativeStancesInput, UserUpdateWithoutNarrativeStancesInput>, UserUncheckedUpdateWithoutNarrativeStancesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FriendshipCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    friend: UserCreateNestedOneWithoutFriendshipsAsFriendInput
  }

  export type FriendshipUncheckedCreateWithoutUserInput = {
    id?: string
    friendId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipCreateManyUserInputEnvelope = {
    data: FriendshipCreateManyUserInput | FriendshipCreateManyUserInput[]
  }

  export type FriendshipCreateWithoutFriendInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFriendshipsAsUserInput
  }

  export type FriendshipUncheckedCreateWithoutFriendInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipCreateManyFriendInputEnvelope = {
    data: FriendshipCreateManyFriendInput | FriendshipCreateManyFriendInput[]
  }

  export type NarrativeFollowerCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutFollowersInput
  }

  export type NarrativeFollowerUncheckedCreateWithoutUserInput = {
    id?: string
    narrativeId: string
    createdAt?: Date | string
  }

  export type NarrativeFollowerCreateOrConnectWithoutUserInput = {
    where: NarrativeFollowerWhereUniqueInput
    create: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput>
  }

  export type NarrativeFollowerCreateManyUserInputEnvelope = {
    data: NarrativeFollowerCreateManyUserInput | NarrativeFollowerCreateManyUserInput[]
  }

  export type UserMetricCreateWithoutUserInput = {
    id?: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
  }

  export type UserMetricUncheckedCreateWithoutUserInput = {
    id?: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
  }

  export type UserMetricCreateOrConnectWithoutUserInput = {
    where: UserMetricWhereUniqueInput
    create: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput>
  }

  export type UserMetricCreateManyUserInputEnvelope = {
    data: UserMetricCreateManyUserInput | UserMetricCreateManyUserInput[]
  }

  export type SocialPostCreateWithoutUserInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickers?: PostTickerCreateNestedManyWithoutPostInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickers?: PostTickerUncheckedCreateNestedManyWithoutPostInput
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostCreateOrConnectWithoutUserInput = {
    where: SocialPostWhereUniqueInput
    create: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput>
  }

  export type SocialPostCreateManyUserInputEnvelope = {
    data: SocialPostCreateManyUserInput | SocialPostCreateManyUserInput[]
  }

  export type PostLikeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    post: SocialPostCreateNestedOneWithoutLikesInput
  }

  export type PostLikeUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type PostLikeCreateOrConnectWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeCreateManyUserInputEnvelope = {
    data: PostLikeCreateManyUserInput | PostLikeCreateManyUserInput[]
  }

  export type MarketMessageCreateWithoutUserInput = {
    id?: string
    text: string
    createdAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutMessagesInput
  }

  export type MarketMessageUncheckedCreateWithoutUserInput = {
    id?: string
    narrativeId: string
    text: string
    createdAt?: Date | string
  }

  export type MarketMessageCreateOrConnectWithoutUserInput = {
    where: MarketMessageWhereUniqueInput
    create: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput>
  }

  export type MarketMessageCreateManyUserInputEnvelope = {
    data: MarketMessageCreateManyUserInput | MarketMessageCreateManyUserInput[]
  }

  export type NarrativeStanceCreateWithoutUserInput = {
    id?: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    narrative: DetectedNarrativeCreateNestedOneWithoutStancesInput
  }

  export type NarrativeStanceUncheckedCreateWithoutUserInput = {
    id?: string
    narrativeId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NarrativeStanceCreateOrConnectWithoutUserInput = {
    where: NarrativeStanceWhereUniqueInput
    create: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput>
  }

  export type NarrativeStanceCreateManyUserInputEnvelope = {
    data: NarrativeStanceCreateManyUserInput | NarrativeStanceCreateManyUserInput[]
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
    create: XOR<FriendshipCreateWithoutUserInput, FriendshipUncheckedCreateWithoutUserInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserInput, FriendshipUncheckedUpdateWithoutUserInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: StringFilter<"Friendship"> | string
    userId?: StringFilter<"Friendship"> | string
    friendId?: StringFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
    create: XOR<FriendshipCreateWithoutFriendInput, FriendshipUncheckedCreateWithoutFriendInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutFriendInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutFriendInput, FriendshipUncheckedUpdateWithoutFriendInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutFriendInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutFriendInput>
  }

  export type NarrativeFollowerUpsertWithWhereUniqueWithoutUserInput = {
    where: NarrativeFollowerWhereUniqueInput
    update: XOR<NarrativeFollowerUpdateWithoutUserInput, NarrativeFollowerUncheckedUpdateWithoutUserInput>
    create: XOR<NarrativeFollowerCreateWithoutUserInput, NarrativeFollowerUncheckedCreateWithoutUserInput>
  }

  export type NarrativeFollowerUpdateWithWhereUniqueWithoutUserInput = {
    where: NarrativeFollowerWhereUniqueInput
    data: XOR<NarrativeFollowerUpdateWithoutUserInput, NarrativeFollowerUncheckedUpdateWithoutUserInput>
  }

  export type NarrativeFollowerUpdateManyWithWhereWithoutUserInput = {
    where: NarrativeFollowerScalarWhereInput
    data: XOR<NarrativeFollowerUpdateManyMutationInput, NarrativeFollowerUncheckedUpdateManyWithoutUserInput>
  }

  export type NarrativeFollowerScalarWhereInput = {
    AND?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
    OR?: NarrativeFollowerScalarWhereInput[]
    NOT?: NarrativeFollowerScalarWhereInput | NarrativeFollowerScalarWhereInput[]
    id?: StringFilter<"NarrativeFollower"> | string
    userId?: StringFilter<"NarrativeFollower"> | string
    narrativeId?: StringFilter<"NarrativeFollower"> | string
    createdAt?: DateTimeFilter<"NarrativeFollower"> | Date | string
  }

  export type UserMetricUpsertWithWhereUniqueWithoutUserInput = {
    where: UserMetricWhereUniqueInput
    update: XOR<UserMetricUpdateWithoutUserInput, UserMetricUncheckedUpdateWithoutUserInput>
    create: XOR<UserMetricCreateWithoutUserInput, UserMetricUncheckedCreateWithoutUserInput>
  }

  export type UserMetricUpdateWithWhereUniqueWithoutUserInput = {
    where: UserMetricWhereUniqueInput
    data: XOR<UserMetricUpdateWithoutUserInput, UserMetricUncheckedUpdateWithoutUserInput>
  }

  export type UserMetricUpdateManyWithWhereWithoutUserInput = {
    where: UserMetricScalarWhereInput
    data: XOR<UserMetricUpdateManyMutationInput, UserMetricUncheckedUpdateManyWithoutUserInput>
  }

  export type UserMetricScalarWhereInput = {
    AND?: UserMetricScalarWhereInput | UserMetricScalarWhereInput[]
    OR?: UserMetricScalarWhereInput[]
    NOT?: UserMetricScalarWhereInput | UserMetricScalarWhereInput[]
    id?: StringFilter<"UserMetric"> | string
    userId?: StringFilter<"UserMetric"> | string
    period?: StringFilter<"UserMetric"> | string
    returnPercent?: FloatFilter<"UserMetric"> | number
    winRate?: FloatFilter<"UserMetric"> | number
    tradesCount?: IntFilter<"UserMetric"> | number
    calculatedAt?: DateTimeFilter<"UserMetric"> | Date | string
  }

  export type SocialPostUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialPostWhereUniqueInput
    update: XOR<SocialPostUpdateWithoutUserInput, SocialPostUncheckedUpdateWithoutUserInput>
    create: XOR<SocialPostCreateWithoutUserInput, SocialPostUncheckedCreateWithoutUserInput>
  }

  export type SocialPostUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialPostWhereUniqueInput
    data: XOR<SocialPostUpdateWithoutUserInput, SocialPostUncheckedUpdateWithoutUserInput>
  }

  export type SocialPostUpdateManyWithWhereWithoutUserInput = {
    where: SocialPostScalarWhereInput
    data: XOR<SocialPostUpdateManyMutationInput, SocialPostUncheckedUpdateManyWithoutUserInput>
  }

  export type SocialPostScalarWhereInput = {
    AND?: SocialPostScalarWhereInput | SocialPostScalarWhereInput[]
    OR?: SocialPostScalarWhereInput[]
    NOT?: SocialPostScalarWhereInput | SocialPostScalarWhereInput[]
    id?: StringFilter<"SocialPost"> | string
    userId?: StringFilter<"SocialPost"> | string
    content?: StringFilter<"SocialPost"> | string
    sentiment?: StringFilter<"SocialPost"> | string
    likesCount?: IntFilter<"SocialPost"> | number
    createdAt?: DateTimeFilter<"SocialPost"> | Date | string
    updatedAt?: DateTimeFilter<"SocialPost"> | Date | string
  }

  export type PostLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutUserInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutUserInput>
  }

  export type PostLikeScalarWhereInput = {
    AND?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    OR?: PostLikeScalarWhereInput[]
    NOT?: PostLikeScalarWhereInput | PostLikeScalarWhereInput[]
    id?: StringFilter<"PostLike"> | string
    postId?: StringFilter<"PostLike"> | string
    userId?: StringFilter<"PostLike"> | string
    createdAt?: DateTimeFilter<"PostLike"> | Date | string
  }

  export type MarketMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MarketMessageWhereUniqueInput
    update: XOR<MarketMessageUpdateWithoutUserInput, MarketMessageUncheckedUpdateWithoutUserInput>
    create: XOR<MarketMessageCreateWithoutUserInput, MarketMessageUncheckedCreateWithoutUserInput>
  }

  export type MarketMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MarketMessageWhereUniqueInput
    data: XOR<MarketMessageUpdateWithoutUserInput, MarketMessageUncheckedUpdateWithoutUserInput>
  }

  export type MarketMessageUpdateManyWithWhereWithoutUserInput = {
    where: MarketMessageScalarWhereInput
    data: XOR<MarketMessageUpdateManyMutationInput, MarketMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MarketMessageScalarWhereInput = {
    AND?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
    OR?: MarketMessageScalarWhereInput[]
    NOT?: MarketMessageScalarWhereInput | MarketMessageScalarWhereInput[]
    id?: StringFilter<"MarketMessage"> | string
    narrativeId?: StringFilter<"MarketMessage"> | string
    userId?: StringFilter<"MarketMessage"> | string
    text?: StringFilter<"MarketMessage"> | string
    createdAt?: DateTimeFilter<"MarketMessage"> | Date | string
  }

  export type NarrativeStanceUpsertWithWhereUniqueWithoutUserInput = {
    where: NarrativeStanceWhereUniqueInput
    update: XOR<NarrativeStanceUpdateWithoutUserInput, NarrativeStanceUncheckedUpdateWithoutUserInput>
    create: XOR<NarrativeStanceCreateWithoutUserInput, NarrativeStanceUncheckedCreateWithoutUserInput>
  }

  export type NarrativeStanceUpdateWithWhereUniqueWithoutUserInput = {
    where: NarrativeStanceWhereUniqueInput
    data: XOR<NarrativeStanceUpdateWithoutUserInput, NarrativeStanceUncheckedUpdateWithoutUserInput>
  }

  export type NarrativeStanceUpdateManyWithWhereWithoutUserInput = {
    where: NarrativeStanceScalarWhereInput
    data: XOR<NarrativeStanceUpdateManyMutationInput, NarrativeStanceUncheckedUpdateManyWithoutUserInput>
  }

  export type NarrativeStanceScalarWhereInput = {
    AND?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
    OR?: NarrativeStanceScalarWhereInput[]
    NOT?: NarrativeStanceScalarWhereInput | NarrativeStanceScalarWhereInput[]
    id?: StringFilter<"NarrativeStance"> | string
    narrativeId?: StringFilter<"NarrativeStance"> | string
    userId?: StringFilter<"NarrativeStance"> | string
    stance?: StringFilter<"NarrativeStance"> | string
    createdAt?: DateTimeFilter<"NarrativeStance"> | Date | string
    updatedAt?: DateTimeFilter<"NarrativeStance"> | Date | string
  }

  export type UserCreateWithoutFriendshipsAsUserInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipsAsUserInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipsAsUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipsAsUserInput, UserUncheckedCreateWithoutFriendshipsAsUserInput>
  }

  export type UserCreateWithoutFriendshipsAsFriendInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendshipsAsFriendInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendshipsAsFriendInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendshipsAsFriendInput, UserUncheckedCreateWithoutFriendshipsAsFriendInput>
  }

  export type UserUpsertWithoutFriendshipsAsUserInput = {
    update: XOR<UserUpdateWithoutFriendshipsAsUserInput, UserUncheckedUpdateWithoutFriendshipsAsUserInput>
    create: XOR<UserCreateWithoutFriendshipsAsUserInput, UserUncheckedCreateWithoutFriendshipsAsUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipsAsUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipsAsUserInput, UserUncheckedUpdateWithoutFriendshipsAsUserInput>
  }

  export type UserUpdateWithoutFriendshipsAsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipsAsUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFriendshipsAsFriendInput = {
    update: XOR<UserUpdateWithoutFriendshipsAsFriendInput, UserUncheckedUpdateWithoutFriendshipsAsFriendInput>
    create: XOR<UserCreateWithoutFriendshipsAsFriendInput, UserUncheckedCreateWithoutFriendshipsAsFriendInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendshipsAsFriendInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendshipsAsFriendInput, UserUncheckedUpdateWithoutFriendshipsAsFriendInput>
  }

  export type UserUpdateWithoutFriendshipsAsFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendshipsAsFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserMetricsInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserMetricsInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserMetricsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserMetricsInput, UserUncheckedCreateWithoutUserMetricsInput>
  }

  export type UserUpsertWithoutUserMetricsInput = {
    update: XOR<UserUpdateWithoutUserMetricsInput, UserUncheckedUpdateWithoutUserMetricsInput>
    create: XOR<UserCreateWithoutUserMetricsInput, UserUncheckedCreateWithoutUserMetricsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserMetricsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserMetricsInput, UserUncheckedUpdateWithoutUserMetricsInput>
  }

  export type UserUpdateWithoutUserMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NarrativeAssetCreateWithoutNarrativeInput = {
    id?: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
  }

  export type NarrativeAssetUncheckedCreateWithoutNarrativeInput = {
    id?: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
  }

  export type NarrativeAssetCreateOrConnectWithoutNarrativeInput = {
    where: NarrativeAssetWhereUniqueInput
    create: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeAssetCreateManyNarrativeInputEnvelope = {
    data: NarrativeAssetCreateManyNarrativeInput | NarrativeAssetCreateManyNarrativeInput[]
  }

  export type NarrativeEventCreateWithoutNarrativeInput = {
    id?: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type NarrativeEventUncheckedCreateWithoutNarrativeInput = {
    id?: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type NarrativeEventCreateOrConnectWithoutNarrativeInput = {
    where: NarrativeEventWhereUniqueInput
    create: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeEventCreateManyNarrativeInputEnvelope = {
    data: NarrativeEventCreateManyNarrativeInput | NarrativeEventCreateManyNarrativeInput[]
  }

  export type IngestedPostCreateWithoutNarrativeInput = {
    id?: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    ingestedAt?: Date | string
    account: TrackedAccountCreateNestedOneWithoutPostsInput
  }

  export type IngestedPostUncheckedCreateWithoutNarrativeInput = {
    id?: string
    trackedAccountId: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    ingestedAt?: Date | string
  }

  export type IngestedPostCreateOrConnectWithoutNarrativeInput = {
    where: IngestedPostWhereUniqueInput
    create: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput>
  }

  export type IngestedPostCreateManyNarrativeInputEnvelope = {
    data: IngestedPostCreateManyNarrativeInput | IngestedPostCreateManyNarrativeInput[]
  }

  export type CommunityPulseCreateWithoutNarrativeInput = {
    id?: string
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
  }

  export type CommunityPulseUncheckedCreateWithoutNarrativeInput = {
    id?: string
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
  }

  export type CommunityPulseCreateOrConnectWithoutNarrativeInput = {
    where: CommunityPulseWhereUniqueInput
    create: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput>
  }

  export type CommunityPulseCreateManyNarrativeInputEnvelope = {
    data: CommunityPulseCreateManyNarrativeInput | CommunityPulseCreateManyNarrativeInput[]
  }

  export type NarrativeAssetUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeAssetWhereUniqueInput
    update: XOR<NarrativeAssetUpdateWithoutNarrativeInput, NarrativeAssetUncheckedUpdateWithoutNarrativeInput>
    create: XOR<NarrativeAssetCreateWithoutNarrativeInput, NarrativeAssetUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeAssetUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeAssetWhereUniqueInput
    data: XOR<NarrativeAssetUpdateWithoutNarrativeInput, NarrativeAssetUncheckedUpdateWithoutNarrativeInput>
  }

  export type NarrativeAssetUpdateManyWithWhereWithoutNarrativeInput = {
    where: NarrativeAssetScalarWhereInput
    data: XOR<NarrativeAssetUpdateManyMutationInput, NarrativeAssetUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type NarrativeAssetScalarWhereInput = {
    AND?: NarrativeAssetScalarWhereInput | NarrativeAssetScalarWhereInput[]
    OR?: NarrativeAssetScalarWhereInput[]
    NOT?: NarrativeAssetScalarWhereInput | NarrativeAssetScalarWhereInput[]
    id?: StringFilter<"NarrativeAsset"> | string
    narrativeId?: StringFilter<"NarrativeAsset"> | string
    assetSymbol?: StringFilter<"NarrativeAsset"> | string
    impact?: FloatNullableFilter<"NarrativeAsset"> | number | null
    createdAt?: DateTimeFilter<"NarrativeAsset"> | Date | string
  }

  export type NarrativeEventUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeEventWhereUniqueInput
    update: XOR<NarrativeEventUpdateWithoutNarrativeInput, NarrativeEventUncheckedUpdateWithoutNarrativeInput>
    create: XOR<NarrativeEventCreateWithoutNarrativeInput, NarrativeEventUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeEventUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeEventWhereUniqueInput
    data: XOR<NarrativeEventUpdateWithoutNarrativeInput, NarrativeEventUncheckedUpdateWithoutNarrativeInput>
  }

  export type NarrativeEventUpdateManyWithWhereWithoutNarrativeInput = {
    where: NarrativeEventScalarWhereInput
    data: XOR<NarrativeEventUpdateManyMutationInput, NarrativeEventUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type NarrativeEventScalarWhereInput = {
    AND?: NarrativeEventScalarWhereInput | NarrativeEventScalarWhereInput[]
    OR?: NarrativeEventScalarWhereInput[]
    NOT?: NarrativeEventScalarWhereInput | NarrativeEventScalarWhereInput[]
    id?: StringFilter<"NarrativeEvent"> | string
    narrativeId?: StringFilter<"NarrativeEvent"> | string
    eventTime?: DateTimeFilter<"NarrativeEvent"> | Date | string
    description?: StringNullableFilter<"NarrativeEvent"> | string | null
    createdAt?: DateTimeFilter<"NarrativeEvent"> | Date | string
  }

  export type IngestedPostUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: IngestedPostWhereUniqueInput
    update: XOR<IngestedPostUpdateWithoutNarrativeInput, IngestedPostUncheckedUpdateWithoutNarrativeInput>
    create: XOR<IngestedPostCreateWithoutNarrativeInput, IngestedPostUncheckedCreateWithoutNarrativeInput>
  }

  export type IngestedPostUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: IngestedPostWhereUniqueInput
    data: XOR<IngestedPostUpdateWithoutNarrativeInput, IngestedPostUncheckedUpdateWithoutNarrativeInput>
  }

  export type IngestedPostUpdateManyWithWhereWithoutNarrativeInput = {
    where: IngestedPostScalarWhereInput
    data: XOR<IngestedPostUpdateManyMutationInput, IngestedPostUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type IngestedPostScalarWhereInput = {
    AND?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
    OR?: IngestedPostScalarWhereInput[]
    NOT?: IngestedPostScalarWhereInput | IngestedPostScalarWhereInput[]
    id?: StringFilter<"IngestedPost"> | string
    trackedAccountId?: StringFilter<"IngestedPost"> | string
    externalPostId?: StringFilter<"IngestedPost"> | string
    content?: StringFilter<"IngestedPost"> | string
    postedAt?: DateTimeFilter<"IngestedPost"> | Date | string
    engagementLikes?: IntFilter<"IngestedPost"> | number
    engagementRetweets?: IntFilter<"IngestedPost"> | number
    keywords?: StringFilter<"IngestedPost"> | string
    tickers?: StringFilter<"IngestedPost"> | string
    hashtags?: StringFilter<"IngestedPost"> | string
    narrativeId?: StringNullableFilter<"IngestedPost"> | string | null
    ingestedAt?: DateTimeFilter<"IngestedPost"> | Date | string
  }

  export type CommunityPulseUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: CommunityPulseWhereUniqueInput
    update: XOR<CommunityPulseUpdateWithoutNarrativeInput, CommunityPulseUncheckedUpdateWithoutNarrativeInput>
    create: XOR<CommunityPulseCreateWithoutNarrativeInput, CommunityPulseUncheckedCreateWithoutNarrativeInput>
  }

  export type CommunityPulseUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: CommunityPulseWhereUniqueInput
    data: XOR<CommunityPulseUpdateWithoutNarrativeInput, CommunityPulseUncheckedUpdateWithoutNarrativeInput>
  }

  export type CommunityPulseUpdateManyWithWhereWithoutNarrativeInput = {
    where: CommunityPulseScalarWhereInput
    data: XOR<CommunityPulseUpdateManyMutationInput, CommunityPulseUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type CommunityPulseScalarWhereInput = {
    AND?: CommunityPulseScalarWhereInput | CommunityPulseScalarWhereInput[]
    OR?: CommunityPulseScalarWhereInput[]
    NOT?: CommunityPulseScalarWhereInput | CommunityPulseScalarWhereInput[]
    id?: StringFilter<"CommunityPulse"> | string
    narrativeId?: StringNullableFilter<"CommunityPulse"> | string | null
    bullishPercent?: FloatFilter<"CommunityPulse"> | number
    bearishPercent?: FloatFilter<"CommunityPulse"> | number
    neutralPercent?: FloatFilter<"CommunityPulse"> | number
    discussionCount?: IntFilter<"CommunityPulse"> | number
    calculatedAt?: DateTimeFilter<"CommunityPulse"> | Date | string
    period?: StringFilter<"CommunityPulse"> | string
  }

  export type NarrativeCreateWithoutAssetsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: NarrativeEventCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUncheckedCreateWithoutAssetsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: NarrativeEventUncheckedCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostUncheckedCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeCreateOrConnectWithoutAssetsInput = {
    where: NarrativeWhereUniqueInput
    create: XOR<NarrativeCreateWithoutAssetsInput, NarrativeUncheckedCreateWithoutAssetsInput>
  }

  export type NarrativeUpsertWithoutAssetsInput = {
    update: XOR<NarrativeUpdateWithoutAssetsInput, NarrativeUncheckedUpdateWithoutAssetsInput>
    create: XOR<NarrativeCreateWithoutAssetsInput, NarrativeUncheckedCreateWithoutAssetsInput>
    where?: NarrativeWhereInput
  }

  export type NarrativeUpdateToOneWithWhereWithoutAssetsInput = {
    where?: NarrativeWhereInput
    data: XOR<NarrativeUpdateWithoutAssetsInput, NarrativeUncheckedUpdateWithoutAssetsInput>
  }

  export type NarrativeUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: NarrativeEventUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: NarrativeEventUncheckedUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUncheckedUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeCreateWithoutEventsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUncheckedCreateWithoutEventsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetUncheckedCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostUncheckedCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeCreateOrConnectWithoutEventsInput = {
    where: NarrativeWhereUniqueInput
    create: XOR<NarrativeCreateWithoutEventsInput, NarrativeUncheckedCreateWithoutEventsInput>
  }

  export type NarrativeUpsertWithoutEventsInput = {
    update: XOR<NarrativeUpdateWithoutEventsInput, NarrativeUncheckedUpdateWithoutEventsInput>
    create: XOR<NarrativeCreateWithoutEventsInput, NarrativeUncheckedCreateWithoutEventsInput>
    where?: NarrativeWhereInput
  }

  export type NarrativeUpdateToOneWithWhereWithoutEventsInput = {
    where?: NarrativeWhereInput
    data: XOR<NarrativeUpdateWithoutEventsInput, NarrativeUncheckedUpdateWithoutEventsInput>
  }

  export type NarrativeUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUncheckedUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUncheckedUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type UserCreateWithoutSocialPostsInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialPostsInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
  }

  export type PostTickerCreateWithoutPostInput = {
    id?: string
    ticker: string
  }

  export type PostTickerUncheckedCreateWithoutPostInput = {
    id?: string
    ticker: string
  }

  export type PostTickerCreateOrConnectWithoutPostInput = {
    where: PostTickerWhereUniqueInput
    create: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput>
  }

  export type PostTickerCreateManyPostInputEnvelope = {
    data: PostTickerCreateManyPostInput | PostTickerCreateManyPostInput[]
  }

  export type PostLikeCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type PostLikeCreateOrConnectWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeCreateManyPostInputEnvelope = {
    data: PostLikeCreateManyPostInput | PostLikeCreateManyPostInput[]
  }

  export type UserUpsertWithoutSocialPostsInput = {
    update: XOR<UserUpdateWithoutSocialPostsInput, UserUncheckedUpdateWithoutSocialPostsInput>
    create: XOR<UserCreateWithoutSocialPostsInput, UserUncheckedCreateWithoutSocialPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialPostsInput, UserUncheckedUpdateWithoutSocialPostsInput>
  }

  export type UserUpdateWithoutSocialPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostTickerUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTickerWhereUniqueInput
    update: XOR<PostTickerUpdateWithoutPostInput, PostTickerUncheckedUpdateWithoutPostInput>
    create: XOR<PostTickerCreateWithoutPostInput, PostTickerUncheckedCreateWithoutPostInput>
  }

  export type PostTickerUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTickerWhereUniqueInput
    data: XOR<PostTickerUpdateWithoutPostInput, PostTickerUncheckedUpdateWithoutPostInput>
  }

  export type PostTickerUpdateManyWithWhereWithoutPostInput = {
    where: PostTickerScalarWhereInput
    data: XOR<PostTickerUpdateManyMutationInput, PostTickerUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTickerScalarWhereInput = {
    AND?: PostTickerScalarWhereInput | PostTickerScalarWhereInput[]
    OR?: PostTickerScalarWhereInput[]
    NOT?: PostTickerScalarWhereInput | PostTickerScalarWhereInput[]
    id?: StringFilter<"PostTicker"> | string
    postId?: StringFilter<"PostTicker"> | string
    ticker?: StringFilter<"PostTicker"> | string
  }

  export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutPostInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostInput>
  }

  export type SocialPostCreateWithoutTickersInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialPostsInput
    likes?: PostLikeCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateWithoutTickersInput = {
    id?: string
    userId: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    likes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostCreateOrConnectWithoutTickersInput = {
    where: SocialPostWhereUniqueInput
    create: XOR<SocialPostCreateWithoutTickersInput, SocialPostUncheckedCreateWithoutTickersInput>
  }

  export type SocialPostUpsertWithoutTickersInput = {
    update: XOR<SocialPostUpdateWithoutTickersInput, SocialPostUncheckedUpdateWithoutTickersInput>
    create: XOR<SocialPostCreateWithoutTickersInput, SocialPostUncheckedCreateWithoutTickersInput>
    where?: SocialPostWhereInput
  }

  export type SocialPostUpdateToOneWithWhereWithoutTickersInput = {
    where?: SocialPostWhereInput
    data: XOR<SocialPostUpdateWithoutTickersInput, SocialPostUncheckedUpdateWithoutTickersInput>
  }

  export type SocialPostUpdateWithoutTickersInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialPostsNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateWithoutTickersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SocialPostCreateWithoutLikesInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialPostsInput
    tickers?: PostTickerCreateNestedManyWithoutPostInput
  }

  export type SocialPostUncheckedCreateWithoutLikesInput = {
    id?: string
    userId: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickers?: PostTickerUncheckedCreateNestedManyWithoutPostInput
  }

  export type SocialPostCreateOrConnectWithoutLikesInput = {
    where: SocialPostWhereUniqueInput
    create: XOR<SocialPostCreateWithoutLikesInput, SocialPostUncheckedCreateWithoutLikesInput>
  }

  export type UserCreateWithoutPostLikesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostLikesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
  }

  export type SocialPostUpsertWithoutLikesInput = {
    update: XOR<SocialPostUpdateWithoutLikesInput, SocialPostUncheckedUpdateWithoutLikesInput>
    create: XOR<SocialPostCreateWithoutLikesInput, SocialPostUncheckedCreateWithoutLikesInput>
    where?: SocialPostWhereInput
  }

  export type SocialPostUpdateToOneWithWhereWithoutLikesInput = {
    where?: SocialPostWhereInput
    data: XOR<SocialPostUpdateWithoutLikesInput, SocialPostUncheckedUpdateWithoutLikesInput>
  }

  export type SocialPostUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialPostsNestedInput
    tickers?: PostTickerUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateWithoutLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickers?: PostTickerUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPostLikesInput = {
    update: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostLikesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
  }

  export type UserUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostLikesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IngestedPostCreateWithoutAccountInput = {
    id?: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    ingestedAt?: Date | string
    narrative?: NarrativeCreateNestedOneWithoutPostsInput
  }

  export type IngestedPostUncheckedCreateWithoutAccountInput = {
    id?: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    narrativeId?: string | null
    ingestedAt?: Date | string
  }

  export type IngestedPostCreateOrConnectWithoutAccountInput = {
    where: IngestedPostWhereUniqueInput
    create: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput>
  }

  export type IngestedPostCreateManyAccountInputEnvelope = {
    data: IngestedPostCreateManyAccountInput | IngestedPostCreateManyAccountInput[]
  }

  export type IngestedPostUpsertWithWhereUniqueWithoutAccountInput = {
    where: IngestedPostWhereUniqueInput
    update: XOR<IngestedPostUpdateWithoutAccountInput, IngestedPostUncheckedUpdateWithoutAccountInput>
    create: XOR<IngestedPostCreateWithoutAccountInput, IngestedPostUncheckedCreateWithoutAccountInput>
  }

  export type IngestedPostUpdateWithWhereUniqueWithoutAccountInput = {
    where: IngestedPostWhereUniqueInput
    data: XOR<IngestedPostUpdateWithoutAccountInput, IngestedPostUncheckedUpdateWithoutAccountInput>
  }

  export type IngestedPostUpdateManyWithWhereWithoutAccountInput = {
    where: IngestedPostScalarWhereInput
    data: XOR<IngestedPostUpdateManyMutationInput, IngestedPostUncheckedUpdateManyWithoutAccountInput>
  }

  export type TrackedAccountCreateWithoutPostsInput = {
    id?: string
    platform?: string
    accountHandle: string
    accountName?: string | null
    accountType?: string | null
    isActive?: boolean
    lastFetchedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TrackedAccountUncheckedCreateWithoutPostsInput = {
    id?: string
    platform?: string
    accountHandle: string
    accountName?: string | null
    accountType?: string | null
    isActive?: boolean
    lastFetchedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TrackedAccountCreateOrConnectWithoutPostsInput = {
    where: TrackedAccountWhereUniqueInput
    create: XOR<TrackedAccountCreateWithoutPostsInput, TrackedAccountUncheckedCreateWithoutPostsInput>
  }

  export type NarrativeCreateWithoutPostsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetUncheckedCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventUncheckedCreateNestedManyWithoutNarrativeInput
    pulse?: CommunityPulseUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeCreateOrConnectWithoutPostsInput = {
    where: NarrativeWhereUniqueInput
    create: XOR<NarrativeCreateWithoutPostsInput, NarrativeUncheckedCreateWithoutPostsInput>
  }

  export type TrackedAccountUpsertWithoutPostsInput = {
    update: XOR<TrackedAccountUpdateWithoutPostsInput, TrackedAccountUncheckedUpdateWithoutPostsInput>
    create: XOR<TrackedAccountCreateWithoutPostsInput, TrackedAccountUncheckedCreateWithoutPostsInput>
    where?: TrackedAccountWhereInput
  }

  export type TrackedAccountUpdateToOneWithWhereWithoutPostsInput = {
    where?: TrackedAccountWhereInput
    data: XOR<TrackedAccountUpdateWithoutPostsInput, TrackedAccountUncheckedUpdateWithoutPostsInput>
  }

  export type TrackedAccountUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackedAccountUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    accountHandle?: StringFieldUpdateOperationsInput | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeUpsertWithoutPostsInput = {
    update: XOR<NarrativeUpdateWithoutPostsInput, NarrativeUncheckedUpdateWithoutPostsInput>
    create: XOR<NarrativeCreateWithoutPostsInput, NarrativeUncheckedCreateWithoutPostsInput>
    where?: NarrativeWhereInput
  }

  export type NarrativeUpdateToOneWithWhereWithoutPostsInput = {
    where?: NarrativeWhereInput
    data: XOR<NarrativeUpdateWithoutPostsInput, NarrativeUncheckedUpdateWithoutPostsInput>
  }

  export type NarrativeUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUncheckedUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUncheckedUpdateManyWithoutNarrativeNestedInput
    pulse?: CommunityPulseUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeCreateWithoutPulseInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeUncheckedCreateWithoutPulseInput = {
    id?: string
    title: string
    description?: string | null
    triggerType: string
    triggerValue?: string | null
    sentiment: string
    mentionCount?: number
    velocity?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: NarrativeAssetUncheckedCreateNestedManyWithoutNarrativeInput
    events?: NarrativeEventUncheckedCreateNestedManyWithoutNarrativeInput
    posts?: IngestedPostUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type NarrativeCreateOrConnectWithoutPulseInput = {
    where: NarrativeWhereUniqueInput
    create: XOR<NarrativeCreateWithoutPulseInput, NarrativeUncheckedCreateWithoutPulseInput>
  }

  export type NarrativeUpsertWithoutPulseInput = {
    update: XOR<NarrativeUpdateWithoutPulseInput, NarrativeUncheckedUpdateWithoutPulseInput>
    create: XOR<NarrativeCreateWithoutPulseInput, NarrativeUncheckedCreateWithoutPulseInput>
    where?: NarrativeWhereInput
  }

  export type NarrativeUpdateToOneWithWhereWithoutPulseInput = {
    where?: NarrativeWhereInput
    data: XOR<NarrativeUpdateWithoutPulseInput, NarrativeUncheckedUpdateWithoutPulseInput>
  }

  export type NarrativeUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUpdateManyWithoutNarrativeNestedInput
  }

  export type NarrativeUncheckedUpdateWithoutPulseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    sentiment?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: NarrativeAssetUncheckedUpdateManyWithoutNarrativeNestedInput
    events?: NarrativeEventUncheckedUpdateManyWithoutNarrativeNestedInput
    posts?: IngestedPostUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeArticleCreateWithoutNarrativeInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
  }

  export type DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
  }

  export type DetectedNarrativeArticleCreateOrConnectWithoutNarrativeInput = {
    where: DetectedNarrativeArticleWhereUniqueInput
    create: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput>
  }

  export type DetectedNarrativeArticleCreateManyNarrativeInputEnvelope = {
    data: DetectedNarrativeArticleCreateManyNarrativeInput | DetectedNarrativeArticleCreateManyNarrativeInput[]
  }

  export type NarrativeMetricCreateWithoutNarrativeInput = {
    id?: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
  }

  export type NarrativeMetricUncheckedCreateWithoutNarrativeInput = {
    id?: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
  }

  export type NarrativeMetricCreateOrConnectWithoutNarrativeInput = {
    where: NarrativeMetricWhereUniqueInput
    create: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeMetricCreateManyNarrativeInputEnvelope = {
    data: NarrativeMetricCreateManyNarrativeInput | NarrativeMetricCreateManyNarrativeInput[]
  }

  export type NarrativeFollowerCreateWithoutNarrativeInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNarrativeFollowersInput
  }

  export type NarrativeFollowerUncheckedCreateWithoutNarrativeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type NarrativeFollowerCreateOrConnectWithoutNarrativeInput = {
    where: NarrativeFollowerWhereUniqueInput
    create: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeFollowerCreateManyNarrativeInputEnvelope = {
    data: NarrativeFollowerCreateManyNarrativeInput | NarrativeFollowerCreateManyNarrativeInput[]
  }

  export type MarketMessageCreateWithoutNarrativeInput = {
    id?: string
    text: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMarketMessagesInput
  }

  export type MarketMessageUncheckedCreateWithoutNarrativeInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type MarketMessageCreateOrConnectWithoutNarrativeInput = {
    where: MarketMessageWhereUniqueInput
    create: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput>
  }

  export type MarketMessageCreateManyNarrativeInputEnvelope = {
    data: MarketMessageCreateManyNarrativeInput | MarketMessageCreateManyNarrativeInput[]
  }

  export type NarrativeStanceCreateWithoutNarrativeInput = {
    id?: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNarrativeStancesInput
  }

  export type NarrativeStanceUncheckedCreateWithoutNarrativeInput = {
    id?: string
    userId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NarrativeStanceCreateOrConnectWithoutNarrativeInput = {
    where: NarrativeStanceWhereUniqueInput
    create: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeStanceCreateManyNarrativeInputEnvelope = {
    data: NarrativeStanceCreateManyNarrativeInput | NarrativeStanceCreateManyNarrativeInput[]
  }

  export type DetectedNarrativeArticleUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: DetectedNarrativeArticleWhereUniqueInput
    update: XOR<DetectedNarrativeArticleUpdateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedUpdateWithoutNarrativeInput>
    create: XOR<DetectedNarrativeArticleCreateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedCreateWithoutNarrativeInput>
  }

  export type DetectedNarrativeArticleUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: DetectedNarrativeArticleWhereUniqueInput
    data: XOR<DetectedNarrativeArticleUpdateWithoutNarrativeInput, DetectedNarrativeArticleUncheckedUpdateWithoutNarrativeInput>
  }

  export type DetectedNarrativeArticleUpdateManyWithWhereWithoutNarrativeInput = {
    where: DetectedNarrativeArticleScalarWhereInput
    data: XOR<DetectedNarrativeArticleUpdateManyMutationInput, DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type DetectedNarrativeArticleScalarWhereInput = {
    AND?: DetectedNarrativeArticleScalarWhereInput | DetectedNarrativeArticleScalarWhereInput[]
    OR?: DetectedNarrativeArticleScalarWhereInput[]
    NOT?: DetectedNarrativeArticleScalarWhereInput | DetectedNarrativeArticleScalarWhereInput[]
    id?: StringFilter<"DetectedNarrativeArticle"> | string
    narrativeId?: StringFilter<"DetectedNarrativeArticle"> | string
    articleId?: StringFilter<"DetectedNarrativeArticle"> | string
    createdAt?: DateTimeFilter<"DetectedNarrativeArticle"> | Date | string
  }

  export type NarrativeMetricUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeMetricWhereUniqueInput
    update: XOR<NarrativeMetricUpdateWithoutNarrativeInput, NarrativeMetricUncheckedUpdateWithoutNarrativeInput>
    create: XOR<NarrativeMetricCreateWithoutNarrativeInput, NarrativeMetricUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeMetricUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeMetricWhereUniqueInput
    data: XOR<NarrativeMetricUpdateWithoutNarrativeInput, NarrativeMetricUncheckedUpdateWithoutNarrativeInput>
  }

  export type NarrativeMetricUpdateManyWithWhereWithoutNarrativeInput = {
    where: NarrativeMetricScalarWhereInput
    data: XOR<NarrativeMetricUpdateManyMutationInput, NarrativeMetricUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type NarrativeMetricScalarWhereInput = {
    AND?: NarrativeMetricScalarWhereInput | NarrativeMetricScalarWhereInput[]
    OR?: NarrativeMetricScalarWhereInput[]
    NOT?: NarrativeMetricScalarWhereInput | NarrativeMetricScalarWhereInput[]
    id?: StringFilter<"NarrativeMetric"> | string
    narrativeId?: StringFilter<"NarrativeMetric"> | string
    period?: StringFilter<"NarrativeMetric"> | string
    mentionCount?: IntFilter<"NarrativeMetric"> | number
    velocity?: FloatFilter<"NarrativeMetric"> | number
    calculatedAt?: DateTimeFilter<"NarrativeMetric"> | Date | string
  }

  export type NarrativeFollowerUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeFollowerWhereUniqueInput
    update: XOR<NarrativeFollowerUpdateWithoutNarrativeInput, NarrativeFollowerUncheckedUpdateWithoutNarrativeInput>
    create: XOR<NarrativeFollowerCreateWithoutNarrativeInput, NarrativeFollowerUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeFollowerUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeFollowerWhereUniqueInput
    data: XOR<NarrativeFollowerUpdateWithoutNarrativeInput, NarrativeFollowerUncheckedUpdateWithoutNarrativeInput>
  }

  export type NarrativeFollowerUpdateManyWithWhereWithoutNarrativeInput = {
    where: NarrativeFollowerScalarWhereInput
    data: XOR<NarrativeFollowerUpdateManyMutationInput, NarrativeFollowerUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type MarketMessageUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: MarketMessageWhereUniqueInput
    update: XOR<MarketMessageUpdateWithoutNarrativeInput, MarketMessageUncheckedUpdateWithoutNarrativeInput>
    create: XOR<MarketMessageCreateWithoutNarrativeInput, MarketMessageUncheckedCreateWithoutNarrativeInput>
  }

  export type MarketMessageUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: MarketMessageWhereUniqueInput
    data: XOR<MarketMessageUpdateWithoutNarrativeInput, MarketMessageUncheckedUpdateWithoutNarrativeInput>
  }

  export type MarketMessageUpdateManyWithWhereWithoutNarrativeInput = {
    where: MarketMessageScalarWhereInput
    data: XOR<MarketMessageUpdateManyMutationInput, MarketMessageUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type NarrativeStanceUpsertWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeStanceWhereUniqueInput
    update: XOR<NarrativeStanceUpdateWithoutNarrativeInput, NarrativeStanceUncheckedUpdateWithoutNarrativeInput>
    create: XOR<NarrativeStanceCreateWithoutNarrativeInput, NarrativeStanceUncheckedCreateWithoutNarrativeInput>
  }

  export type NarrativeStanceUpdateWithWhereUniqueWithoutNarrativeInput = {
    where: NarrativeStanceWhereUniqueInput
    data: XOR<NarrativeStanceUpdateWithoutNarrativeInput, NarrativeStanceUncheckedUpdateWithoutNarrativeInput>
  }

  export type NarrativeStanceUpdateManyWithWhereWithoutNarrativeInput = {
    where: NarrativeStanceScalarWhereInput
    data: XOR<NarrativeStanceUpdateManyMutationInput, NarrativeStanceUncheckedUpdateManyWithoutNarrativeInput>
  }

  export type DetectedNarrativeCreateWithoutMessagesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateWithoutMessagesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeCreateOrConnectWithoutMessagesInput = {
    where: DetectedNarrativeWhereUniqueInput
    create: XOR<DetectedNarrativeCreateWithoutMessagesInput, DetectedNarrativeUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMarketMessagesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMarketMessagesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMarketMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMarketMessagesInput, UserUncheckedCreateWithoutMarketMessagesInput>
  }

  export type DetectedNarrativeUpsertWithoutMessagesInput = {
    update: XOR<DetectedNarrativeUpdateWithoutMessagesInput, DetectedNarrativeUncheckedUpdateWithoutMessagesInput>
    create: XOR<DetectedNarrativeCreateWithoutMessagesInput, DetectedNarrativeUncheckedCreateWithoutMessagesInput>
    where?: DetectedNarrativeWhereInput
  }

  export type DetectedNarrativeUpdateToOneWithWhereWithoutMessagesInput = {
    where?: DetectedNarrativeWhereInput
    data: XOR<DetectedNarrativeUpdateWithoutMessagesInput, DetectedNarrativeUncheckedUpdateWithoutMessagesInput>
  }

  export type DetectedNarrativeUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type UserUpsertWithoutMarketMessagesInput = {
    update: XOR<UserUpdateWithoutMarketMessagesInput, UserUncheckedUpdateWithoutMarketMessagesInput>
    create: XOR<UserCreateWithoutMarketMessagesInput, UserUncheckedCreateWithoutMarketMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMarketMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMarketMessagesInput, UserUncheckedUpdateWithoutMarketMessagesInput>
  }

  export type UserUpdateWithoutMarketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMarketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNarrativeFollowersInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNarrativeFollowersInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
    narrativeStances?: NarrativeStanceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNarrativeFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNarrativeFollowersInput, UserUncheckedCreateWithoutNarrativeFollowersInput>
  }

  export type DetectedNarrativeCreateWithoutFollowersInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateWithoutFollowersInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeCreateOrConnectWithoutFollowersInput = {
    where: DetectedNarrativeWhereUniqueInput
    create: XOR<DetectedNarrativeCreateWithoutFollowersInput, DetectedNarrativeUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutNarrativeFollowersInput = {
    update: XOR<UserUpdateWithoutNarrativeFollowersInput, UserUncheckedUpdateWithoutNarrativeFollowersInput>
    create: XOR<UserCreateWithoutNarrativeFollowersInput, UserUncheckedCreateWithoutNarrativeFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNarrativeFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNarrativeFollowersInput, UserUncheckedUpdateWithoutNarrativeFollowersInput>
  }

  export type UserUpdateWithoutNarrativeFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNarrativeFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
    narrativeStances?: NarrativeStanceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DetectedNarrativeUpsertWithoutFollowersInput = {
    update: XOR<DetectedNarrativeUpdateWithoutFollowersInput, DetectedNarrativeUncheckedUpdateWithoutFollowersInput>
    create: XOR<DetectedNarrativeCreateWithoutFollowersInput, DetectedNarrativeUncheckedCreateWithoutFollowersInput>
    where?: DetectedNarrativeWhereInput
  }

  export type DetectedNarrativeUpdateToOneWithWhereWithoutFollowersInput = {
    where?: DetectedNarrativeWhereInput
    data: XOR<DetectedNarrativeUpdateWithoutFollowersInput, DetectedNarrativeUncheckedUpdateWithoutFollowersInput>
  }

  export type DetectedNarrativeUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateWithoutFollowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeCreateWithoutMetricsInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateWithoutMetricsInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeCreateOrConnectWithoutMetricsInput = {
    where: DetectedNarrativeWhereUniqueInput
    create: XOR<DetectedNarrativeCreateWithoutMetricsInput, DetectedNarrativeUncheckedCreateWithoutMetricsInput>
  }

  export type DetectedNarrativeUpsertWithoutMetricsInput = {
    update: XOR<DetectedNarrativeUpdateWithoutMetricsInput, DetectedNarrativeUncheckedUpdateWithoutMetricsInput>
    create: XOR<DetectedNarrativeCreateWithoutMetricsInput, DetectedNarrativeUncheckedCreateWithoutMetricsInput>
    where?: DetectedNarrativeWhereInput
  }

  export type DetectedNarrativeUpdateToOneWithWhereWithoutMetricsInput = {
    where?: DetectedNarrativeWhereInput
    data: XOR<DetectedNarrativeUpdateWithoutMetricsInput, DetectedNarrativeUncheckedUpdateWithoutMetricsInput>
  }

  export type DetectedNarrativeUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeCreateWithoutArticlesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: NarrativeMetricCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateWithoutArticlesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput
    stances?: NarrativeStanceUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeCreateOrConnectWithoutArticlesInput = {
    where: DetectedNarrativeWhereUniqueInput
    create: XOR<DetectedNarrativeCreateWithoutArticlesInput, DetectedNarrativeUncheckedCreateWithoutArticlesInput>
  }

  export type DetectedNarrativeUpsertWithoutArticlesInput = {
    update: XOR<DetectedNarrativeUpdateWithoutArticlesInput, DetectedNarrativeUncheckedUpdateWithoutArticlesInput>
    create: XOR<DetectedNarrativeCreateWithoutArticlesInput, DetectedNarrativeUncheckedCreateWithoutArticlesInput>
    where?: DetectedNarrativeWhereInput
  }

  export type DetectedNarrativeUpdateToOneWithWhereWithoutArticlesInput = {
    where?: DetectedNarrativeWhereInput
    data: XOR<DetectedNarrativeUpdateWithoutArticlesInput, DetectedNarrativeUncheckedUpdateWithoutArticlesInput>
  }

  export type DetectedNarrativeUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: NarrativeMetricUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput
    stances?: NarrativeStanceUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeCreateWithoutStancesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeUncheckedCreateWithoutStancesInput = {
    id?: string
    title: string
    summary: string
    sentiment?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: DetectedNarrativeArticleUncheckedCreateNestedManyWithoutNarrativeInput
    metrics?: NarrativeMetricUncheckedCreateNestedManyWithoutNarrativeInput
    followers?: NarrativeFollowerUncheckedCreateNestedManyWithoutNarrativeInput
    messages?: MarketMessageUncheckedCreateNestedManyWithoutNarrativeInput
  }

  export type DetectedNarrativeCreateOrConnectWithoutStancesInput = {
    where: DetectedNarrativeWhereUniqueInput
    create: XOR<DetectedNarrativeCreateWithoutStancesInput, DetectedNarrativeUncheckedCreateWithoutStancesInput>
  }

  export type UserCreateWithoutNarrativeStancesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostCreateNestedManyWithoutUserInput
    postLikes?: PostLikeCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNarrativeStancesInput = {
    id?: string
    username: string
    email?: string | null
    profileMetadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    friendshipsAsUser?: FriendshipUncheckedCreateNestedManyWithoutUserInput
    friendshipsAsFriend?: FriendshipUncheckedCreateNestedManyWithoutFriendInput
    narrativeFollowers?: NarrativeFollowerUncheckedCreateNestedManyWithoutUserInput
    userMetrics?: UserMetricUncheckedCreateNestedManyWithoutUserInput
    socialPosts?: SocialPostUncheckedCreateNestedManyWithoutUserInput
    postLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    marketMessages?: MarketMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNarrativeStancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNarrativeStancesInput, UserUncheckedCreateWithoutNarrativeStancesInput>
  }

  export type DetectedNarrativeUpsertWithoutStancesInput = {
    update: XOR<DetectedNarrativeUpdateWithoutStancesInput, DetectedNarrativeUncheckedUpdateWithoutStancesInput>
    create: XOR<DetectedNarrativeCreateWithoutStancesInput, DetectedNarrativeUncheckedCreateWithoutStancesInput>
    where?: DetectedNarrativeWhereInput
  }

  export type DetectedNarrativeUpdateToOneWithWhereWithoutStancesInput = {
    where?: DetectedNarrativeWhereInput
    data: XOR<DetectedNarrativeUpdateWithoutStancesInput, DetectedNarrativeUncheckedUpdateWithoutStancesInput>
  }

  export type DetectedNarrativeUpdateWithoutStancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUpdateManyWithoutNarrativeNestedInput
  }

  export type DetectedNarrativeUncheckedUpdateWithoutStancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeNestedInput
    metrics?: NarrativeMetricUncheckedUpdateManyWithoutNarrativeNestedInput
    followers?: NarrativeFollowerUncheckedUpdateManyWithoutNarrativeNestedInput
    messages?: MarketMessageUncheckedUpdateManyWithoutNarrativeNestedInput
  }

  export type UserUpsertWithoutNarrativeStancesInput = {
    update: XOR<UserUpdateWithoutNarrativeStancesInput, UserUncheckedUpdateWithoutNarrativeStancesInput>
    create: XOR<UserCreateWithoutNarrativeStancesInput, UserUncheckedCreateWithoutNarrativeStancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNarrativeStancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNarrativeStancesInput, UserUncheckedUpdateWithoutNarrativeStancesInput>
  }

  export type UserUpdateWithoutNarrativeStancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNarrativeStancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    profileMetadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendshipsAsUser?: FriendshipUncheckedUpdateManyWithoutUserNestedInput
    friendshipsAsFriend?: FriendshipUncheckedUpdateManyWithoutFriendNestedInput
    narrativeFollowers?: NarrativeFollowerUncheckedUpdateManyWithoutUserNestedInput
    userMetrics?: UserMetricUncheckedUpdateManyWithoutUserNestedInput
    socialPosts?: SocialPostUncheckedUpdateManyWithoutUserNestedInput
    postLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    marketMessages?: MarketMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FriendshipCreateManyUserInput = {
    id?: string
    friendId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateManyFriendInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type NarrativeFollowerCreateManyUserInput = {
    id?: string
    narrativeId: string
    createdAt?: Date | string
  }

  export type UserMetricCreateManyUserInput = {
    id?: string
    period: string
    returnPercent: number
    winRate: number
    tradesCount?: number
    calculatedAt?: Date | string
  }

  export type SocialPostCreateManyUserInput = {
    id?: string
    content: string
    sentiment: string
    likesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostLikeCreateManyUserInput = {
    id?: string
    postId: string
    createdAt?: Date | string
  }

  export type MarketMessageCreateManyUserInput = {
    id?: string
    narrativeId: string
    text: string
    createdAt?: Date | string
  }

  export type NarrativeStanceCreateManyUserInput = {
    id?: string
    narrativeId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FriendshipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friend?: UserUpdateOneRequiredWithoutFriendshipsAsFriendNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFriendshipsAsUserNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type NarrativeFollowerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserMetricUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    returnPercent?: FloatFieldUpdateOperationsInput | number
    winRate?: FloatFieldUpdateOperationsInput | number
    tradesCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialPostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickers?: PostTickerUpdateManyWithoutPostNestedInput
    likes?: PostLikeUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickers?: PostTickerUncheckedUpdateManyWithoutPostNestedInput
    likes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SocialPostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sentiment?: StringFieldUpdateOperationsInput | string
    likesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: SocialPostUpdateOneRequiredWithoutLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MarketMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: DetectedNarrativeUpdateOneRequiredWithoutStancesNestedInput
  }

  export type NarrativeStanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    narrativeId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetCreateManyNarrativeInput = {
    id?: string
    assetSymbol: string
    impact?: number | null
    createdAt?: Date | string
  }

  export type NarrativeEventCreateManyNarrativeInput = {
    id?: string
    eventTime: Date | string
    description?: string | null
    createdAt?: Date | string
  }

  export type IngestedPostCreateManyNarrativeInput = {
    id?: string
    trackedAccountId: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    ingestedAt?: Date | string
  }

  export type CommunityPulseCreateManyNarrativeInput = {
    id?: string
    bullishPercent: number
    bearishPercent: number
    neutralPercent: number
    discussionCount?: number
    calculatedAt?: Date | string
    period: string
  }

  export type NarrativeAssetUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeAssetUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetSymbol?: StringFieldUpdateOperationsInput | string
    impact?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeEventUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventTime?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: TrackedAccountUpdateOneRequiredWithoutPostsNestedInput
  }

  export type IngestedPostUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackedAccountId?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackedAccountId?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPulseUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityPulseUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type CommunityPulseUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bullishPercent?: FloatFieldUpdateOperationsInput | number
    bearishPercent?: FloatFieldUpdateOperationsInput | number
    neutralPercent?: FloatFieldUpdateOperationsInput | number
    discussionCount?: IntFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: StringFieldUpdateOperationsInput | string
  }

  export type PostTickerCreateManyPostInput = {
    id?: string
    ticker: string
  }

  export type PostLikeCreateManyPostInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type PostTickerUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostTickerUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostTickerUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostCreateManyAccountInput = {
    id?: string
    externalPostId: string
    content: string
    postedAt: Date | string
    engagementLikes?: number
    engagementRetweets?: number
    keywords: string
    tickers: string
    hashtags: string
    narrativeId?: string | null
    ingestedAt?: Date | string
  }

  export type IngestedPostUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    narrative?: NarrativeUpdateOneWithoutPostsNestedInput
  }

  export type IngestedPostUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedPostUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalPostId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementLikes?: IntFieldUpdateOperationsInput | number
    engagementRetweets?: IntFieldUpdateOperationsInput | number
    keywords?: StringFieldUpdateOperationsInput | string
    tickers?: StringFieldUpdateOperationsInput | string
    hashtags?: StringFieldUpdateOperationsInput | string
    narrativeId?: NullableStringFieldUpdateOperationsInput | string | null
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleCreateManyNarrativeInput = {
    id?: string
    articleId: string
    createdAt?: Date | string
  }

  export type NarrativeMetricCreateManyNarrativeInput = {
    id?: string
    period: string
    mentionCount: number
    velocity: number
    calculatedAt?: Date | string
  }

  export type NarrativeFollowerCreateManyNarrativeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type MarketMessageCreateManyNarrativeInput = {
    id?: string
    userId: string
    text: string
    createdAt?: Date | string
  }

  export type NarrativeStanceCreateManyNarrativeInput = {
    id?: string
    userId: string
    stance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetectedNarrativeArticleUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedNarrativeArticleUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeMetricUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    mentionCount?: IntFieldUpdateOperationsInput | number
    velocity?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNarrativeFollowersNestedInput
  }

  export type NarrativeFollowerUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeFollowerUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMarketMessagesNestedInput
  }

  export type MarketMessageUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketMessageUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNarrativeStancesNestedInput
  }

  export type NarrativeStanceUncheckedUpdateWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NarrativeStanceUncheckedUpdateManyWithoutNarrativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeCountOutputTypeDefaultArgs instead
     */
    export type NarrativeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialPostCountOutputTypeDefaultArgs instead
     */
    export type SocialPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SocialPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackedAccountCountOutputTypeDefaultArgs instead
     */
    export type TrackedAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackedAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetectedNarrativeCountOutputTypeDefaultArgs instead
     */
    export type DetectedNarrativeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetectedNarrativeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FriendshipDefaultArgs instead
     */
    export type FriendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FriendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserMetricDefaultArgs instead
     */
    export type UserMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeDefaultArgs instead
     */
    export type NarrativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeAssetDefaultArgs instead
     */
    export type NarrativeAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeEventDefaultArgs instead
     */
    export type NarrativeEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SocialPostDefaultArgs instead
     */
    export type SocialPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SocialPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostTickerDefaultArgs instead
     */
    export type PostTickerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostTickerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostLikeDefaultArgs instead
     */
    export type PostLikeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostLikeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackedAccountDefaultArgs instead
     */
    export type TrackedAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackedAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngestedPostDefaultArgs instead
     */
    export type IngestedPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngestedPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunityPulseDefaultArgs instead
     */
    export type CommunityPulseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunityPulseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsArticleDefaultArgs instead
     */
    export type NewsArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsSourceDefaultArgs instead
     */
    export type NewsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsSourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleEntityDefaultArgs instead
     */
    export type ArticleEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleEntityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetectedNarrativeDefaultArgs instead
     */
    export type DetectedNarrativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetectedNarrativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketMessageDefaultArgs instead
     */
    export type MarketMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeFollowerDefaultArgs instead
     */
    export type NarrativeFollowerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeFollowerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeMetricDefaultArgs instead
     */
    export type NarrativeMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetectedNarrativeArticleDefaultArgs instead
     */
    export type DetectedNarrativeArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetectedNarrativeArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NarrativeStanceDefaultArgs instead
     */
    export type NarrativeStanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NarrativeStanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExternalPostDefaultArgs instead
     */
    export type ExternalPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExternalPostDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}